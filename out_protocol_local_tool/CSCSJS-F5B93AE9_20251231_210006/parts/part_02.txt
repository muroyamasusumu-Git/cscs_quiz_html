<<<PART_BEGIN>>>
【分割コード(2)の開始】
PartID: CSCSJS-F5B93AE9-P02-of-04
PartSHA256: 400f949cd0ff7f2e09b82aa098f636affec9c70e7e70bb9d31aaf1c40b84e340
Range: chars 43632..88875 (len=45243)
FirstLine:               if (type === "lastCorrect" && bestType === "lastWrong") {
LastLine: 
EndNewline: YES

```javascript
              if (type === "lastCorrect" && bestType === "lastWrong") {
                bestType = "lastCorrect";
              }
            }
          }

          consider("lastCorrect", cS);
          consider("lastWrong",  wS);
          consider("lastCorrect", cL);
          consider("lastWrong",  wL);

          return bestType;
        }

        const latestType = pickLatestType();
        const latestSyncVal  = (latestType === "lastWrong") ? lastWrongSync  : lastCorrectSync;
        const latestLocalVal = (latestType === "lastWrong") ? lastWrongLocal : lastCorrectLocal;

        if (lastdaySummaryTypeEl) {
          // ★ summary の種別表示は 1行で読みやすい “LastWrong / LastCorrect” に統一
          lastdaySummaryTypeEl.textContent = (latestType === "lastWrong") ? "LastWrong" : "LastCorrect";
        }
        if (lastdaySummarySyncEl) {
          // ★ summary の SYNC 値（8桁日付 or データなし）
          //   - 表示は「SYNC 20251210」のようにラベル込みにする
          lastdaySummarySyncEl.textContent = "SYNC " + toDisplayText(latestSyncVal, "-");
        }
        if (lastdaySummaryLocalEl) {
          // ★ summary の local 値（8桁日付 or データなし）
          //   - 表示は「local 20251210」のようにラベル込みにする
          lastdaySummaryLocalEl.textContent = "local " + toDisplayText(latestLocalVal, "-");
        }

        // ★ 追加: 見出しと下の詳細が “同じ情報で二重表示” にならないように調整する
        // ★ 処理1: 見出しが LastCorrect の場合 → 下の lastCorrect 行を非表示
        // ★ 処理2: 見出しが LastWrong   の場合 → 下の lastWrong 行を非表示
        // ★ 処理3: 見出しがどちらでもない/未判定の場合 → 両方表示（ここではフォールバック推測はしない）
        try{
          const hideCorrect = (latestType === "lastCorrect");
          const hideWrong   = (latestType === "lastWrong");

          const correctRows = box.querySelectorAll(".lastday-grid .ld-row-lastcorrect");
          const wrongRows   = box.querySelectorAll(".lastday-grid .ld-row-lastwrong");

          correctRows.forEach(function(el){
            el.style.display = hideCorrect ? "none" : "";
          });
          wrongRows.forEach(function(el){
            el.style.display = hideWrong ? "none" : "";
          });
        }catch(_){}

        // ★ lastday は折りたたみ無し：見出し差し替え（open判定）は不要

        const lEl  = box.querySelector(".sync-local");
        const qdEl = box.querySelector(".sync-queue");
        const stEl = box.querySelector(".sync-status");
        const s3El = box.querySelector(".sync-streak3-val");
        const s3sEl = box.querySelector(".sync-streak3-server");
        const slEl = box.querySelector(".sync-streaklen-val");
        const slsEl = box.querySelector(".sync-streaklen-server");
        const slsProgEl = box.querySelector(".sync-streaklen-server-progress");
        const sllProgEl = box.querySelector(".sync-streaklen-local-progress");

        // ★ 不正解ストリーク用 DOM 取得
        const s3wEl  = box.querySelector(".sync-wrong-streak3-val");
        const s3wsEl = box.querySelector(".sync-wrong-streak3-server");
        const slwEl  = box.querySelector(".sync-wrong-streaklen-val");
        const slwsEl = box.querySelector(".sync-wrong-streaklen-server");
        const slwsProgEl = box.querySelector(".sync-wrong-streaklen-server-progress");
        const sllwProgEl = box.querySelector(".sync-wrong-streaklen-local-progress");

        if (qEl)   qEl.textContent  = QID ? QID : "-";
        if (lEl) {
          // ★ 処理1: null は "-" 表示（0埋め禁止）
          const lcText = (lc === null) ? "-" : String(lc);
          const liText = (li === null) ? "-" : String(li);
          lEl.textContent  = "local  " + lcText + " / " + liText;

          // ★ 処理2: 反映成功ログ（欠損有無も出す）
          console.log("[SYNC-A][UI] local totals display updated", {
            qid: QID,
            correct: lc,
            wrong: li,
            missing: (lc === null || li === null)
          });
        }

        if (qdEl)  qdEl.textContent = "+Δ    " + dC + " / " + dI;

        if (s3El) {
          // ★ 処理3: null は "-" 表示（0埋め禁止）
          s3El.textContent = (ls === null) ? "-" : String(ls);

          // ★ 処理4: 反映成功ログ
          console.log("[SYNC-A][UI] local streak3 display updated", {
            qid: QID,
            streak3: ls,
            missing: (ls === null)
          });
        }

        // ★ 処理: server streak3 は欠損なら "-"（0埋め禁止）
        if (s3sEl) s3sEl.textContent = (ss === null) ? "-" : String(ss);

        // ★ 追加: streak max カード（A）に localStorage の値を反映
        //   - len: 現在の連続正解数（cscs_q_correct_streak_len:{qid}）
        //   - max: 最高連続正解数（cscs_q_correct_streak_max:{qid}）
        //   - day: 最高を更新した日（cscs_q_correct_streak_max_day:{qid}）
        if (streakMaxLenEl) streakMaxLenEl.textContent = toDisplayText(lMax !== null && lMax !== undefined ? ll : "", "-");
        if (streakMaxValEl) streakMaxValEl.textContent = toDisplayText(lMax !== null && lMax !== undefined ? lMax : "", "-");
        if (streakMaxDayEl) streakMaxDayEl.textContent = toDisplayText(lMaxDay, "-");

        // ★ 追加: 不正解 streak max カード（A）に localStorage の値を反映
        //   - len: 現在の連続不正解数（cscs_q_wrong_streak_len:{qid}）
        //   - max: 最高連続不正解数（cscs_q_wrong_streak_max:{qid}）
        //   - day: 最高を更新した日（cscs_q_wrong_streak_max_day:{qid}）
        if (wrongStreakMaxLenEl) wrongStreakMaxLenEl.textContent = toDisplayText(lWrongMax !== null && lWrongMax !== undefined ? llWrong : "", "-");
        if (wrongStreakMaxValEl) wrongStreakMaxValEl.textContent = toDisplayText(lWrongMax !== null && lWrongMax !== undefined ? lWrongMax : "", "-");
        if (wrongStreakMaxDayEl) wrongStreakMaxDayEl.textContent = toDisplayText(lWrongMaxDay, "-");

        // ★ 追加: 初回だけ「UI反映に成功した」ログを出す（コンソールで確認可能）
        if (!loggedStreakMaxUiOnce) {
          console.log("[SYNC-A] streak-max card updated (localStorage)", {
            qid: QID,
            streakLen: ll,
            streakMax: lMax,
            streakMaxDay: lMaxDay
          });
          loggedStreakMaxUiOnce = true;
        }

        // ★ 追加: 初回だけ「不正解 streak max カード反映に成功した」ログを出す（コンソールで確認可能）
        if (!loggedWrongStreakMaxUiOnce) {
          console.log("[SYNC-A] wrong-streak-max card updated (localStorage)", {
            qid: QID,
            wrongStreakLen: llWrong,
            wrongStreakMax: lWrongMax,
            wrongStreakMaxDay: lWrongMaxDay
          });
          loggedWrongStreakMaxUiOnce = true;
        }

        if (slEl) {
          // ★ 処理1: null は "-" 表示（0埋め禁止）
          slEl.textContent = (ll === null) ? "-" : String(ll);

          // ★ 処理2: 反映成功ログ
          console.log("[SYNC-A][UI] local streakLen display updated", {
            qid: QID,
            streakLen: ll,
            missing: (ll === null)
          });
        }

        // ★ 処理: server streakLen は欠損なら "-"（0埋め禁止）
        if (slsEl)       slsEl.textContent       = (sl === null) ? "-" : String(sl);

        if (slsProgEl) {
          // ★ 処理3: null は "-" 表示（推測で 0 にしない）
          slsProgEl.textContent = (serverProgress === null) ? "-" : String(serverProgress);

          // ★ 処理4: 反映成功ログ
          console.log("[SYNC-A][UI] server progress display updated", {
            qid: QID,
            serverProgress: serverProgress,
            missing: (serverProgress === null)
          });
        }

        if (sllProgEl) {
          // ★ 処理5: null は "-" 表示（推測で 0 にしない）
          sllProgEl.textContent = (localProgress === null) ? "-" : String(localProgress);

          // ★ 処理6: 反映成功ログ
          console.log("[SYNC-A][UI] local progress display updated", {
            qid: QID,
            localProgress: localProgress,
            missing: (localProgress === null)
          });
        }

        // ★ 不正解ストリークの値を UI に反映（欠損は "-"、0 は本当に 0 の時だけ）
        if (s3wEl)  s3wEl.textContent  = (lsWrong === null) ? "-" : String(lsWrong);
        if (s3wsEl) s3wsEl.textContent = (ssWrong === null) ? "-" : String(ssWrong);
        if (slwEl)  slwEl.textContent  = (llWrong === null) ? "-" : String(llWrong);
        if (slwsEl) slwsEl.textContent = (slWrong === null) ? "-" : String(slWrong);

        // ★ 処理: progress は “計算できる時だけ” 数字、できなければ "-"（0埋め禁止）
        if (slwsProgEl) slwsProgEl.textContent = (serverWrongProgress === null) ? "-" : String(serverWrongProgress);
        if (sllwProgEl) sllwProgEl.textContent  = (localWrongProgress === null) ? "-" : String(localWrongProgress);

        // ★ 追加: キュー（+Δ）に “Totals(c/w) 以外” の溜まり具合を表示（A）
        //   - streakLenDelta / streakWrongLenDelta は「増分」ではなく「最新値」なので、そのまま表示する
        //   - last*DayDelta も「最新値」なので、そのまま表示する
        // ★ 処理: 「|| 0」禁止。欠損は null のまま保持して “取れていない” を明確化する
        const hasQdS3  = Object.prototype.hasOwnProperty.call(queue.streak3Delta, QID);
        const qdS3     = hasQdS3 ? queue.streak3Delta[QID] : null;

        const qdSL  = Object.prototype.hasOwnProperty.call(queue.streakLenDelta, QID) ? queue.streakLenDelta[QID] : null;

        const hasQdS3W = Object.prototype.hasOwnProperty.call(queue.streak3WrongDelta, QID);
        const qdS3W    = hasQdS3W ? queue.streak3WrongDelta[QID] : null;

        const qdSLW = Object.prototype.hasOwnProperty.call(queue.streakWrongLenDelta, QID) ? queue.streakWrongLenDelta[QID] : null;

        // ★ 処理: 欠損/数値をコンソールで確実に判別できるログ
        console.log("[SYNC-A][NO-FALLBACK][QUEUE] detail snapshot", {
          qid: QID,
          qdS3: qdS3,
          qdS3W: qdS3W,
          qdSL: qdSL,
          qdSLW: qdSLW,
          missing: { qdS3: !hasQdS3, qdS3W: !hasQdS3W }
        });

        const qdSeen = Object.prototype.hasOwnProperty.call(queue.lastSeenDayDelta, QID) ? queue.lastSeenDayDelta[QID] : "";
        const qdCor  = Object.prototype.hasOwnProperty.call(queue.lastCorrectDayDelta, QID) ? queue.lastCorrectDayDelta[QID] : "";
        const qdWrg  = Object.prototype.hasOwnProperty.call(queue.lastWrongDayDelta, QID) ? queue.lastWrongDayDelta[QID] : "";

        // ★ 処理1: 欠損（null/undefined）を "0" で埋めず、「-」として可視化する
        if (qdCwEl)   qdCwEl.textContent   = toDisplayText(dC, "-") + " / " + toDisplayText(dI, "-");
        // ★ 処理2: 欠損（null/undefined）を "0" で埋めず、「-」として可視化する
        if (qdS3El)   qdS3El.textContent   = toDisplayText(qdS3, "-");
        // ★ 処理3: streakLenDelta は「最新値」なので、欠損時のみ「（なし）」を表示する（推測で数値化しない）
        if (qdSLel)   qdSLel.textContent   = toDisplayText(qdSL !== null && qdSL !== undefined ? qdSL : "", "（なし）");
        // ★ 処理4: 欠損（null/undefined）を "0" で埋めず、「-」として可視化する
        if (qdS3wEl)  qdS3wEl.textContent  = toDisplayText(qdS3W, "-");
        // ★ 処理5: streakWrongLenDelta は「最新値」なので、欠損時のみ「（なし）」を表示する（推測で数値化しない）
        if (qdSLwEl)  qdSLwEl.textContent  = toDisplayText(qdSLW !== null && qdSLW !== undefined ? qdSLW : "", "（なし）");

        // ★ 処理6: 反映が確実に成功したかをコンソールで確認できるログ（欠損/表示文字列も併記）
        console.log("[SYNC-A][OK][UI] queue detail text updated (no-fallback)", {
          qid: QID,
          raw: {
            dC: dC,
            dI: dI,
            qdS3: qdS3,
            qdS3W: qdS3W,
            qdSL: qdSL,
            qdSLW: qdSLW
          },
          rendered: {
            cw: (qdCwEl ? qdCwEl.textContent : null),
            s3: (qdS3El ? qdS3El.textContent : null),
            sl: (qdSLel ? qdSLel.textContent : null),
            s3w: (qdS3wEl ? qdS3wEl.textContent : null),
            slw: (qdSLwEl ? qdSLwEl.textContent : null)
          }
        });

        if (qdSeenEl) qdSeenEl.textContent = toDisplayText(qdSeen, "（なし）");
        if (qdCorEl)  qdCorEl.textContent  = toDisplayText(qdCor, "（なし）");
        if (qdWrgEl)  qdWrgEl.textContent  = toDisplayText(qdWrg, "（なし）");

        const time = lastSyncTime ? lastSyncTime : "-";
        const err  = lastSyncError ? (" err:" + lastSyncError) : "";

        // oncePerDayToday の計測状況を別行として表示するためのラベル文字列を作成
        // ★ 追加: ODOA: ON/OFF / count対象 / 理由 を同じ行に付加して表示する
        let onceLabel = "";
        let odoaLabel = "ODOA: unknown";
        let countLabel = "count対象: unknown";
        let reasonLabel = "理由: unknown";

        try{
          const state = (window.__cscs_sync_state && typeof window.__cscs_sync_state === "object")
            ? window.__cscs_sync_state
            : null;

          let todayYmd = null;
          try{
            const now = new Date();
            const yy = now.getFullYear();
            const mm = now.getMonth() + 1;
            const dd = now.getDate();
            todayYmd = yy * 10000 + mm * 100 + dd;
          }catch(_eDate){
            todayYmd = null;
          }

          const once = state && state.oncePerDayToday && typeof state.oncePerDayToday === "object"
            ? state.oncePerDayToday
            : null;

          if (
            once &&
            typeof once.day === "number" &&
            todayYmd !== null &&
            once.day === todayYmd &&
            once.results &&
            typeof once.results === "object"
          ) {
            const r = once.results[QID];
            if (r === "correct" || r === "wrong") {
              // 計測済（correct / wrong）
              onceLabel = "計測済(" + r + ")";
            } else if (Object.prototype.hasOwnProperty.call(once.results, QID)) {
              // 何かしら値はあるが unknown の場合
              onceLabel = "計測済(unknown)";
            } else {
              // 今日の日付だがこの QID は未計測
              onceLabel = "未計測";
            }
          } else {
            // oncePerDayToday 自体が今日ではない or データなし
            onceLabel = "未計測";
          }
        }catch(_eOnce){
          // oncePerDayToday 表示に失敗してもステータス自体は出す
          onceLabel = "";
        }

        // ★ 変更: ODOA の状態と count対象判定は「唯一の参照元」を固定する
        //   参照元:
        //     (1) window.CSCS_ODOA_MODE            … "on" / "off"
        //     (2) window.__cscs_sync_state.oncePerDayToday … { day, results }
        //     (3) window.CSCS_VERIFY_MODE         … "on" の場合は常に計測対象外
        //   方針:
        //     - localStorage 等へのフォールバックは行わない（取れなければ unknown 表示）
        try{
          // (1) ODOA モード表示：window.CSCS_ODOA_MODE をそのまま正とする
          const odoaMode = (typeof window.CSCS_ODOA_MODE === "string") ? window.CSCS_ODOA_MODE : "";
          if (odoaMode === "on") {
            odoaLabel = "ODOA: ON";
          } else if (odoaMode === "off") {
            odoaLabel = "ODOA: OFF";
          } else {
            odoaLabel = "ODOA: unknown";
          }

          // (2) VERIFY モード：ON の場合は常に「count対象: NO」
          const verifyModeOn =
            (typeof window.CSCS_VERIFY_MODE === "string" && window.CSCS_VERIFY_MODE === "on");

          if (verifyModeOn) {
            countLabel = "count対象: NO";
            reasonLabel = "理由: VERIFY_MODE";
          } else {
            // (3) oncePerDayToday を __cscs_sync_state から取得（ここ以外からは取らない）
            const state = (window.__cscs_sync_state && typeof window.__cscs_sync_state === "object")
              ? window.__cscs_sync_state
              : null;

            const once = (state && state.oncePerDayToday && typeof state.oncePerDayToday === "object")
              ? state.oncePerDayToday
              : null;

            // (4) 今日 YYYYMMDD（数値）を作る（once.day が number の想定に合わせる）
            let todayYmd = null;
            try{
              const now = new Date();
              const yy = now.getFullYear();
              const mm = now.getMonth() + 1;
              const dd = now.getDate();
              todayYmd = yy * 10000 + mm * 100 + dd;
            }catch(_eDate){
              todayYmd = null;
            }

            // (5) count対象判定
            //   - ODOA: OFF → count対象: YES（ODOA制限が無い）
            //   - ODOA: ON  → 今日すでに oncePerDayToday.results[QID] があれば count対象: NO
            //   - 情報が取れない場合は unknown
            if (odoaMode === "off") {
              countLabel = "count対象: YES";
              reasonLabel = "理由: ODOA_OFF";
            } else if (odoaMode === "on") {
              if (
                once &&
                typeof once.day === "number" &&
                todayYmd !== null &&
                once.day === todayYmd &&
                once.results &&
                typeof once.results === "object"
              ) {
                const hasEntry = Object.prototype.hasOwnProperty.call(once.results, QID);
                if (hasEntry) {
                  countLabel = "count対象: NO";
                  reasonLabel = "理由: ALREADY_MEASURED_TODAY";
                } else {
                  countLabel = "count対象: YES";
                  reasonLabel = "理由: NOT_MEASURED_TODAY";
                }
              } else {
                countLabel = "count対象: unknown";
                reasonLabel = "理由: ONCEPERDAY_STATE_UNAVAILABLE";
              }
            } else {
              countLabel = "count対象: unknown";
              reasonLabel = "理由: ODOA_MODE_UNKNOWN";
            }
          }
        }catch(_eOdoa){
          // ★ 補足: 参照元が壊れていた/例外になった場合は unknown 表示に倒す（フォールバック取得はしない）
          odoaLabel = "ODOA: unknown";
          countLabel = "count対象: unknown";
          reasonLabel = "理由: unknown";
        }

        if (stEl) stEl.textContent = lastSyncStatus + " (" + time + ")" + err;

        const onceElSync  = box.querySelector(".sync-onceperday.sync");
        const onceElLocal = box.querySelector(".sync-onceperday.local");

        // ============================================================
        // ★ SYNC由来カード：既存ロジック（参照元 = window.__cscs_sync_state）を維持して描画
        // ------------------------------------------------------------
        // - 表示は従来の4行構成
        // - フォールバックで別ソースから埋め合わせない（取れなければ取れない表示）
        // ============================================================
        if (onceElSync) {
          function ymdNumToIso(ymdNum){
            try{
              const s = String(ymdNum);
              if (!/^\d{8}$/.test(s)) return "";
              return s.slice(0,4) + "-" + s.slice(4,6) + "-" + s.slice(6,8);
            }catch(_){
              return "";
            }
          }

          function ymdStrToIso(ymdStr){
            try{
              const s = String(ymdStr || "").trim();
              if (!/^\d{8}$/.test(s)) return "";
              return s.slice(0,4) + "-" + s.slice(4,6) + "-" + s.slice(6,8);
            }catch(_){
              return "";
            }
          }

          function getTodayYmdNum(){
            try{
              const now = new Date();
              const yy = now.getFullYear();
              const mm = now.getMonth() + 1;
              const dd = now.getDate();
              return yy * 10000 + mm * 100 + dd;
            }catch(_){
              return null;
            }
          }

          // ★ 処理: 参照元を固定（SYNC snapshot のみ）
          const state = (window.__cscs_sync_state && typeof window.__cscs_sync_state === "object")
            ? window.__cscs_sync_state
            : null;

          const once = (state && state.oncePerDayToday && typeof state.oncePerDayToday === "object")
            ? state.oncePerDayToday
            : null;

          const odoaMode = (typeof window.CSCS_ODOA_MODE === "string") ? window.CSCS_ODOA_MODE : "";
          const odoaText = (odoaMode === "on") ? "ON" : (odoaMode === "off") ? "OFF" : "unknown";

          const todayYmd = getTodayYmdNum();

          let isTodayOnce = false;
          let onceDayIso = "";
          let lastRecordedDayIso = "";
          let measuredResult = null; // "correct" | "wrong" | null

          try{
            let onceDayNum = null;

            if (once && typeof once.day === "number" && Number.isFinite(once.day) && once.day > 0) {
              onceDayNum = once.day;
              const iso = ymdNumToIso(onceDayNum);
              if (iso) {
                lastRecordedDayIso = iso;
              }
            } else if (once && typeof once.day === "string") {
              const iso = ymdStrToIso(once.day);
              if (iso) {
                lastRecordedDayIso = iso;
              }
              if (/^\d{8}$/.test(String(once.day || "").trim())) {
                onceDayNum = parseInt(String(once.day).trim(), 10);
              }
            }

            if (todayYmd !== null && onceDayNum !== null && onceDayNum === todayYmd) {
              isTodayOnce = true;
              onceDayIso = ymdNumToIso(todayYmd);

              if (once && once.results && typeof once.results === "object") {
                const r = once.results[QID];
                if (r === "correct" || r === "wrong") {
                  measuredResult = r;
                } else if (Object.prototype.hasOwnProperty.call(once.results, QID)) {
                  measuredResult = "unknown";
                } else {
                  measuredResult = null;
                }
              } else {
                measuredResult = null;
              }
            }
          }catch(_){
            isTodayOnce = false;
            measuredResult = null;
          }

          let line1 = "";
          let line2 = "";
          let line3 = "";
          let line4 = "";

          if (!isTodayOnce) {
            line1 = "oncePerDayToday: 未開始";
            line2 = "lastRecordedDay: " + (lastRecordedDayIso ? lastRecordedDayIso : "-");
            line3 = "count対象: 判定可能";
            line4 = "ODOA: " + odoaText + " (累計加算: Yes)";
          } else {
            line1 = "oncePerDayToday: 計測中";
            line2 = "Today: " + (onceDayIso ? onceDayIso : "-");

            if (measuredResult === "correct" || measuredResult === "wrong") {
              line3 = "count対象: No 計測済(" + measuredResult + ")";
            } else if (measuredResult === "unknown") {
              line3 = "count対象: No 計測済(unknown)";
            } else {
              line3 = "count対象: Yes 未計測";
            }

            let addYesNo = "Yes";
            if (odoaMode === "off") {
              addYesNo = "Yes";
            } else if (odoaMode === "on") {
              const counted = (measuredResult === "correct" || measuredResult === "wrong" || measuredResult === "unknown");
              addYesNo = counted ? "No" : "Yes";
            } else {
              addYesNo = "unknown";
            }
            line4 = "ODOA: " + odoaText + " (累計加算: " + addYesNo + ")";
          }

          onceElSync.innerHTML =
            '<div class="once-grid">' +

              '<div class="once-label">oncePerDayToday</div>' +
              '<div class="once-val">' + line1.replace(/^oncePerDayToday:\s*/, "") + '</div>' +

              '<div class="once-label">' +
                (isTodayOnce ? 'Today' : 'lastRecordedDay') +
              '</div>' +
              '<div class="once-val">' +
                (isTodayOnce
                  ? line2.replace(/^Today:\s*/, "")
                  : line2.replace(/^lastRecordedDay:\s*/, "")
                ) +
              '</div>' +

              '<div class="once-label">count対象</div>' +
              '<div class="once-val">' +
                line3.replace(/^count対象:\s*/, "") +
              '</div>' +

              '<div class="once-label">ODOA</div>' +
              '<div class="once-val">' +
                line4.replace(/^ODOA:\s*/, "") +
              '</div>' +

            '</div>';
        }

        // ============================================================
        // ★ local由来カード：参照元 = localStorage（SYNC snapshot を参照しない）
        // ------------------------------------------------------------
        // - oncePerDayToday: localStorage の day/results をそのまま読む
        // - ODOA/VERIFY: window のフラグだけを読む（localStorage等へフォールバックしない）
        // - 欠損は欠損として扱い、0埋め・推測はしない
        // ============================================================
        if (onceElLocal) {
          function ymdNumToIso(ymdNum){
            try{
              const s = String(ymdNum);
              if (!/^\d{8}$/.test(s)) return "";
              return s.slice(0,4) + "-" + s.slice(4,6) + "-" + s.slice(6,8);
            }catch(_){
              return "";
            }
          }

          function getTodayYmdNum(){
            try{
              const now = new Date();
              const yy = now.getFullYear();
              const mm = now.getMonth() + 1;
              const dd = now.getDate();
              return yy * 10000 + mm * 100 + dd;
            }catch(_){
              return null;
            }
          }

          // ★ 処理: localStorage から oncePerDayToday の day/results を取得する
          let localDayNum = null;
          let localResults = null;

          try{
            const rawDay = localStorage.getItem("cscs_once_per_day_today_day");
            if (rawDay !== null && rawDay !== undefined) {
              const s = String(rawDay).trim();
              if (/^\d{8}$/.test(s)) {
                localDayNum = parseInt(s, 10);
              }
            }
          }catch(_){
            localDayNum = null;
          }

          try{
            const rawRes = localStorage.getItem("cscs_once_per_day_today_results");
            if (rawRes !== null && rawRes !== undefined) {
              const s = String(rawRes).trim();
              if (s !== "") {
                const parsed = JSON.parse(s);
                if (parsed && typeof parsed === "object") {
                  localResults = parsed;
                }
              }
            }
          }catch(_){
            localResults = null;
          }

          const odoaMode = (typeof window.CSCS_ODOA_MODE === "string") ? window.CSCS_ODOA_MODE : "";
          const odoaText = (odoaMode === "on") ? "ON" : (odoaMode === "off") ? "OFF" : "unknown";

          const verifyModeOn =
            (typeof window.CSCS_VERIFY_MODE === "string" && window.CSCS_VERIFY_MODE === "on");

          const todayYmd = getTodayYmdNum();

          let isTodayOnce = false;
          let onceDayIso = "";
          let lastRecordedDayIso = "";
          let measuredResult = null; // "correct" | "wrong" | "unknown" | null

          try{
            if (localDayNum !== null) {
              const iso = ymdNumToIso(localDayNum);
              if (iso) {
                lastRecordedDayIso = iso;
              }
            }

            if (todayYmd !== null && localDayNum !== null && localDayNum === todayYmd) {
              isTodayOnce = true;
              onceDayIso = ymdNumToIso(todayYmd);

              if (localResults && typeof localResults === "object") {
                const r = localResults[QID];
                if (r === "correct" || r === "wrong") {
                  measuredResult = r;
                } else if (Object.prototype.hasOwnProperty.call(localResults, QID)) {
                  measuredResult = "unknown";
                } else {
                  measuredResult = null;
                }
              } else {
                measuredResult = null;
              }
            }
          }catch(_){
            isTodayOnce = false;
            measuredResult = null;
          }

          let line1 = "";
          let line2 = "";
          let line3 = "";
          let line4 = "";

          if (!isTodayOnce) {
            // ★ 処理: localの oncePerDayToday が今日でない（または欠損）場合は未開始扱いで表示する
            line1 = "oncePerDayToday: 未開始";
            line2 = "lastRecordedDay: " + (lastRecordedDayIso ? lastRecordedDayIso : "-");
            line3 = "count対象: 判定可能";
            line4 = "ODOA: " + odoaText + " (累計加算: Yes)";
          } else {
            line1 = "oncePerDayToday: 計測中";
            line2 = "Today: " + (onceDayIso ? onceDayIso : "-");

            // ★ 処理: VERIFY_MODE は常に count対象: NO として表示する
            if (verifyModeOn) {
              line3 = "count対象: NO 理由: VERIFY_MODE";
            } else {
              if (measuredResult === "correct" || measuredResult === "wrong") {
                line3 = "count対象: No 計測済(" + measuredResult + ")";
              } else if (measuredResult === "unknown") {
                line3 = "count対象: No 計測済(unknown)";
              } else {
                line3 = "count対象: Yes 未計測";
              }
            }

            // ★ 処理: ODOAの累計加算表示（local判定のcount対象と連動して Yes/No を出す）
            let addYesNo = "Yes";
            if (odoaMode === "off") {
              addYesNo = "Yes";
            } else if (odoaMode === "on") {
              const counted = (verifyModeOn || measuredResult === "correct" || measuredResult === "wrong" || measuredResult === "unknown");
              addYesNo = counted ? "No" : "Yes";
            } else {
              addYesNo = "unknown";
            }
            line4 = "ODOA: " + odoaText + " (累計加算: " + addYesNo + ")";
          }

          onceElLocal.innerHTML =
            '<div class="once-grid">' +

              '<div class="once-label">oncePerDayToday</div>' +
              '<div class="once-val">' + line1.replace(/^oncePerDayToday:\s*/, "") + '</div>' +

              '<div class="once-label">' +
                (isTodayOnce ? 'Today' : 'lastRecordedDay') +
              '</div>' +
              '<div class="once-val">' +
                (isTodayOnce
                  ? line2.replace(/^Today:\s*/, "")
                  : line2.replace(/^lastRecordedDay:\s*/, "")
                ) +
              '</div>' +

              '<div class="once-label">count対象</div>' +
              '<div class="once-val">' +
                line3.replace(/^count対象:\s*/, "") +
              '</div>' +

              '<div class="once-label">ODOA</div>' +
              '<div class="once-val">' +
                line4.replace(/^ODOA:\s*/, "") +
              '</div>' +

            '</div>';
        }
      }
    }catch(_){
      // UI更新失敗は握りつぶし
    }
  }

  function scheduleSend(){
    if (!navigator.onLine) {
      lastSyncStatus = "offline";
      updateMonitor();
      return;
    }
    clearTimeout(sendTimer);
    sendTimer = setTimeout(sendDelta, 1000);
    updateMonitor();
  }

  async function sendDelta(){
    const hasC   = Object.keys(queue.correctDelta).length>0;
    const hasI   = Object.keys(queue.incorrectDelta).length>0;
    const hasS3  = Object.keys(queue.streak3Delta).length>0;
    const hasSL  = Object.keys(queue.streakLenDelta).length>0;
    const hasS3W = Object.keys(queue.streak3WrongDelta).length>0;
    const hasSLW = Object.keys(queue.streakWrongLenDelta).length>0;
    const hasLastSeen    = Object.keys(queue.lastSeenDayDelta).length>0;
    const hasLastCorrect = Object.keys(queue.lastCorrectDayDelta).length>0;
    const hasLastWrong   = Object.keys(queue.lastWrongDayDelta).length>0;

    // ★ いずれの delta も空なら、送信する意味がないので終了
    if (
      !hasC &&
      !hasI &&
      !hasS3 &&
      !hasSL &&
      !hasS3W &&
      !hasSLW &&
      !hasLastSeen &&
      !hasLastCorrect &&
      !hasLastWrong
    ) {
      return;
    }

    const payload = {
      qid: QID || null,
      correctDelta: queue.correctDelta,
      incorrectDelta: queue.incorrectDelta,
      streak3Delta: queue.streak3Delta,
      streakLenDelta: queue.streakLenDelta,
      // ★ 追加: 不正解側ストリークの delta も Workers へ送る
      streak3WrongDelta: queue.streak3WrongDelta,
      streakWrongLenDelta: queue.streakWrongLenDelta,
      // ★ 追加: 問題別 最終日情報の delta（最新値）を Workers へ送る
      lastSeenDayDelta: queue.lastSeenDayDelta,
      lastCorrectDayDelta: queue.lastCorrectDayDelta,
      lastWrongDayDelta: queue.lastWrongDayDelta,
      updatedAt: Date.now()
    };

    // ★ 追加した処理0: localStorage の SYNC key を先に読む（trim）
    // - 空白だけも「未設定」として扱う（空白キーでログやfetchを発生させない）
    // - フォールバックで埋めない（欠損は欠損として止める）
    let syncKey = null;
    try{
      const v = localStorage.getItem("cscs_sync_key");
      if (v !== null && v !== undefined) {
        const s = String(v).trim();
        syncKey = (s === "") ? null : s;
      }
    }catch(_){
      syncKey = null;
    }

    // ★ 追加した処理1: syncKey が未セット/空白なら、ログもfetchも行わず例外で停止する
    if (!syncKey) {
      throw new Error("SYNC_KEY_MISSING_LOCAL");
    }

    // ★ 追加した処理2: syncKey が確定している場合のみ、payloadログを出す（ログ汚染を防ぐ）
    // 送信前に、今回送る delta の中身をコンソールで確認できるようにする
    console.log("[SYNC-A] sendDelta payload(prepare)", {
      qid: QID,
      hasCorrectDelta: hasC,
      hasIncorrectDelta: hasI,
      hasStreak3Delta: hasS3,
      hasStreakLenDelta: hasSL,
      hasStreak3WrongDelta: hasS3W,
      hasStreakWrongLenDelta: hasSLW,
      hasLastSeenDayDelta: hasLastSeen,
      hasLastCorrectDayDelta: hasLastCorrect,
      hasLastWrongDayDelta: hasLastWrong,
      payload: payload
    });

    lastSyncStatus = "sending";
    lastSyncError  = "";
    updateMonitor();

    try{
      // ★ 処理1: merge を叩き、レスポンスヘッダも必ず取得する（欠損は欠損として null）
      const res = await fetch("/api/sync/merge", {
        method:"POST",
        headers:{ "content-type":"application/json", "X-CSCS-Key": String(syncKey) },
        body: JSON.stringify(payload)
      });
      if (!res.ok) throw new Error(String(res.status));

      // ★ 処理2: 指定ヘッダ群を “そのまま” 抜き出す（フォールバックで埋めない）
      function readHeaderStrict(headers, name){
        try{
          const v = headers ? headers.get(name) : null;
          if (v === null || v === undefined) return null;
          const s = String(v).trim();
          return s === "" ? null : s;
        }catch(_){
          return null;
        }
      }

      function readHeaderAny(headers, names){
        for (let i = 0; i < names.length; i++) {
          const v = readHeaderStrict(headers, names[i]);
          if (v !== null) return v;
        }
        return null;
      }

      const mergeHeaders = {
        // ★ 処理2-1: 明示指定ヘッダ
        "X-CSCS-User": readHeaderStrict(res.headers, "X-CSCS-User"),
        "Key": readHeaderAny(res.headers, ["X-CSCS-Key", "X-CSCS-API-Key", "X-CSCS-Token", "X-CSCS-User-Key"]),
        "OdoaMode": readHeaderAny(res.headers, ["X-CSCS-OdoaMode", "X-CSCS-ODOA-Mode", "X-ODOA-Mode"]),
        "KV(hit|miss)": readHeaderAny(res.headers, ["X-CSCS-KV", "X-CSCS-KV-Cache", "CF-KV-Cache", "X-KV-Cache", "X-KV"]),
        "Colo": readHeaderAny(res.headers, ["CF-Colo", "cf-colo"]),
        "CF-Ray": readHeaderAny(res.headers, ["CF-Ray", "cf-ray"])
      };

      // ★ 処理3: merge ヘッダを “確実に” 出す（ここで missing も見える化）
      console.log("[SYNC-A][HDR][MERGE] response headers snapshot", {
        endpoint: "/api/sync/merge",
        qid: QID || null,
        headers: mergeHeaders,
        missing: {
          "X-CSCS-User": (mergeHeaders["X-CSCS-User"] === null),
          "Key": (mergeHeaders["Key"] === null),
          "OdoaMode": (mergeHeaders["OdoaMode"] === null),
          "KV(hit|miss)": (mergeHeaders["KV(hit|miss)"] === null),
          "Colo": (mergeHeaders["Colo"] === null),
          "CF-Ray": (mergeHeaders["CF-Ray"] === null)
        }
      });

      // ★ 処理4: merge ヘッダを保持し、state と一致/不一致を比較できるようにする
      try{
        if (!window.__cscs_sync_last_headers || typeof window.__cscs_sync_last_headers !== "object") {
          window.__cscs_sync_last_headers = { state: null, merge: null };
        }
        window.__cscs_sync_last_headers.merge = mergeHeaders;
      }catch(_){}

      // ★ 処理5: state ヘッダが既にあるなら “一致/不一致” をここで判定して出す
      try{
        const last = (window.__cscs_sync_last_headers && typeof window.__cscs_sync_last_headers === "object")
          ? window.__cscs_sync_last_headers
          : null;

        const sh = last && last.state ? last.state : null;
        if (sh) {
          const keys = ["X-CSCS-User", "Key", "OdoaMode", "KV(hit|miss)", "Colo", "CF-Ray"];
          const diff = {};
          let anyDiff = false;

          for (let i = 0; i < keys.length; i++) {
            const k = keys[i];
            const sv = sh[k];
            const mv = mergeHeaders[k];
            const same = (sv === mv);
            if (!same) {
              anyDiff = true;
              diff[k] = { state: sv, merge: mv };
            }
          }

          console.log("[SYNC-A][CMP][MERGE↔STATE] headers compare", {
            qid: QID || null,
            match: !anyDiff,
            diff: diff
          });
        } else {
          console.log("[SYNC-A][CMP][MERGE↔STATE] headers compare skipped (state headers missing)", {
            qid: QID || null
          });
        }
      }catch(eCmp){
        console.error("[SYNC-A][CMP][MERGE↔STATE] headers compare error", {
          qid: QID || null,
          error: String(eCmp && eCmp.message || eCmp)
        });
      }

      queue.correctDelta        = {};
      queue.incorrectDelta      = {};
      queue.streak3Delta        = {};
      queue.streakLenDelta      = {};
      queue.streak3WrongDelta   = {};
      queue.streakWrongLenDelta = {};
      queue.lastSeenDayDelta    = {};
      queue.lastCorrectDayDelta = {};
      queue.lastWrongDayDelta   = {};

      // ★ 処理6: JSON本文を取得し、注目項目（odoa_mode / updatedAt / correct 空か等）をログ
      const latest = await res.json();

      let correctInfo = null;
      try{
        const hasCorrectMap = !!(latest && latest.correct && typeof latest.correct === "object");
        const keysLen = hasCorrectMap ? Object.keys(latest.correct).length : null;

        let qidHasEntry = null;
        let qidValue = null;
        if (hasCorrectMap && QID) {
          qidHasEntry = Object.prototype.hasOwnProperty.call(latest.correct, QID);
          if (qidHasEntry) qidValue = latest.correct[QID];
        }

        correctInfo = {
          hasCorrectMap: hasCorrectMap,
          correctKeysLen: keysLen,
          correctIsEmpty: (hasCorrectMap ? (keysLen === 0) : null),
          qid: QID || null,
          qidHasEntry: qidHasEntry,
          qidValue: qidValue
        };
      }catch(eCorrect){
        correctInfo = {
          error: String(eCorrect && eCorrect.message || eCorrect)
        };
      }

      console.log("[SYNC-A][BODY][MERGE] json snapshot (selected fields)", {
        endpoint: "/api/sync/merge",
        qid: QID || null,
        odoa_mode: (latest && Object.prototype.hasOwnProperty.call(latest, "odoa_mode")) ? latest.odoa_mode : null,
        updatedAt: (latest && Object.prototype.hasOwnProperty.call(latest, "updatedAt")) ? latest.updatedAt : null,
        correct: correctInfo
      });

      // SYNC 全体状態を常に最新に保つ（streak3Today も含めて反映）
      try{
        window.__cscs_sync_state = latest;
      }catch(_){}

      if (QID){
        // ============================================================
        // ★ フォールバック無し：mergeレスポンスから「確実に取れた値だけ」を採用する
        // ------------------------------------------------------------
        // - 値が欠損/型不正なら console.error で原因を確実に可視化
        // - 欠損時は dataset（UI表示の“サーバー値”）も更新しない
        // ============================================================
        function readMapNumberStrict(src, mapKey, qid){
          // ★ 処理1: mapの存在チェック（無ければログ＆失敗）
          if (!src || typeof src !== "object" || !src[mapKey] || typeof src[mapKey] !== "object") {
            console.error("[SYNC-A][NO-FALLBACK] merge response missing map", {
              qid: qid,
              mapKey: mapKey,
              gotType: src && typeof src === "object" ? typeof src[mapKey] : typeof src
            });
            return { ok: false, value: null, reason: "missing_map" };
          }

          // ★ 処理2: qidキーの存在チェック（無ければログ＆失敗）
          if (!Object.prototype.hasOwnProperty.call(src[mapKey], qid)) {
            console.error("[SYNC-A][NO-FALLBACK] merge response missing qid entry", {
              qid: qid,
              mapKey: mapKey
            });
            return { ok: false, value: null, reason: "missing_qid_entry" };
          }

          // ★ 処理3: number検証（非number/NaN/負数はログ＆失敗）
          const v = src[mapKey][qid];
          if (typeof v !== "number" || !Number.isFinite(v) || v < 0) {
            console.error("[SYNC-A][NO-FALLBACK] merge response invalid number", {
              qid: qid,
              mapKey: mapKey,
              value: v,
              valueType: typeof v
            });
            return { ok: false, value: null, reason: "type_invalid" };
          }

          // ★ 処理4: 成功ログ（必要十分な情報だけ）
          console.log("[SYNC-A][OK] merge response value", {
            qid: qid,
            mapKey: mapKey,
            value: v
          });
          return { ok: true, value: v };
        }

        const rc  = readMapNumberStrict(latest, "correct", QID);
        const ri  = readMapNumberStrict(latest, "incorrect", QID);
        const rs3 = readMapNumberStrict(latest, "streak3", QID);
        const rsl = readMapNumberStrict(latest, "streakLen", QID);
        const rs3w = readMapNumberStrict(latest, "streak3Wrong", QID);
        const rslw = readMapNumberStrict(latest, "streakWrongLen", QID);
        const reasons = {
          correct: (rc && rc.ok === false) ? (rc.reason || "unknown") : null,
          incorrect: (ri && ri.ok === false) ? (ri.reason || "unknown") : null,
          streak3: (rs3 && rs3.ok === false) ? (rs3.reason || "unknown") : null,
          streakLen: (rsl && rsl.ok === false) ? (rsl.reason || "unknown") : null,
          streak3Wrong: (rs3w && rs3w.ok === false) ? (rs3w.reason || "unknown") : null,
          streakWrongLen: (rslw && rslw.ok === false) ? (rslw.reason || "unknown") : null
        };

        const failedKeys = Object.keys(reasons).filter(function(k){ return reasons[k] !== null; });

        if (failedKeys.length > 0) {
          console.log("[SYNC-A][NO-FALLBACK] state map read failed (reasons)", {
            qid: QID,
            failedKeys: failedKeys,
            reasons: reasons
          });
        } else {
          console.log("[SYNC-A][OK] state map read ok (all)", { qid: QID });
        }        

        // ★ 処理5: 全て取れた場合のみ、UIのサーバー値を更新する（欠損時は上書きしない）
        if (rc.ok && ri.ok && rs3.ok && rsl.ok && rs3w.ok && rslw.ok) {
          setServerTotalsForQid(rc.value, ri.value, rs3.value, rsl.value);

          console.log("[SYNC-A][OK] sendDelta merged server snapshot for this QID", {
            qid: QID,
            correctTotal: rc.value,
            wrongTotal: ri.value,
            streak3Correct: rs3.value,
            streakLenCorrect: rsl.value,
            streak3Wrong: rs3w.value,
            streakLenWrong: rslw.value
          });
        } else {
          console.error("[SYNC-A][NO-OVERWRITE] sendDelta skipped server totals update (missing/invalid)", {
            qid: QID,
            ok: {
              correct: rc.ok,
              incorrect: ri.ok,
              streak3: rs3.ok,
              streakLen: rsl.ok,
              streak3Wrong: rs3w.ok,
              streakWrongLen: rslw.ok
            }
          });
        }
      }
      lastSyncStatus = "ok";
      lastSyncTime   = new Date().toLocaleTimeString();
      lastSyncError  = "";
    }catch(e){
      lastSyncStatus = "error";
      lastSyncError  = String(e && e.message || e);
    }finally{
      updateMonitor();
    }
  }

  // === ④ init（キー発行/保存）完了保証 ===
  // 方針:
  //   - cscs_sync_a.js 側では init（/api/sync/init）を絶対に叩かない（bootstrap に一本化）
  //   - nav-guard と同様に、cscs_sync_bootstrap_a.js の完了後にだけ先へ進む
  //   - フォールバックで埋めない（bootstrap が失敗/未実行なら止める）
  async function ensureSyncKeyReady(){
    // ★ 追加した処理1: bootstrap の共有 Promise があるなら、それを必ず待つ
    //   - cscs_sync_bootstrap_a.js は window["__CSCS_SYNC_KEY_PROMISE__"] を唯一の“待てる導線”として提供する
    try{
      var p = window["__CSCS_SYNC_KEY_PROMISE__"];
      if (p && typeof p.then === "function") {
        await p;
      }
    }catch(eWait){
      // ★ 処理: bootstrap 側が reject した場合はここで確定（推測で先へ進まない）
      throw new Error("SYNC_BOOTSTRAP_PROMISE_REJECTED_" + String(eWait && eWait.message || eWait));
    }

    // ★ 追加した処理2: Promise が無い環境（読み込み順など）では event を待つ
    //   - ただし「待ち続けて進む」ようなフォールバックはしない
    //   - ready になった事実（Event）を待てない場合は missing として止める
    if (!window["__CSCS_SYNC_KEY_PROMISE__"]) {
      await new Promise(function(resolve, reject){
        var done = false;

        function cleanup(){
          try{
            window.removeEventListener("cscs:syncKeyReady", onReady);
          }catch(_){}
        }

        function onReady(){
          if (done) return;
          done = true;
          cleanup();
          resolve(true);
        }

        try{
          window.addEventListener("cscs:syncKeyReady", onReady);
        }catch(eAdd){
          cleanup();
          reject(eAdd);
          return;
        }
      });
    }

    // ★ 追加した処理3: bootstrap 完了後に localStorage のキーを読む（trim）
    //   - 空文字/空白のみは未設定として扱う（空白キーで fetch を発生させない）
    //   - フォールバックで別ソースから推測しない
    try{
      const v = localStorage.getItem("cscs_sync_key");
      if (v !== null && v !== undefined) {
        const s = String(v).trim();
        if (s !== "") return s;
      }
    }catch(_){
      // ★ 方針: 読めない場合も推測で埋めず missing 扱いに倒す
    }

    // ★ 追加した処理4: ここまで来て key が無いなら、bootstrap 未完了/失敗として確定停止
    throw new Error("SYNC_KEY_MISSING_AFTER_BOOTSTRAP");
  }

  window.CSCS_SYNC = {
    // ★ 正解1回分の計測を SYNC キューに積む（累計 correctDelta）
    //   あわせて「最終閲覧日」「最終正解日」も localStorage から読み取り、
    //   それぞれ lastSeenDayDelta / lastCorrectDayDelta に最新値として積む。
    recordCorrect(){
      if (!QID) return;
      // ★ 処理: 「|| 0」禁止。欠損は “無い” として扱い、明示的に 1 をセットする
      if (Object.prototype.hasOwnProperty.call(queue.correctDelta, QID)) {
        queue.correctDelta[QID] = queue.correctDelta[QID] + 1;
      } else {
        queue.correctDelta[QID] = 1;
      }

      // ★ 処理: キュー加算が成功したことを確実に確認できるログ
      console.log("[SYNC-A][OK][QUEUE] correctDelta incremented", {
        qid: QID,
        correctDelta: queue.correctDelta[QID]
      });

      try{
        const seenDay = readLocalLastSeenDayForQid(QID);
        if (seenDay) {
          queue.lastSeenDayDelta[QID] = seenDay;
        }
        const correctDay = readLocalLastCorrectDayForQid(QID);
        if (correctDay) {
          queue.lastCorrectDayDelta[QID] = correctDay;
        }
      }catch(_){}


```
<<<PART_END>>>
【RECEIPT_INPUT（このメッセージ内だけを真とする）】
EXPECTED_TOTAL: 4
RECEIVED_TOTAL: 2

CUMULATIVE_RECEIVED_PARTIDS:
- CSCSJS-F5B93AE9-P01-of-04
- CSCSJS-F5B93AE9-P02-of-04

【ChatGPTへの強制ルール】
・受領確認は、このメッセージ内の CUMULATIVE_RECEIVED_PARTIDS と EXPECTED_PARTIDS のみを使用すること。
・会話履歴から PartID を再収集しないこと（禁止）。
・受領確認OK前に、コード内容の解釈・要約・推測・修正案提示をしないこと（禁止）。

RECEIPT_REQUIRED_RESPONSE_TEMPLATE:
ACK: <PartID> <PartSHA256_8> / WAITING_NEXT

【分割コード(2)の終了】→ 次は 分割コード(3) を送ります
【ChatGPTへの指示】解釈・要約・推測・修正案提示は禁止。返答は次のみ。
ACK: <PartID> / WAITING_NEXT
