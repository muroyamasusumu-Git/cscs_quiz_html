<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1">
<meta name="cscs-qid" content="20251129-012">
  <meta charset="utf-8">
  <style>
html, body {
  margin: 0;
  padding: 0;
  background: #111;
  color: #fff;
  width: 100%;
  height: 100%;
}

.wrap {
  margin: 40px auto;
  font-family: -apple-system, BlinkMacSystemFont,
               "Hiragino Kaku Gothic ProN", "Yu Gothic", "Meiryo", sans-serif;
  line-height: 1.5;
  font-size: 32px;
}


.top-title  { opacity:.95; color:#fff; }
.top-date   { color:#a8b0b8; opacity:.95; }
.top-number { color:#c9c9c9; }
.top-level  { color:#a8a8a8; }
.crumb-field{font-size:26px;font-weight:400}
.crumb-sep{opacity:.6}
.crumb-theme{font-size:22px;opacity:.85}

/* ヘッダー部（左右ブロック＋右端日付） */
.topmeta {
  display: flex;
  justify-content: space-between;  /* 左右を分ける */
  align-items: center;
  gap: 16px;
  font-size: 24px;
  font-weight: 500;
  color: rgba(255, 255, 255, 0.7);
  opacity: 0.85;
  margin-bottom: 6px;
  flex-wrap: wrap;
}

/* 左ブロック（タイトル／番号／レベル） */
.topmeta-left {
  display: flex;
  flex-wrap: wrap;
  gap: 14px;
  align-items: center;
}

/* 右ブロック（日付だけ右端に寄せる） */
.topmeta-right {
  margin-left: auto;
  text-align: right;
  white-space: nowrap;
}

.qno {
  font-size: 20px;
  opacity: .9;
  margin: 6px 0 2px;
}

/* 問題文 */
h1 {
  font-size: 44px;
  margin: 10px 0 10px;
  color: #66d9ff;     /* 明るい水色 */
  line-height: 1.10;  /* タイトに */
  overflow-wrap: anywhere;
  word-break: break-word;
}

/* 選択肢 */
.opts {
  padding-left: 1.1em;
  margin-left: 15px;
  margin-top: 0;
}

ol.opts {
    margin-bottom: 20px;
}

.opts li {
  margin-top: 2px;
  margin-bottom: 2px;
}

/* 区切り線 */
.hr {
  height: 1px;
  background: #444;
  margin: 0 0 8px;
}

/* 正解 */
.answer { margin-top: 12px; font-weight: 600; }
.answer { word-break: break-word; }
.answer {
  font-size: 40px;
  margin-top: 0;
  margin-left: 0;
  color: #fff34d;  /* 明るい黄色 */
}

/* Bパートの「正解: A　本　文」の“本文”だけ少し小さく */
.answer .opt-small {
  font-size: 0.85em;   /* ← ほんの少し小さく（0.85〜0.95で調整） */
  line-height: 1.25;  /* 任意：行間を少し詰める */
  opacity: 0.95;      /* 任意：わずかに落として主役のAを強調 */
  margin-left: 10px;
}

/* 解説 */
.explain {
  font-size: 16px;
  margin-top: 4px;
  margin-left: 0;
  opacity: .92;
  white-space: pre-wrap;
}

/* ヒント（B未表示段階） */
.hint {
  font-size: 22px;
  opacity: .6;
  margin-top: 0;
  margin-left: 0;
}
  
/* 選択肢リンク：本文色を継承。iOSの強制色・visitedも抑止 */
.opt-link,
.opt-link:link,
.opt-link:visited,
.opt-link:active {
  color: inherit !important;
  -webkit-text-fill-color: currentColor !important;
  text-decoration: none;
}
.opt-link:hover, .opt-link:focus { text-decoration: underline; }





</style>
<script src="../../assets/a_nav_guard.js" defer></script>


      <script>
      (function(){
        if (window.__cscsBPreflightInstalled) return;
        window.__cscsBPreflightInstalled = true;

        // === consumedタブなら最優先で Kt を削除（b_judge_record.js 起動前に潰す） ===
        try {
          const mDay = (location.pathname.match(/_build_cscs_(\d{8})/)||[])[1];
          const n3   = (location.pathname.match(/q(\d{3})_b/i)||[])[1];
          if (mDay && n3) {
            const qid   = `${mDay}-${n3}`;
            const gk    = `cscs_ab_consumed:${qid}`;
            const ktKey = `cscs_from_a_token:${qid}`;
            if (sessionStorage.getItem(gk) === '1') {
              try { localStorage.removeItem(ktKey); } catch(_){}
              console.debug('[B:preflight] removed Kt before record.js', {qid});
            }
          }
        } catch(_){}

        // qid = YYYYMMDD-NNN（Bページ限定）
        const mDay  = location.pathname.match(/_build_cscs_(\d{8})/);
        const mStem = location.pathname.match(/(?:^|\/)(q\d{3})_b(?:\.html)?(?:\/)?$/i);
        if (!mDay || !mStem) return;
        const day  = mDay[1];
        const num3 = mStem[1].slice(1);
        const qid  = `${day}-${num3}`;

        const Kt  = `cscs_from_a_token:${qid}`;
        const Kc  = `cscs_from_a:${qid}`;
        const KsT = `cscs_ab_shadow_token:${qid}`;   // 影トークン（sessionStorage）
        const KsC = `cscs_ab_shadow_choice:${qid}`;  // 影choice（sessionStorage）

        // ★ 初回到着フレームで Kt/Kc を「影」に退避 → localStorage からは見えなくする
        try{
          const hasShadow = sessionStorage.getItem(KsT);
          const lt = localStorage.getItem(Kt);
          const lc = localStorage.getItem(Kc);
          if (!hasShadow && (lt || lc)) {
            if (lt) { try{ sessionStorage.setItem(KsT, lt); }catch(_){} }
            if (lc) { try{ sessionStorage.setItem(KsC, lc); }catch(_){} }
            try{ localStorage.removeItem(Kt); }catch(_){}
            // Kc は UI 復元に使うので local 側も残す（※消さない）
            console.debug('[B:preflight] moved Kt/Kc to session shadow', { qid });
          }
        }catch(_){}

        // 画面左上に診断用パネル（B）
        const diag = document.createElement('div');
        diag.id = 'cscs_token_diag_b';
        diag.style.cssText =
          'position:fixed;z-index:99999;left:8px;top:8px;max-width:46vw;font:12px/1.4 -apple-system,system-ui,Segoe UI,Roboto,sans-serif;background:rgba(22,22,22,.8);color:#fff;padding:8px 10px;border-radius:6px;white-space:pre-wrap;word-break:break-word;pointer-events:none;';
        diag.textContent = '[B:preflight] init…';
        document.addEventListener('DOMContentLoaded', () => document.body.appendChild(diag));

        const blog = (...a) => { try { console.debug('[B:preflight]', ...a); } catch(_){} };
        const setPanel = (o) => { try{
          diag.textContent = '[B:preflight] ' + Object.entries(o).map(([k,v]) => `${k}: ${v}`).join(' | ');
        }catch(_){ } };

        // 到着直後：不足なら sessionStorage から即時バックフィル（★リロード時は実行しない＆一度使ったら即消す）
        let initLocalToken = null, initLocalChoice = null;
        try {
          // 1) 既存 localStorage を確認
          initLocalToken  = localStorage.getItem(Kt);
          initLocalChoice = localStorage.getItem(Kc);

          // 2) ブラウザのナビゲーション種別を判定（reload の場合はバックフィル禁止）
          let isReload = false;
          try {
            const nav = (performance && performance.getEntriesByType)
              ? (performance.getEntriesByType('navigation')[0] || null)
              : null;
            isReload = !!(nav && nav.type === 'reload');
          } catch(_){ /* noop */ }

          // 3) token が無く、かつリロードではない場合のみ sessionStorage から一度だけ補填
          if (!initLocalToken && !isReload) {
            const sq = sessionStorage.getItem('cscs_last_token_qid');
            const sv = sessionStorage.getItem('cscs_last_token_value');
            const sc = sessionStorage.getItem('cscs_last_choice');

            if (sq === qid && sv) {
              // backfill → 直後に sessionStorage を必ず消去（※リロード時の再バックフィル防止）
              try { localStorage.setItem(Kt, sv); } catch(_){}
              if (sc) { try { localStorage.setItem(Kc, sc); } catch(_){ } }

              try {
                sessionStorage.removeItem('cscs_last_token_qid');
                sessionStorage.removeItem('cscs_last_token_value');
                sessionStorage.removeItem('cscs_last_choice');
              } catch(_){}

              initLocalToken  = localStorage.getItem(Kt);
              initLocalChoice = localStorage.getItem(Kc);
              blog('backfilled from sessionStorage (once, then cleared):', { qid, Kt, Kc });
            }
          } else if (isReload) {
            blog('skip backfill on reload');
          }
        } catch (e) {
          blog('localStorage get exception:', String(e));
        }

        // A側がデバッグ用に残したセッションミラーも取得（比較用）
        let sessQid = null, sessToken = null, sessChoice = null;
        try {
          sessQid    = sessionStorage.getItem('cscs_last_token_qid');
          sessToken  = sessionStorage.getItem('cscs_last_token_value');
          sessChoice = sessionStorage.getItem('cscs_last_choice');
        } catch (e) {
          blog('sessionStorage get exception:', String(e));
        }

        const shadowToken  = (function(){ try{ return sessionStorage.getItem(KsT); }catch(_){ return null; } })();
        const shadowChoice = (function(){ try{ return sessionStorage.getItem(KsC); }catch(_){ return null; } })();
        blog('arrived', {
          qid, Kt, Kc,
          initLocalToken, initLocalChoice,
          shadowToken: !!shadowToken,
          shadowChoice: shadowChoice || null,
          sessQid, sessToken: !!sessToken, sessChoice
        });

        // --- ロールアップ（集計）ユーティリティ ---
        function ensureDayIndex(dayStr){
          const dk = `cscs_rollup:${dayStr}`;
          let arr = [];
          try {
            const raw = localStorage.getItem(dk);
            if (raw) arr = JSON.parse(raw);
          } catch(_){}
          if (!Array.isArray(arr)) arr = [];
          if (arr.length < 30) {
            const need = 30 - arr.length;
            for (let i = 0; i < need; i++) arr.push(null);
          }
          return { key: dk, arr };
        }

        function qIndexFromQid(qidStr){
          // qidStr = "YYYYMMDD-NNN"
          const m = qidStr && qidStr.match(/-(\d{3})$/);
          if (!m) return -1;
          const n = parseInt(m[1], 10);
          return (n >= 1 && n <= 30) ? (n - 1) : -1;
        }

        function recordArrival(qidStr, tokenVal, choiceVal){
          const dayStr = qidStr.slice(0, 8);
          const { key, arr } = ensureDayIndex(dayStr);
          const idx = qIndexFromQid(qidStr);
          if (idx < 0) return false;

          const now = Date.now();
          const entry = {
            qid: qidStr,
            token: tokenVal || null,
            choice: choiceVal || null,
            ts: now
          };
          arr[idx] = entry;

          try {
            localStorage.setItem(key, JSON.stringify(arr));
            localStorage.setItem('cscs_last_seen_day', dayStr);
            blog('rollup saved', { key, idx, qid: qidStr });
            return true;
          } catch (e) {
            blog('rollup save exception:', String(e));
            return false;
          }
        }

        // ◆ロールアップへ即時反映（token/choice のどちらかがあれば記録）
        try{
          // consumed タブ、または直後A→B初回（未消費）では rollup を保留
          const gk = `cscs_ab_consumed:${qid}`;
          const alreadyConsumed = sessionStorage.getItem(gk) === '1';
          if (alreadyConsumed) {
            blog('rollup skip: already consumed tab', { qid });
          } else if (!alreadyConsumed) {
            // 初回タブでも、まだ b_judge.js が tally 前の Kt を持つ状態。
            // ここでは rollup を保留し、b_judge.js 側に任せる。
            blog('rollup deferred: let b_judge.js handle tally', { qid });
          }
        }catch(e){
          blog('rollup exception:', String(e));
        }

        setPanel({
          qid,
          localToken:   initLocalToken ? 'set' : 'null',
          localChoice:  initLocalChoice || 'null',
          shadowToken:  (function(){ try{ return sessionStorage.getItem(KsT) ? 'set' : 'null'; }catch(_){ return 'err'; } })(),
          shadowChoice: (function(){ try{ return sessionStorage.getItem(KsC) || 'null'; }catch(_){ return 'err'; } })(),
          sessQid:      sessQid || 'null',
          sessToken:    sessToken ? 'set' : 'null',
          sessChoice:   sessChoice || 'null'
        });

        // 以降、誰が localStorage を書き換えるか監視（stack 付き）
        try{
          const LS = localStorage;
          const _set    = LS.setItem.bind(LS);
          const _remove = LS.removeItem.bind(LS);
          const _clear  = LS.clear.bind(LS);

          LS.setItem = function(k, v){
            blog('setItem', {k, v}, 'stack:', new Error().stack);
            return _set(k, v);
          };
          LS.removeItem = function(k){
            blog('removeItem', {k}, 'stack:', new Error().stack);
            return _remove(k);
          };
          LS.clear = function(){
            blog('clear()', 'stack:', new Error().stack);
            return _clear();
          };
        }catch(e){
          blog('hook localStorage methods failed:', String(e));
        }

        window.addEventListener('beforeunload', (e)=>{ blog('beforeunload (B)', {trusted:e.isTrusted}); }, {capture:true});
        window.addEventListener('unload',       (e)=>{ blog('unload (B)'      , {trusted:e.isTrusted}); }, {capture:true});
      })();
      </script>
    

      <script> try{ maybeStartNewRunIfRequested(); }catch(_){} </script>
    

<style>
/* 全ページ強制：html/body の高さ指定を解除 */
html, body { height: auto !important; min-height: 0 !important; }
</style>


<link rel="stylesheet" href="../../assets/wrong_badge.css">
<script src="../../assets/wrong_badge.js" defer></script>


<link rel="stylesheet" href="../../assets/fav_modal.css">
<script src="../../assets/fav_modal.js" defer></script>


<link rel="stylesheet" href="../../assets/main.css">




<style>
/* 後から --h1-lh で自由に変更可（既定は normal） */
h1 { line-height: var(--h1-lh, normal); }
</style>


<style>
/* 後から --h1-fs で自由に変更可（既定は inherit。UA既定や main.css が決める） */
h1 { font-size: var(--h1-fs, inherit); }
</style>


<script src="../../assets/correct_star.js" defer></script>


<script src="../../assets/consistency_check_debug.js" data-part="a" defer></script>

</head>
<body class="mode-a">
<div id="root">
  <div class="wrap">
    <div id="cc-check-wrapper" class="cc-check-wrapper"></div>
    <div class='topmeta'><div class='topmeta-left'><div class='top-title'>NSCA CSCS 問題集 (65/90)</div><div class='top-number'>番号: <span class='top-number-val'>12/30</span></div><div class='top-level'>Lvl 2</div></div><div class='topmeta-right'></div></div>
    <div class='qno'><span class="correct_star">⭐️</span><span class="consistency_status">◎</span><span class="top-date">2025年11月29日</span><span class='crumb-field'>施設管理と運営</span><span class='crumb-sep'> ＞ </span><span class='crumb-theme'>安全確認手順</span></div>
    <h1 style="">安全掲示物を設置する最も効果的な位置はどれか？</h1>
    <ol class='opts' type='A'><li><a class="opt-link" href="q012_b.html?choice=A">スタッフ休憩室</a></li><li><a class="opt-link" href="q012_b.html?choice=B">器具裏面</a></li><li><a class="opt-link" href="q012_b.html?choice=C">利用動線上の目線高さ</a></li><li><a class="opt-link" href="q012_b.html?choice=D">入口外壁の裏</a></li></ol>
    <div class='hint'>（この後、正解と解説が表示されます）</div>
    <!-- <div class="footer">（このスライドは自動生成です）</div> -->
  </div>
<script type="application/json" id="cscs-meta">{"qid": "2025年11月29日-012", "field": "施設管理と運営", "theme": "安全確認手順", "level": "Level 2", "date": "2025年11月29日", "number": "12", "quiztype": "単一分野", "tags": {"cause": "掲示設計", "process": "視認高さ設定|通行導線配置", "outcome": "注意喚起|事故抑制"}}</script>

  <!-- 左下の [TOPへ戻る] ボタン -->
  <a class="back-to-top" href="../../index.html" title="問題一覧に戻る">［TOPへ戻る］</a>


  <!-- A専用：問題一覧（2カラム） -->
  <link rel="stylesheet" href="../../assets/nav_list.css">
  <script src="../../assets/nav_list.js" data-a-nav="1"></script>

<!-- Aパート：類似問題（全2700問横断） -->
<div id="similar-list" data-src="../../assets/cscs_meta_all.json" data-mode="similar" data-qtext="安全掲示物を設置する最も効果的な位置はどれか？"></div>
<script src="../../assets/similar_list.js" data-src="../../assets/cscs_meta_all.json" data-mode="similar"></script>

<script>
  (function(){
    // === ① QID検出（Aパート） ===
    function detectQidFromLocationA() {
      const m = location.pathname.match(/_build_cscs_(\d{8})\/slides\/q(\d{3})_a(?:\.html)?$/);
      if (!m) return null;
      const day  = m[1];   // 例: "20250926"
      const num3 = m[2];   // 例: "001"
      // qid 形式を「YYYYMMDD-NNN」に統一
      return day + "-" + num3;
    }
    const QID = detectQidFromLocationA();

    // === ② 差分キュー（Aパート専用） ===
    const queue = { correctDelta: {}, incorrectDelta: {}, streak3Delta: {}, streakLenDelta: {} };
    let sendTimer = null;

    // SYNCモニタ用ステータス
    let lastSyncStatus = "idle";   // "idle" | "sending" | "ok" | "error" | "offline"
    let lastSyncTime   = null;     // "HH:MM:SS"
    let lastSyncError  = "";

    function readLocalTotalsForQid(qid){
      try{
        const kC = "cscs_q_correct_total:" + qid;
        const kW = "cscs_q_wrong_total:"   + qid;
        const c  = parseInt(localStorage.getItem(kC) || "0", 10) || 0;
        const w  = parseInt(localStorage.getItem(kW) || "0", 10) || 0;
        return { c, w };
      }catch(_){
        return { c:0, w:0 };
      }
    }

    function readLocalStreak3ForQid(qid){
      try{
        const kS = "cscs_q_correct_streak3_total:" + qid;
        const s  = parseInt(localStorage.getItem(kS) || "0", 10) || 0;
        return s;
      }catch(_){
        return 0;
      }
    }

    function readLocalStreakLenForQid(qid){
      try{
        const kL = "cscs_q_correct_streak_len:" + qid;
        const l  = parseInt(localStorage.getItem(kL) || "0", 10) || 0;
        return l;
      }catch(_){
        return 0;
      }
    }

    function setServerTotalsForQid(c, i, s3, sLen){
      const el = document.getElementById("cscs_sync_totals");
      if (el) {
        el.dataset.serverC = String(c);
        el.dataset.serverI = String(i);
        if (typeof s3 === "number") {
          el.dataset.serverS3 = String(s3);
        }
        if (typeof sLen === "number") {
          el.dataset.serverSL = String(sLen);
        }
      }
    }

    function updateMonitor(){
      try{
        if (!QID) return;
        const box = document.getElementById("cscs_sync_monitor_a");
        const totalsEl = document.getElementById("cscs_sync_totals");

        const dC = queue.correctDelta[QID]   || 0;
        const dI = queue.incorrectDelta[QID] || 0;

        const local = readLocalTotalsForQid(QID);
        const lc = local.c;
        const li = local.w;

        const ls = readLocalStreak3ForQid(QID);
        const ll = readLocalStreakLenForQid(QID);

        let sc = 0, si = 0, ss = 0, sl = 0;
        if (totalsEl) {
          sc = parseInt(totalsEl.dataset.serverC || "0", 10) || 0;
          si = parseInt(totalsEl.dataset.serverI || "0", 10) || 0;
          ss = parseInt(totalsEl.dataset.serverS3 || "0", 10) || 0;
          sl = parseInt(totalsEl.dataset.serverSL || "0", 10) || 0;
          totalsEl.textContent = "server " + sc + " / " + si;
        }

        const serverProgress = sl % 3;
        const localProgress  = ll % 3;

        if (box) {
          const qEl  = box.querySelector(".sync-qid");
          const lEl  = box.querySelector(".sync-local");
          const qdEl = box.querySelector(".sync-queue");
          const stEl = box.querySelector(".sync-status");
          const s3El = box.querySelector(".sync-streak3-val");
          const s3sEl = box.querySelector(".sync-streak3-server");
          const slEl = box.querySelector(".sync-streaklen-val");
          const slsEl = box.querySelector(".sync-streaklen-server");
          const slsProgEl = box.querySelector(".sync-streaklen-server-progress");
          const sllProgEl = box.querySelector(".sync-streaklen-local-progress");

          if (qEl)   qEl.textContent  = QID;
          if (lEl)   lEl.textContent  = "local  " + lc + " / " + li;
          if (qdEl)  qdEl.textContent = "+Δ    " + dC + " / " + dI;
          if (s3El)  s3El.textContent = String(ls);
          if (s3sEl) s3sEl.textContent = String(ss);

          if (slEl)        slEl.textContent        = String(ll);
          if (slsEl)       slsEl.textContent       = String(sl);
          if (slsProgEl)   slsProgEl.textContent   = String(serverProgress);
          if (sllProgEl)   sllProgEl.textContent   = String(localProgress);

          const time = lastSyncTime ? lastSyncTime : "-";
          const err  = lastSyncError ? (" err:" + lastSyncError) : "";
          if (stEl) stEl.textContent = lastSyncStatus + " (" + time + ")" + err;
        }
      }catch(_){
        // UI更新失敗は握りつぶし
      }
    }

    function scheduleSend(){
      if (!navigator.onLine) {
        lastSyncStatus = "offline";
        updateMonitor();
        return;
      }
      clearTimeout(sendTimer);
      sendTimer = setTimeout(sendDelta, 1000);
      updateMonitor();
    }

    async function sendDelta(){
      const hasC  = Object.keys(queue.correctDelta).length>0;
      const hasI  = Object.keys(queue.incorrectDelta).length>0;
      const hasS3 = Object.keys(queue.streak3Delta).length>0;
      const hasSL = Object.keys(queue.streakLenDelta).length>0;
      if (!hasC && !hasI && !hasS3 && !hasSL) return;

      // ★ 差分送信用のペイロード（qid とタイムスタンプ付き）
      const payload = {
        qid: QID || null,
        correctDelta: queue.correctDelta,
        incorrectDelta: queue.incorrectDelta,
        streak3Delta: queue.streak3Delta,
        streakLenDelta: queue.streakLenDelta,
        updatedAt: Date.now()
      };

      lastSyncStatus = "sending";
      lastSyncError  = "";
      updateMonitor();

      try{
        const res = await fetch("/api/sync/merge", {
          method:"POST",
          headers:{ "content-type":"application/json" },
          body: JSON.stringify(payload)
        });
        if (!res.ok) throw new Error(String(res.status));

        // 送信が成功したら差分キューをクリア
        queue.correctDelta    = {};
        queue.incorrectDelta  = {};
        queue.streak3Delta    = {};
        queue.streakLenDelta  = {};

        const latest = await res.json();
        if (QID){
          const c   = (latest.correct   && latest.correct[QID])   || 0;
          const i   = (latest.incorrect && latest.incorrect[QID]) || 0;
          const s3  = (latest.streak3   && latest.streak3[QID])   || 0;
          const sl  = (latest.streakLen && latest.streakLen[QID]) || 0;
          setServerTotalsForQid(c, i, s3, sl);
        }
        lastSyncStatus = "ok";
        lastSyncTime   = new Date().toLocaleTimeString();
        lastSyncError  = "";
      }catch(e){
        lastSyncStatus = "error";
        lastSyncError  = String(e && e.message || e);
      }finally{
        updateMonitor();
      }
    }

    window.CSCS_SYNC = {
      recordCorrect(){
        if (!QID) return;
        queue.correctDelta[QID] = (queue.correctDelta[QID] || 0) + 1;
        scheduleSend();
      },
      recordIncorrect(){
        if (!QID) return;
        queue.incorrectDelta[QID] = (queue.incorrectDelta[QID] || 0) + 1;
        scheduleSend();
      },
      recordStreak3(){
        if (!QID) return;
        queue.streak3Delta[QID] = (queue.streak3Delta[QID] || 0) + 1;
        try{
          var ev = new CustomEvent("cscs:streak3-earned", {
            detail: {
              qid: QID,
              ts: Date.now()
            }
          });
          window.dispatchEvent(ev);
        }catch(_){}
        scheduleSend();
      },
      recordStreakLen(){
        if (!QID) return;
        const currentLen = readLocalStreakLenForQid(QID);
        queue.streakLenDelta[QID] = currentLen;
        scheduleSend();
      },
      async fetchServer(){
        const r = await fetch("/api/sync/state");
        if(!r.ok) throw new Error(r.statusText);
        return r.json();
      }
    };

    // 初期ロードでサーバ側の累積を取得
    async function initialFetch(){
      if (!QID) return;
      try{
        const s  = await CSCS_SYNC.fetchServer();
        const c  = (s.correct   && s.correct[QID])   || 0;
        const i  = (s.incorrect && s.incorrect[QID]) || 0;
        const s3 = (s.streak3   && s.streak3[QID])   || 0;
        const sl = (s.streakLen && s.streakLen[QID]) || 0;

        // SYNC 側の 3連続正解回数＋連続正解長も含めてステータスに反映
        setServerTotalsForQid(c, i, s3, sl);

        try{
          // 正解／不正解の累積をサーバー値でローカルに揃える
          localStorage.setItem("cscs_q_correct_total:" + QID, String(c));
          localStorage.setItem("cscs_q_wrong_total:"   + QID, String(i));
          // 3連続正解累積もサーバー値でローカルに揃える
          localStorage.setItem("cscs_q_correct_streak3_total:" + QID, String(s3));
          // 連続正解長もサーバー値でローカルに揃える
          localStorage.setItem("cscs_q_correct_streak_len:" + QID, String(sl));
        }catch(_){}

        lastSyncStatus = "pulled";
        lastSyncTime   = new Date().toLocaleTimeString();
        lastSyncError  = "";
      }catch(e){
        lastSyncStatus = "error";
        lastSyncError  = String(e && e.message || e);
      }finally{
        updateMonitor();
      }
    }

    // 右下モニタ生成＋テストボタン（+ok/+ng/send/pull）
    window.addEventListener("DOMContentLoaded", function(){
      if (!QID) return;
      try{
        const box = document.createElement("div");
        box.id = "cscs_sync_monitor_a";
        box.innerHTML = `
          <div class="sync-header">SYNC(A): <span class="sync-qid"></span></div>
          <div id="cscs_sync_totals" class="sync-line sync-totals" data-server-c="0" data-server-i="0">server 0 / 0</div>
          <div class="sync-line sync-local">local  0 / 0</div>
          <div class="sync-line sync-queue">+Δ    0 / 0</div>
          <div class="sync-line sync-streak3">
            3連続正解回数:<br>
            SYNC <span class="sync-streak3-server">0</span> 回 / local <span class="sync-streak3-val">0</span> 回
          </div>
          <div class="sync-line sync-streaklen">
            3連続正解回数 (進捗):<br>
            SYNC <span class="sync-streaklen-server">0</span> (<span class="sync-streaklen-server-progress">0</span>/3) /
            local <span class="sync-streaklen-val">0</span> (<span class="sync-streaklen-local-progress">0</span>/3)
          </div>
          <div class="sync-line sync-status-row">status: <span class="sync-status">idle (-)</span></div>          
          
          <div class="sync-reset-row">            
            <button id="cscs_sync_test_reset" type="button" class="sync-reset-button">reset this qid</button>
            <button id="cscs_sync_star_reset" type="button" class="sync-reset-button">reset stars</button>
          </div>
        `;
        const wrap = document.querySelector("div.wrap");
        if (wrap) {
          wrap.appendChild(box);
        } else {
          document.body.appendChild(box);
        }

        const btnOk   = document.getElementById("cscs_sync_test_ok");
        const btnNg   = document.getElementById("cscs_sync_test_ng");
        const btnReset  = document.getElementById("cscs_sync_test_reset");
        const btnStarReset = document.getElementById("cscs_sync_star_reset");
        // ③ この問題(qid単位)のSYNCカウンタをリセット（サーバー＋ローカル両方）
        if (btnReset) btnReset.addEventListener("click", async () => {
          if (!QID) return;
          try{
            await fetch("/api/sync/reset_qid", {
              method:"POST",
              headers:{ "content-type":"application/json" },
              body: JSON.stringify({ qid: QID })
            });

            // サーバーリセット成功とみなしたら、このqidのローカル累積もゼロに揃える
            try{
              const kCorNow  = "cscs_q_correct_total:" + QID;
              const kWrgNow  = "cscs_q_wrong_total:"   + QID;
              const kCorLast = "cscs_sync_last_c:"     + QID;
              const kWrgLast = "cscs_sync_last_w:"     + QID;

              localStorage.setItem(kCorNow,  "0");
              localStorage.setItem(kWrgNow,  "0");
              localStorage.setItem(kCorLast, "0");
              localStorage.setItem(kWrgLast, "0");
            }catch(_){}

            alert("この問題のSYNCカウンタをリセットしました。");
            await initialFetch();
          }catch(e){
            alert("reset 失敗: " + e);
          }
        });

        // ④ この問題(qid単位)の星データ（連続正解関連）をリセット（ローカル＋SYNC＋DOM）
        if (btnStarReset) btnStarReset.addEventListener("click", async () => {
          if (!QID) return;
          try{
            // SYNC 側（サーバー）の streak3 カウンタもリセット
            try{
              await fetch("/api/sync/reset_streak3_qid", {
                method:"POST",
                headers:{ "content-type":"application/json" },
                body: JSON.stringify({ qid: QID })
              });
            }catch(_){}

            // 連続正解カウンタ系（qidごと）のリセット（ローカル）
            const kStreakLen    = "cscs_q_correct_streak_len:" + QID;
            const kStreakTotal  = "cscs_q_correct_streak3_total:" + QID;
            const kStreakLastS3 = "cscs_sync_last_s3:" + QID;
            try{
              localStorage.removeItem(kStreakLen);
              localStorage.removeItem(kStreakTotal);
              // Bパート用の「前回SYNC済みstreak3」も 0 に揃える
              localStorage.setItem(kStreakLastS3, "0");
            }catch(_){}

            // 3連正解達成履歴ログから、このqidの記録だけを削除（ローカル）
            const logKey = "cscs_correct_streak3_log";
            try{
              const raw = localStorage.getItem(logKey);
              if (raw) {
                const parsed = JSON.parse(raw);
                if (Array.isArray(parsed)) {
                  const filtered = parsed.filter(function(entry){
                    if (!entry || typeof entry !== "object") return true;
                    if (!("qid" in entry)) return true;
                    return entry.qid !== QID;
                  });
                  localStorage.setItem(logKey, JSON.stringify(filtered));
                }
              }
            }catch(_){}

            // SYNC 側 streak3 を 0 とみなしてモニタ用データにも反映
            try{
              const totalsEl = document.getElementById("cscs_sync_totals");
              if (totalsEl) {
                const sc = parseInt(totalsEl.dataset.serverC || "0", 10) || 0;
                const si = parseInt(totalsEl.dataset.serverI || "0", 10) || 0;
                setServerTotalsForQid(sc, si, 0);
              }
            }catch(_){}

            // DOM 上の ⭐️ を即時非表示（A/B共通クラス）
            try{
              const stars = document.querySelectorAll(".correct_star");
              stars.forEach(function(el){
                el.style.display = "none";
              });
            }catch(_){}

            // モニタも更新（3連続正解回数を 0 に反映）
            updateMonitor();

            alert("この問題の星データをリセットしました。");
          }catch(e){
            alert("星データのリセットに失敗しました: " + e);
          }
        });

        // 既存の差分テストボタン
        if (btnOk)   btnOk.addEventListener("click", () => window.CSCS_SYNC.recordCorrect());
        if (btnNg)   btnNg.addEventListener("click", () => window.CSCS_SYNC.recordIncorrect());
      }catch(_){}
      initialFetch();
    });

    window.addEventListener("online", function(){
      lastSyncStatus = "idle";
      sendDelta();
    });
    window.addEventListener("offline", function(){
      lastSyncStatus = "offline";
      updateMonitor();
    });
  })();
</script>


</div></body>
</html>