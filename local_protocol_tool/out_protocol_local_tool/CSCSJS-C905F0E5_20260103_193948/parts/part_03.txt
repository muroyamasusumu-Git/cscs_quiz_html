<<<PART_BEGIN>>>
【分割コード(3)の開始】
PartID: CSCSJS-C905F0E5-P03-of-05
PartSHA256: af70cfaf810569077ede9cdf03040d678d9cc53ad717ab4239676935785ce0e3
Range: chars 70963..114468 (len=43505)
FirstLine:   function renderPanel(box, payload) {
LastLine: 
EndNewline: YES
PART_SCOPE_HINT: LineRange=L2207..L3326 | BraceDepth=1->2
PART_SCOPE_HINT_TOP_IDENTIFIERS: qid:84, window:48, payload:45, SYNC:40, B:32, __cscs_sync_state:32, console:31, params:28, info:26, log:24, localStreakLen:23, localWrongStreakLen:23
PART_SCOPE_HINT_DEFINES: renderPanel, sendDiffToServer, lastBox, lastPayload, serverCorrect, serverWrong, localCorrect, localWrong, diffCorrect, diffWrong, serverStreak3, localStreak3, diffStreak3, serverStreakLen, localStreakLen, diffStreakLen, localCorrectStreakMax, localCorrectStreakMaxDayLabel, maxDayNum, localWrongStreakMax, localWrongStreakMaxDayLabel, maxWrongDayNum, serverCorrectStreakMax, serverCorrectStreakMaxDayLabel, serverWrongStreakMax, serverWrongStreakMaxDayLabel, stMax, qidForMax, cMax, cDay, wMax, wDay, statusText, serverProgress, localProgress, diffProgress, qidForStreakWrong, serverStreak3Wrong, localStreak3Wrong, diffStreak3Wrong

```javascript
  function renderPanel(box, payload) {
    try {
      // ★ 何をしているか:
      //   b_sync_merge.js の "cscs:sync:todayUniqueUpdated" を受けたときに
      //   “同じHUD” を再描画できるよう、最後に描画した参照を保持する。
      try {
        window.__CSCS_SYNC_VIEW_B_LAST_BOX__ = box || null;
        window.__CSCS_SYNC_VIEW_B_LAST_PAYLOAD__ = payload || null;
      } catch (_eKeepLast) {}

      // ★ 追加②：イベント cscs:sync:todayUniqueUpdated を受けたら再描画
      //   何をしているか:
      //   - b_sync_merge.js が Today系ユニーク数（localStorage / state）を更新した合図を受け取る
      //   - 最後に描画した “同じHUD” をもう一度 renderPanel で描画し直す（payload は最後の参照を再利用）
      //   - 多重登録防止のため、リスナーは1回だけ登録する
      try {
        if (!window.__CSCS_SYNC_VIEW_B_TODAY_UNIQUE_LISTENER_INSTALLED__) {
          window.__CSCS_SYNC_VIEW_B_TODAY_UNIQUE_LISTENER_INSTALLED__ = true;

          window.addEventListener("cscs:sync:todayUniqueUpdated", function (_ev) {
            try {
              var lastBox = null;
              var lastPayload = null;

              try { lastBox = window.__CSCS_SYNC_VIEW_B_LAST_BOX__ || null; } catch (_e1) { lastBox = null; }
              try { lastPayload = window.__CSCS_SYNC_VIEW_B_LAST_PAYLOAD__ || null; } catch (_e2) { lastPayload = null; }

              if (!lastBox || !lastPayload) {
                console.log("[SYNC-B:view] todayUniqueUpdated received but no last render refs", {
                  hasBox: !!lastBox,
                  hasPayload: !!lastPayload
                });
                return;
              }

              console.log("[SYNC-B:view] todayUniqueUpdated -> rerender same HUD", {
                qid: (lastPayload && lastPayload.info && lastPayload.info.qid) ? lastPayload.info.qid : "-"
              });

              renderPanel(lastBox, lastPayload);
            } catch (eRerender) {
              console.error("[SYNC-B:view] rerender on todayUniqueUpdated error:", eRerender);
            }
          });
        }
      } catch (_eInstallTodayUniqueListener) {}

      var serverCorrect = payload.serverCorrect || 0;
      var serverWrong = payload.serverWrong || 0;
      var localCorrect = payload.localCorrect || 0;
      var localWrong = payload.localWrong || 0;
      var diffCorrect = payload.diffCorrect || 0;
      var diffWrong = payload.diffWrong || 0;

      var serverStreak3 = payload.serverStreak3 || 0;
      var localStreak3 = payload.localStreak3 || 0;
      var diffStreak3 = payload.diffStreak3 || 0;

      var serverStreakLen = payload.serverStreakLen || 0;
      var localStreakLen = payload.localStreakLen || 0;
      var diffStreakLen = payload.diffStreakLen || 0;

      // ★ 追加: b_judge_record.js のローカル計測（問題別：最高連続正解数 / 更新日）を読み出す
      //   何をしているか: localStorage の確定キーから「現在/最高/達成日」を取得し、HUD model に載せる
      //   フォールバックはしない（キーが無い/不正なら 0 または -）
      var localCorrectStreakMax = 0;
      var localCorrectStreakMaxDayLabel = "-";
      try {
        localCorrectStreakMax = readIntFromLocalStorage("cscs_q_correct_streak_max:" + info.qid);
        var maxDayNum = readDayFromLocalStorage("cscs_q_correct_streak_max_day:" + info.qid);
        if (maxDayNum !== null) {
          localCorrectStreakMaxDayLabel = String(maxDayNum);
        }

        console.log("[SYNC-B:view] correct-streak max from localStorage", {
          qid: info.qid,
          localCorrectStreakLen: localStreakLen,
          localCorrectStreakMax: localCorrectStreakMax,
          localCorrectStreakMaxDay: localCorrectStreakMaxDayLabel
        });
      } catch (eStreakMax) {
        console.error("[SYNC-B:view] correct-streak max read error:", eStreakMax);
      }

      // ★ 追加: b_judge_record.js のローカル計測（問題別：最高連続不正解数 / 達成日）を読み出す
      //   何をしているか: localStorage の確定キーから「最高/達成日」を取得し、HUD model に載せる
      //   フォールバックはしない（キーが無い/不正なら 0 または -）
      var localWrongStreakMax = 0;
      var localWrongStreakMaxDayLabel = "-";
      try {
        localWrongStreakMax = readIntFromLocalStorage("cscs_q_wrong_streak_max:" + info.qid);
        var maxWrongDayNum = readDayFromLocalStorage("cscs_q_wrong_streak_max_day:" + info.qid);
        if (maxWrongDayNum !== null) {
          localWrongStreakMaxDayLabel = String(maxWrongDayNum);
        }

        console.log("[SYNC-B:view] wrong-streak max from localStorage", {
          qid: info.qid,
          localWrongStreakLen: localWrongStreakLen,
          localWrongStreakMax: localWrongStreakMax,
          localWrongStreakMaxDay: localWrongStreakMaxDayLabel
        });
      } catch (eWrongStreakMax) {
        console.error("[SYNC-B:view] wrong-streak max read error:", eWrongStreakMax);
      }

      // ★ 追加: SYNC側の「最高連続正解/不正解（streak_max / max_day）」を state から読み出す
      //   - フォールバック無し：window.__cscs_sync_state の決め打ちキーのみを見る
      //   - 無ければ 0 / "-" のまま（“補完しない”）
      var serverCorrectStreakMax = 0;
      var serverCorrectStreakMaxDayLabel = "-";
      var serverWrongStreakMax = 0;
      var serverWrongStreakMaxDayLabel = "-";

      try {
        var stMax = null;
        try { stMax = window.__cscs_sync_state || null; } catch (_eStMax) { stMax = null; }
        var qidForMax = (info && info.qid) ? info.qid : null;

        if (stMax && qidForMax) {
          // 連続正解 max
          if (stMax.streakMax &&
              typeof stMax.streakMax === "object" &&
              stMax.streakMax[qidForMax] != null) {
            var cMax = stMax.streakMax[qidForMax];
            if (typeof cMax === "number" && Number.isFinite(cMax) && cMax >= 0) {
              serverCorrectStreakMax = cMax;
            }
          }
          if (stMax.streakMaxDay &&
              typeof stMax.streakMaxDay === "object" &&
              stMax.streakMaxDay[qidForMax] != null) {
            var cDay = stMax.streakMaxDay[qidForMax];
            if (typeof cDay === "number" && Number.isFinite(cDay) && cDay > 0) {
              serverCorrectStreakMaxDayLabel = String(cDay);
            }
          }

          // 連続不正解 max
          if (stMax.streakWrongMax &&
              typeof stMax.streakWrongMax === "object" &&
              stMax.streakWrongMax[qidForMax] != null) {
            var wMax = stMax.streakWrongMax[qidForMax];
            if (typeof wMax === "number" && Number.isFinite(wMax) && wMax >= 0) {
              serverWrongStreakMax = wMax;
            }
          }
          if (stMax.streakWrongMaxDay &&
              typeof stMax.streakWrongMaxDay === "object" &&
              stMax.streakWrongMaxDay[qidForMax] != null) {
            var wDay = stMax.streakWrongMaxDay[qidForMax];
            if (typeof wDay === "number" && Number.isFinite(wDay) && wDay > 0) {
              serverWrongStreakMaxDayLabel = String(wDay);
            }
          }
        }

        console.log("[SYNC-B:view] streak max from SYNC state", {
          qid: qidForMax || "-",
          serverCorrectStreakMax: serverCorrectStreakMax,
          serverCorrectStreakMaxDay: serverCorrectStreakMaxDayLabel,
          serverWrongStreakMax: serverWrongStreakMax,
          serverWrongStreakMaxDay: serverWrongStreakMaxDayLabel
        });
      } catch (eMaxSync) {
        console.error("[SYNC-B:view] streak max read from SYNC state error:", eMaxSync);
      }

      // statusText は内部状態としてログだけに使う
      var statusText = payload.statusText || "";

      var serverProgress = serverStreakLen % 3;
      var localProgress = localStreakLen % 3;
      var diffProgress = Math.max(0, localProgress - serverProgress);

      // ★ 3連続不正解用のサマリを server / local / diff から計算して HUD に追加表示する
      //   - server 側: window.__cscs_sync_state.streak3Wrong / streakWrongLen（存在すれば使用）
      //   - local 側: localStorage の cscs_q_wrong_streak3_total:{qid}, cscs_q_wrong_streak_len:{qid}
      var qidForStreakWrong = info && info.qid ? info.qid : null;
      var serverStreak3Wrong = 0;
      var localStreak3Wrong = 0;
      var diffStreak3Wrong = 0;
      var serverWrongStreakLen = 0;
      var localWrongStreakLen = 0;
      var diffWrongStreakLen = 0;
      var serverWrongProgress = 0;
      var localWrongProgress = 0;
      var diffWrongProgress = 0;

      try {
        if (qidForStreakWrong) {
          var stateForWrong = null;
          try {
            stateForWrong = window.__cscs_sync_state || null;
          } catch (_eStateWrong) {
            stateForWrong = null;
          }

          // サーバ側の 3連続不正解回数（存在する場合のみ採用）
          if (
            stateForWrong &&
            stateForWrong.streak3Wrong &&
            typeof stateForWrong.streak3Wrong === "object" &&
            stateForWrong.streak3Wrong[qidForStreakWrong] != null
          ) {
            var s3w = stateForWrong.streak3Wrong[qidForStreakWrong];
            if (typeof s3w === "number" && Number.isFinite(s3w) && s3w >= 0) {
              serverStreak3Wrong = s3w;
            }
          }

          // サーバ側の「現在の連続不正解長」（存在する場合のみ採用）
          if (
            stateForWrong &&
            stateForWrong.streakWrongLen &&
            typeof stateForWrong.streakWrongLen === "object" &&
            stateForWrong.streakWrongLen[qidForStreakWrong] != null
          ) {
            var slw = stateForWrong.streakWrongLen[qidForStreakWrong];
            if (typeof slw === "number" && Number.isFinite(slw) && slw >= 0) {
              serverWrongStreakLen = slw;
            }
          }

          // localStorage 側の 3連続不正解回数 / 現在の連続不正解長
          localStreak3Wrong = readIntFromLocalStorage("cscs_q_wrong_streak3_total:" + qidForStreakWrong);
          localWrongStreakLen = readIntFromLocalStorage("cscs_q_wrong_streak_len:" + qidForStreakWrong);

          // SYNC と local の diff と 3回に対する進捗（0〜2/3）を計算
          diffStreak3Wrong = Math.max(0, localStreak3Wrong - serverStreak3Wrong);
          diffWrongStreakLen = Math.max(0, localWrongStreakLen - serverWrongStreakLen);

          serverWrongProgress = serverWrongStreakLen % 3;
          localWrongProgress = localWrongStreakLen % 3;
          diffWrongProgress = Math.max(0, localWrongProgress - serverWrongProgress);

          console.log("[SYNC-B:view] wrong-streak status", {
            qid: qidForStreakWrong,
            serverStreak3Wrong: serverStreak3Wrong,
            localStreak3Wrong: localStreak3Wrong,
            diffStreak3Wrong: diffStreak3Wrong,
            serverWrongStreakLen: serverWrongStreakLen,
            localWrongStreakLen: localWrongStreakLen,
            diffWrongStreakLen: diffWrongStreakLen,
            serverWrongProgress: serverWrongProgress,
            localWrongProgress: localWrongProgress
          });
        }
      } catch (eWrong) {
        console.error("[SYNC-B:view] wrong-streak status error:", eWrong);
      }

      var s3TodaySyncDay = (window.__cscs_sync_state && window.__cscs_sync_state.streak3Today && window.__cscs_sync_state.streak3Today.day) 
        ? window.__cscs_sync_state.streak3Today.day : "-";
      var s3TodaySyncCnt = (window.__cscs_sync_state && window.__cscs_sync_state.streak3Today && window.__cscs_sync_state.streak3Today.unique_count) 
        ? window.__cscs_sync_state.streak3Today.unique_count : 0;

      var localS3TodayDay = "";
      var localS3TodayCnt = 0;
      try {
        localS3TodayDay = localStorage.getItem("cscs_streak3_today_day") || "-";
        var rawLocalCnt = localStorage.getItem("cscs_streak3_today_unique_count");
        var parsedLocalCnt = rawLocalCnt == null ? NaN : parseInt(rawLocalCnt, 10);
        if (Number.isFinite(parsedLocalCnt) && parsedLocalCnt >= 0) {
          localS3TodayCnt = parsedLocalCnt;
        }
      } catch(_e) {}

      // ★ 3連続不正解（Streak3WrongToday）の SYNC / local 状態も取得
      var s3WrongTodaySyncDay = (window.__cscs_sync_state && window.__cscs_sync_state.streak3WrongToday && window.__cscs_sync_state.streak3WrongToday.day) 
        ? window.__cscs_sync_state.streak3WrongToday.day : "-";
      var s3WrongTodaySyncCnt = (window.__cscs_sync_state && window.__cscs_sync_state.streak3WrongToday && window.__cscs_sync_state.streak3WrongToday.unique_count) 
        ? window.__cscs_sync_state.streak3WrongToday.unique_count : 0;

      var localS3WrongTodayDay = "";
      var localS3WrongTodayCnt = 0;
      try {
        localS3WrongTodayDay = localStorage.getItem("cscs_streak3_wrong_today_day") || "-";
        var rawLocalWrongCnt = localStorage.getItem("cscs_streak3_wrong_today_unique_count");
        var parsedLocalWrongCnt = rawLocalWrongCnt == null ? NaN : parseInt(rawLocalWrongCnt, 10);
        if (Number.isFinite(parsedLocalWrongCnt) && parsedLocalWrongCnt >= 0) {
          localS3WrongTodayCnt = parsedLocalWrongCnt;
        }
      } catch(_e2) {}

      // ★ Pending 詳細表示用：Today系 qids（SYNC / local）を取得して model に載せる
      var s3TodaySyncQids = [];
      var s3WrongTodaySyncQids = [];
      try {
        if (window.__cscs_sync_state &&
            window.__cscs_sync_state.streak3Today &&
            Array.isArray(window.__cscs_sync_state.streak3Today.qids)) {
          s3TodaySyncQids = window.__cscs_sync_state.streak3Today.qids
            .filter(function (x) { return typeof x === "string" && x; });
        }
      } catch (_eS3TodaySyncQids) {
        s3TodaySyncQids = [];
      }

      try {
        if (window.__cscs_sync_state &&
            window.__cscs_sync_state.streak3WrongToday &&
            Array.isArray(window.__cscs_sync_state.streak3WrongToday.qids)) {
          s3WrongTodaySyncQids = window.__cscs_sync_state.streak3WrongToday.qids
            .filter(function (x) { return typeof x === "string" && x; });
        }
      } catch (_eS3WrongTodaySyncQids) {
        s3WrongTodaySyncQids = [];
      }

      var localS3TodayQids = [];
      try {
        var rawLocalS3TodayQids = localStorage.getItem("cscs_streak3_today_qids");
        if (rawLocalS3TodayQids) {
          var parsedLocalS3TodayQids = JSON.parse(rawLocalS3TodayQids);
          if (Array.isArray(parsedLocalS3TodayQids)) {
            localS3TodayQids = parsedLocalS3TodayQids
              .filter(function (x) { return typeof x === "string" && x; });
          }
        }
      } catch (_eLocalS3TodayQids) {
        localS3TodayQids = [];
      }

      var localS3WrongTodayQids = [];
      try {
        var rawLocalS3WrongTodayQids = localStorage.getItem("cscs_streak3_wrong_today_qids");
        if (rawLocalS3WrongTodayQids) {
          var parsedLocalS3WrongTodayQids = JSON.parse(rawLocalS3WrongTodayQids);
          if (Array.isArray(parsedLocalS3WrongTodayQids)) {
            localS3WrongTodayQids = parsedLocalS3WrongTodayQids
              .filter(function (x) { return typeof x === "string" && x; });
          }
        }
      } catch (_eLocalS3WrongTodayQids) {
        localS3WrongTodayQids = [];
      }

      // ★ 計測記録がない場合は「-」、それ以外は day をそのまま表示
      var s3TodayDayLabel = (s3TodaySyncDay === "-" ? "-" : String(s3TodaySyncDay));
      var s3WrongTodayDayLabel = (s3WrongTodaySyncDay === "-" ? "-" : String(s3WrongTodaySyncDay));

      // ★ ここから：問題別 最終日情報（lastSeen / lastCorrect / lastWrong）を HUD に追加
      var lastSeenSyncLabel = "-";
      var lastCorrectSyncLabel = "-";
      var lastWrongSyncLabel = "-";

      var lastSeenLocalLabel = "-";
      var lastCorrectLocalLabel = "-";
      var lastWrongLocalLabel = "-";

      try {
        var qidForLastDay = info && info.qid ? info.qid : null;

        // ---- SYNC 側の lastSeen / lastCorrect / lastWrong 読み取り ----
        var st = null;
        try { st = window.__cscs_sync_state || null; } catch (_e) { st = null; }

        if (qidForLastDay && st) {
          // lastSeen
          if (st.lastSeenDay &&
              typeof st.lastSeenDay === "object" &&
              st.lastSeenDay[qidForLastDay] != null) {
            var v1 = st.lastSeenDay[qidForLastDay];
            if (typeof v1 === "number" && Number.isFinite(v1) && v1 > 0) {
              lastSeenSyncLabel = String(v1);
            }
          }
          // lastCorrect
          if (st.lastCorrectDay &&
              typeof st.lastCorrectDay === "object" &&
              st.lastCorrectDay[qidForLastDay] != null) {
            var v2 = st.lastCorrectDay[qidForLastDay];
            if (typeof v2 === "number" && Number.isFinite(v2) && v2 > 0) {
              lastCorrectSyncLabel = String(v2);
            }
          }
          // lastWrong
          if (st.lastWrongDay &&
              typeof st.lastWrongDay === "object" &&
              st.lastWrongDay[qidForLastDay] != null) {
            var v3 = st.lastWrongDay[qidForLastDay];
            if (typeof v3 === "number" && Number.isFinite(v3) && v3 > 0) {
              lastWrongSyncLabel = String(v3);
            }
          }
        }

        // ---- localStorage 側の lastSeen / lastCorrect / lastWrong 読み取り ----
        if (qidForLastDay) {
          var loc1 = readDayFromLocalStorage("cscs_q_last_seen_day:" + qidForLastDay);
          var loc2 = readDayFromLocalStorage("cscs_q_last_correct_day:" + qidForLastDay);
          var loc3 = readDayFromLocalStorage("cscs_q_last_wrong_day:" + qidForLastDay);

          if (loc1 !== null) lastSeenLocalLabel = String(loc1);
          if (loc2 !== null) lastCorrectLocalLabel = String(loc2);
          if (loc3 !== null) lastWrongLocalLabel = String(loc3);
        }

      } catch (eLast) {
        console.error("[SYNC-B:view] lastDay HUD build error:", eLast);
      }

      // ★ OncePerDayToday / O.D.O.A 表示用の値を localStorage + window.__cscs_sync_state から組み立て
      var onceStateLabel = "未開始";
      var onceMeasureOkLabel = "-";
      var onceResultLabel = "-";
      var onceTodayDateLabel = "-";
      var onceQidLabel = (info && info.qid) ? info.qid : "-";
      var onceCountableLabel = "-";
      var onceRecordLabel = "-";
      var onceOdoaLabel = "-";

      try {
        // 今日(YYYY-MM-DD) は JST の「日付だけ」表示
        try {
          var now = new Date();
          var y = now.getFullYear();
          var m = String(now.getMonth() + 1).padStart(2, "0");
          var d = String(now.getDate()).padStart(2, "0");
          onceTodayDateLabel = String(y) + "-" + String(m) + "-" + String(d);
        } catch (_eDate) {
          onceTodayDateLabel = "-";
        }

        var stOnce = null;
        try { stOnce = window.__cscs_sync_state || null; } catch (_eSt) { stOnce = null; }

        // --- 何をしているか:
        //   今日の「計測済み判定」は唯一の参照元として window.__cscs_sync_state.oncePerDayToday だけを見る
        //   （localStorage の oncePerDayToday は HUD 判定に一切使わない）
        var serverOnceVal = null;
        var serverOnceDay = null;

        if (stOnce && stOnce.oncePerDayToday && typeof stOnce.oncePerDayToday === "object") {
          var s = stOnce.oncePerDayToday;
          if (typeof s.day === "number" && Number.isFinite(s.day)) {
            serverOnceDay = s.day;
          }
          if (s.results && typeof s.results === "object" && Object.prototype.hasOwnProperty.call(s.results, onceQidLabel)) {
            serverOnceVal = s.results[onceQidLabel];
          }
        }

        // --- 何をしているか:
        //   HUD 表示用の状態文字列を serverOnceVal だけで作る（フォールバックしない）
        if (serverOnceVal === "correct" || serverOnceVal === "wrong") {
          onceStateLabel = "計測済";
        } else {
          onceStateLabel = "未開始";
        }

        // --- 何をしているか:
        //   localの記録表示は “today 判定” の参照元から外すため、HUDでは常に "-" に固定
        onceRecordLabel = "-";

        // --- 何をしているか:
        //   結果表示も serverOnceVal のみ（フォールバックしない）
        if (serverOnceVal === "correct" || serverOnceVal === "wrong") {
          onceResultLabel = String(serverOnceVal);
        } else {
          onceResultLabel = "-";
        }

        // --- 何をしているか:
        //   計測OKは「serverOnceVal が存在するか」だけで決める（ローカル照合はしない）
        if (serverOnceVal === "correct" || serverOnceVal === "wrong") {
          onceMeasureOkLabel = "OK";
        } else {
          onceMeasureOkLabel = "NG";
        }

        // --- 何をしているか:
        //   すでに計測済みかどうかも唯一の参照元（serverOnceVal）だけで判定
        var alreadyCounted = false;
        if (serverOnceVal === "correct" || serverOnceVal === "wrong") {
          alreadyCounted = true;
        }

        // --- 何をしているか:
        //   VERIFYモードは常に count対象 NO（ガード）
        var verifyModeOn =
          typeof window.CSCS_VERIFY_MODE === "string" && window.CSCS_VERIFY_MODE === "on";

        // --- 何をしているか:
        //   ODOAモードは唯一の参照元 window.CSCS_ODOA_MODE（"on"/"off"）のみを見る
        var odoaRaw = null;
        try {
          if (typeof window.CSCS_ODOA_MODE === "string") {
            odoaRaw = window.CSCS_ODOA_MODE;
          }
        } catch (_eOdoaPick) {
          odoaRaw = null;
        }

        var odoaLower = "";
        try {
          odoaLower = (odoaRaw == null ? "" : String(odoaRaw)).trim().toLowerCase();
        } catch (_eOdoaLower) {
          odoaLower = "";
        }

        // --- 何をしているか:
        //   "on"/"off" 以外は未知扱いにせず OFF に寄せる（参照元は変えない）
        var odoaIsOn = (odoaLower === "on");

        // --- 何をしているか:
        //   count対象は「計測済」「VERIFY」「ODOA」で No、それ以外のみ Yes
        if (alreadyCounted) {
          onceCountableLabel = "No（計測済）";
        } else if (verifyModeOn) {
          onceCountableLabel = "No（ガード）";
        } else if (odoaIsOn) {
          onceCountableLabel = "No（ガード）";
        } else {
          onceCountableLabel = "Yes（未計測）";
        }

        // --- 何をしているか:
        //   ODOA行の末尾ステータスは「oncePerDayToday の結果」だけを採用（フォールバックしない）
        var odoaResultSuffix = "nocount";
        if (serverOnceVal === "correct") {
          odoaResultSuffix = "Correct";
        } else if (serverOnceVal === "wrong") {
          odoaResultSuffix = "Wrong";
        }

        // --- 何をしているか:
        //   VERIFY/ODOA は累計加算 No として表示する（ガード理由の明示）
        var addNo = false;
        if (verifyModeOn) addNo = true;
        if (odoaIsOn) addNo = true;

        // ★ 表示ルール:
        //   ODOA が ON（累計加算: No）のときは末尾サフィックスを "-" にする
        if (odoaIsOn && addNo) {
          odoaResultSuffix = "-";
        }

        if (odoaIsOn) {
          onceOdoaLabel = "ON（累計加算: " + (addNo ? "No" : "Yes") + "）  " + odoaResultSuffix;
        } else {
          onceOdoaLabel = "OFF（累計加算: Yes）  " + odoaResultSuffix;
        }
      } catch (_eOnceAll) {
        onceStateLabel = "未開始";
        onceMeasureOkLabel = "-";
        onceResultLabel = "-";
        onceTodayDateLabel = "-";
        onceQidLabel = (info && info.qid) ? info.qid : "-";
        onceCountableLabel = "-";
        onceRecordLabel = "-";
        onceOdoaLabel = "-";
      }

      // ★ グリッド描画用モデル（2列：label / value）
      updateSyncBodyGrid({
        serverCorrect: serverCorrect,
        serverWrong: serverWrong,
        localCorrect: localCorrect,
        localWrong: localWrong,
        diffCorrect: diffCorrect,
        diffWrong: diffWrong,

        serverStreak3: serverStreak3,
        localStreak3: localStreak3,
        diffStreak3: diffStreak3,

        serverStreakLen: serverStreakLen,
        localStreakLen: localStreakLen,
        diffStreakLen: diffStreakLen,

        serverProgress: serverProgress,
        localProgress: localProgress,
        diffProgress: diffProgress,

        serverStreak3Wrong: serverStreak3Wrong,
        localStreak3Wrong: localStreak3Wrong,
        diffStreak3Wrong: diffStreak3Wrong,

        serverWrongStreakLen: serverWrongStreakLen,
        localWrongStreakLen: localWrongStreakLen,
        diffWrongStreakLen: diffWrongStreakLen,

        serverWrongProgress: serverWrongProgress,
        localWrongProgress: localWrongProgress,
        diffWrongProgress: diffWrongProgress,

        s3TodayDayLabel: s3TodayDayLabel,
        s3TodaySyncCnt: s3TodaySyncCnt,
        localS3TodayCnt: localS3TodayCnt,

        s3WrongTodayDayLabel: s3WrongTodayDayLabel,
        s3WrongTodaySyncCnt: s3WrongTodaySyncCnt,
        localS3WrongTodayCnt: localS3WrongTodayCnt,

        // ★ Pending 詳細表示用：qids（SYNC / local）
        s3TodaySyncQids: s3TodaySyncQids,
        localS3TodayQids: localS3TodayQids,
        s3WrongTodaySyncQids: s3WrongTodaySyncQids,
        localS3WrongTodayQids: localS3WrongTodayQids,

        lastSeenSyncLabel: lastSeenSyncLabel,
        lastCorrectSyncLabel: lastCorrectSyncLabel,
        lastWrongSyncLabel: lastWrongSyncLabel,

        lastSeenLocalLabel: lastSeenLocalLabel,
        lastCorrectLocalLabel: lastCorrectLocalLabel,
        lastWrongLocalLabel: lastWrongLocalLabel,

        pending: (payload && payload.pending) ? payload.pending : null,

        onceStateLabel: onceStateLabel,
        onceMeasureOkLabel: onceMeasureOkLabel,
        onceResultLabel: onceResultLabel,
        onceTodayDateLabel: onceTodayDateLabel,
        onceQidLabel: onceQidLabel,
        onceCountableLabel: onceCountableLabel,
        onceRecordLabel: onceRecordLabel,
        onceOdoaLabel: onceOdoaLabel,

        // ★ 追加: b_judge_record.js 由来のローカル計測（最高連続正解数 / 更新日）
        localCorrectStreakMax: localCorrectStreakMax,
        localCorrectStreakMaxDayLabel: localCorrectStreakMaxDayLabel,

        // ★ 追加: b_judge_record.js 由来のローカル計測（最高連続不正解数 / 達成日）
        localWrongStreakMax: localWrongStreakMax,
        localWrongStreakMaxDayLabel: localWrongStreakMaxDayLabel,

        // ★ 追加: SYNC側（streak_max / max_day）
        serverCorrectStreakMax: serverCorrectStreakMax,
        serverCorrectStreakMaxDayLabel: serverCorrectStreakMaxDayLabel,
        serverWrongStreakMax: serverWrongStreakMax,
        serverWrongStreakMaxDayLabel: serverWrongStreakMaxDayLabel
      });

      // ★ 何をしているか:
      //   OncePerDayToday / O.D.O.A Mode は「body(#cscs_sync_view_b_body) 専用」に一本化する。
      //   status(#cscs_sync_view_b_status) には once/odoa を一切生成/挿入しない（重複・ちらつき根絶）。
      var statusDiv = document.getElementById("cscs_sync_view_b_status");
      if (statusDiv) {
        statusDiv.textContent = "";
      }

      // 内部用の statusText はログとして残すだけ
      if (statusText) {
        console.log("[SYNC-B] statusText (internal):", statusText);
      }
    } catch (e) {
      var errorText = "SYNC(B) " + info.qid + "  error: " + (e && e.message ? e.message : e);
      updateSyncBodyText(errorText);

      // ★ 何をしているか:
      //   エラー時でも status(#cscs_sync_view_b_status) に once/odoa を出さない（body専用の原則維持）。
      var statusDiv = document.getElementById("cscs_sync_view_b_status");
      if (statusDiv) {
        statusDiv.textContent = "";
      }

      console.error("[SYNC-B] renderPanel error:", e);
    }
  }

  async function sendDiffToServer(box, params) {
    var qid = info.qid;

    // ★ 手動送信の強制フラグ
    //   - ボタン押下直後（2秒以内）なら forceSend=true 扱い
    //   - params.forceSend === true が明示されていればそれも優先
    var forceSend = false;
    try {
      if (params && params.forceSend === true) {
        forceSend = true;
      } else {
        var ts = window.__cscs_sync_b_manual_send_ts || 0;
        if (typeof ts === "number" && Number.isFinite(ts) && ts > 0) {
          if ((Date.now() - ts) <= 2000) {
            forceSend = true;
          }
        }
      }
    } catch (_eForce) {
      forceSend = false;
    }

    // ====== ① 各種 diff / local / server 値を受け取る ======
    // params は refreshAndSend() 側で作られた「同期前の状態比較」結果
    var diffCorrect = params.diffCorrect;      // local - server の「正解」増分
    var diffWrong = params.diffWrong;          // local - server の「不正解」増分
    var diffStreak3 = params.diffStreak3 || 0; // local streak3 達成の増分（3連続正解の+1）
    var diffStreakLen = params.diffStreakLen || 0;
    // ★ 不正解側: 3連続不正解の増分と、連続不正解長の差分（0 以上の増分）
    var diffStreak3Wrong = params.diffStreak3Wrong || 0;
    var diffWrongStreakLen = params.diffWrongStreakLen || 0;

    var localCorrect = params.localCorrect;    // localStorage 側の正解累計値
    var localWrong = params.localWrong;        // localStorage 側の不正解累計値
    var localStreak3 = params.localStreak3 || 0;
    var localStreakLen = params.localStreakLen || 0;
    // ★ 不正解側: localStorage の 3連続不正解回数 / 連続不正解長
    var localStreak3Wrong = params.localStreak3Wrong || 0;
    var localWrongStreakLen = params.localWrongStreakLen || 0;

    var serverCorrect = params.serverCorrect;  // サーバー側 snapshot の正解累計
    var serverWrong = params.serverWrong;
    var serverStreak3 = params.serverStreak3 || 0;
    var serverStreakLen = params.serverStreakLen || 0;
    // ★ 不正解側: サーバー側 snapshot の 3連続不正解回数 / 連続不正解長
    var serverStreak3Wrong = params.serverStreak3Wrong || 0;
    var serverWrongStreakLen = params.serverWrongStreakLen || 0;

    // ★ コンソールで送信前の不正解ストリーク状態を確認できるようにログ出力
    console.log("[SYNC-B] sendDiffToServer: wrong-streak params", {
      qid: qid,
      diffStreak3Wrong: diffStreak3Wrong,
      diffWrongStreakLen: diffWrongStreakLen,
      localStreak3Wrong: localStreak3Wrong,
      localWrongStreakLen: localWrongStreakLen,
      serverStreak3Wrong: serverStreak3Wrong,
      serverWrongStreakLen: serverWrongStreakLen
    });

    // ★ 何をしているか:
    //   ODOAモードは唯一の参照元 window.CSCS_ODOA_MODE（"on"/"off"）のみを見る（params には依存しない）
    var odoaModeText = "OFF";
    try {
      var t = (typeof window.CSCS_ODOA_MODE === "string" ? window.CSCS_ODOA_MODE : "").trim().toLowerCase();
      if (t === "on") {
        odoaModeText = "ON";
      } else if (t === "off") {
        odoaModeText = "OFF";
      }
    } catch (_eOdoaModeText) {
      odoaModeText = "OFF";
    }

    // ★ 追加: /api/sync/state の snapshot を受け取り、
    //    そこから oncePerDayTodayDelta / 最終日 Delta を構築するために利用する
    var syncState = params.syncState || null;

    // ★ 追加: oncePerDayTodayDelta を事前に構築しておく
    //   - 差分が無ければ null
    //   - 何かあれば { day, results } を返す
    var oncePerDayDelta = buildOncePerDayTodayDelta(syncState);

    // ★ 追加: 最終学習日・最終正解日・最終不正解日の local / server を取得し、差分の有無を判定
    var localLastSeenDay = readDayFromLocalStorage("cscs_q_last_seen_day:" + qid);
    var localLastCorrectDay = readDayFromLocalStorage("cscs_q_last_correct_day:" + qid);
    var localLastWrongDay = readDayFromLocalStorage("cscs_q_last_wrong_day:" + qid);

    var serverLastSeenDay = null;
    var serverLastCorrectDay = null;
    var serverLastWrongDay = null;

    if (syncState) {
      if (syncState.lastSeenDay && typeof syncState.lastSeenDay === "object" && syncState.lastSeenDay[qid] != null) {
        var sSeen = syncState.lastSeenDay[qid];
        if (typeof sSeen === "number" && Number.isFinite(sSeen) && sSeen > 0) {
          serverLastSeenDay = sSeen;
        }
      }
      if (syncState.lastCorrectDay && typeof syncState.lastCorrectDay === "object" && syncState.lastCorrectDay[qid] != null) {
        var sCor = syncState.lastCorrectDay[qid];
        if (typeof sCor === "number" && Number.isFinite(sCor) && sCor > 0) {
          serverLastCorrectDay = sCor;
        }
      }
      if (syncState.lastWrongDay && typeof syncState.lastWrongDay === "object" && syncState.lastWrongDay[qid] != null) {
        var sWrong = syncState.lastWrongDay[qid];
        if (typeof sWrong === "number" && Number.isFinite(sWrong) && sWrong > 0) {
          serverLastWrongDay = sWrong;
        }
      }
    }

    var hasLastSeenDayDiff = localLastSeenDay !== null && localLastSeenDay !== serverLastSeenDay;
    var hasLastCorrectDayDiff = localLastCorrectDay !== null && localLastCorrectDay !== serverLastCorrectDay;
    var hasLastWrongDayDiff = localLastWrongDay !== null && localLastWrongDay !== serverLastWrongDay;

    if (hasLastSeenDayDiff || hasLastCorrectDayDiff || hasLastWrongDayDiff) {
      console.log("[SYNC-B] lastDay diff detected", {
        qid: qid,
        localLastSeenDay: localLastSeenDay,
        serverLastSeenDay: serverLastSeenDay,
        localLastCorrectDay: localLastCorrectDay,
        serverLastCorrectDay: serverLastCorrectDay,
        localLastWrongDay: localLastWrongDay,
        serverLastWrongDay: serverLastWrongDay
      });
    }

    // ★ 何をしているか:
    //   HUD再描画などで suppressDiffSend が立っている場合でも、
    //   diff が非ゼロなら「送信は抑止しない」方針に寄せる。
    //   つまり suppressDiffSend は「diff がゼロのときだけ return」できる。
    var suppressDiffSend = false;
    try {
      suppressDiffSend = !!(params && params.suppressDiffSend);
    } catch (_eSuppressPick) {
      suppressDiffSend = false;
    }

    // ★ 何をしているか:
    //   送るべき差分が“完全にゼロ”かどうかを 1 個の真偽値に集約する。
    //   （forceSend は別枠なので、ここでは forceSend の判定式と同等条件にしている）
    var diffIsZero =
      (!forceSend &&
       diffCorrect <= 0 &&
       diffWrong <= 0 &&
       diffStreak3 <= 0 &&
       diffStreak3Wrong <= 0 &&
       localStreakLen === serverStreakLen &&
       localWrongStreakLen === serverWrongStreakLen &&
       !oncePerDayDelta &&
       !hasLastSeenDayDiff &&
       !hasLastCorrectDayDiff &&
       !hasLastWrongDayDiff);

    // ★ 何をしているか:
    //   suppressDiffSend が true の場合でも、
    //   diffIsZero のときだけ return（＝HUD再描画由来の無駄送信を止める）。
    //   diffIsZero が false のときは「抑止せず送信へ進む」ことをログで保証する。
    if (suppressDiffSend && diffIsZero) {
      console.log("[SYNC-B] suppressDiffSend=ON & diffIsZero=TRUE → return (send suppressed)", {
        qid: qid,
        suppressDiffSend: suppressDiffSend,
        diffIsZero: diffIsZero
      });
      return;
    }

    if (suppressDiffSend && !diffIsZero) {
      console.log("[SYNC-B] suppressDiffSend=ON but diffIsZero=FALSE → continue (send NOT suppressed)", {
        qid: qid,
        suppressDiffSend: suppressDiffSend,
        diffIsZero: diffIsZero,
        diffCorrect: diffCorrect,
        diffWrong: diffWrong,
        diffStreak3: diffStreak3,
        diffStreak3Wrong: diffStreak3Wrong,
        localStreakLen: localStreakLen,
        serverStreakLen: serverStreakLen,
        localWrongStreakLen: localWrongStreakLen,
        serverWrongStreakLen: serverWrongStreakLen,
        hasOncePerDayDelta: !!oncePerDayDelta,
        hasLastSeenDayDiff: hasLastSeenDayDiff,
        hasLastCorrectDayDiff: hasLastCorrectDayDiff,
        hasLastWrongDayDiff: hasLastWrongDayDiff
      });
    }

    // ====== ② diff が存在しない場合は SYNC を送らず終了 ======
    // ・diffCorrect / diffWrong / diffStreak3 / diffStreak3Wrong が 0 以下
    // ・かつ streakLen / streakWrongLen が server と同じ
    // ・かつ oncePerDayDelta が null
    // ・かつ lastSeen / lastCorrect / lastWrong に差分が無い
    //
    // → 「今回は送るべき更新が何もない」ので、
    //    HUD パネルの表示だけ更新して return する。
    if (diffIsZero) {

      var odoaStatusTextForPanel;
      if (odoaModeText === "ON") {
        odoaStatusTextForPanel = "O.D.O.A Mode : ON nocount";
      } else {
        odoaStatusTextForPanel = "O.D.O.A Mode : OFF";
      }

      renderPanel(box, {
        serverCorrect: serverCorrect,
        serverWrong: serverWrong,
        localCorrect: localCorrect,
        localWrong: localWrong,
        diffCorrect: diffCorrect,
        diffWrong: diffWrong,
        serverStreak3: serverStreak3,
        localStreak3: localStreak3,
        diffStreak3: diffStreak3,
        serverStreakLen: serverStreakLen,
        localStreakLen: localStreakLen,
        diffStreakLen: diffStreakLen,
        statusText: "no diff (送信なし) / oncePerDayToday: 計測なし",
        odoaModeText: odoaModeText,
        odoaStatusText: odoaStatusTextForPanel
      });
      return;
    }

    // ====== ③ オフライン時は送れないため「未送信」ステータスで終了 ======
    if (!navigator.onLine) {
      var offlineOncePerDayStatus = oncePerDayDelta ? "oncePerDayToday: 計測エラー" : "oncePerDayToday: 計測なし";
      var odoaStatusTextForPanelOffline;
      if (odoaModeText === "ON") {
        odoaStatusTextForPanelOffline = "O.D.O.A Mode : ON nocount";
      } else {
        odoaStatusTextForPanelOffline = "O.D.O.A Mode : OFF";
      }
      renderPanel(box, {
        serverCorrect: serverCorrect,
        serverWrong: serverWrong,
        localCorrect: localCorrect,
        localWrong: localWrong,
        diffCorrect: diffCorrect,
        diffWrong: diffWrong,
        serverStreak3: serverStreak3,
        localStreak3: localStreak3,
        diffStreak3: diffStreak3,
        serverStreakLen: serverStreakLen,
        localStreakLen: localStreakLen,
        diffStreakLen: diffStreakLen,
        statusText: "offline (未送信) / " + offlineOncePerDayStatus,
        odoaModeText: odoaModeText,
        odoaStatusText: odoaStatusTextForPanelOffline
      });
      return;
    }

    // ====== ④ 各 delta オブジェクトを作る（送信する差分を構築） ======
    // * diffCorrect, diffWrong, diffStreak3 等は「増分として送る」
    // * streakLenDelta / streakWrongLenDelta / last*DayDelta は「最新値で上書きする」
    var correctDeltaObj = {};
    var incorrectDeltaObj = {};
    var streak3DeltaObj = {};
    var streakLenDeltaObj = {};
    var streak3WrongDeltaObj = {};
    var streakWrongLenDeltaObj = {};
    var lastSeenDayDeltaObj = {};
    var lastCorrectDayDeltaObj = {};
    var lastWrongDayDeltaObj = {};

    if (diffCorrect > 0) {
      correctDeltaObj[qid] = diffCorrect;
    }
    if (diffWrong > 0) {
      incorrectDeltaObj[qid] = diffWrong;
    }
    if (diffStreak3 > 0) {
      streak3DeltaObj[qid] = diffStreak3;
    }
    // ★ 不正解側: 3連続不正解の増分があれば delta として送信
    if (diffStreak3Wrong > 0) {
      streak3WrongDeltaObj[qid] = diffStreak3Wrong;
      console.log("[SYNC-B] streak3WrongDelta set:", {
        qid: qid,
        diffStreak3Wrong: diffStreak3Wrong
      });
    }

    // ====== ⑤ streakLenDelta（連続正解長）の扱い ======
    // ★ local と server が同じ連続正解長なら送らない（ノイズ防止）
    // ★ local と server が違う場合のみ「値そのもの」を送る
    //
    // ※ streakLenDelta は「増分」ではなく「セットする最新値」
    if (localStreakLen !== serverStreakLen) {
      streakLenDeltaObj[qid] = localStreakLen;
      console.log("[SYNC-B] streakLenDelta set (local != server):", {
        qid: qid,
        localStreakLen: localStreakLen,
        serverStreakLen: serverStreakLen
      });
    } else {
      console.log("[SYNC-B] streakLenDelta not set (local == server):", {
        qid: qid,
        localStreakLen: localStreakLen,
        serverStreakLen: serverStreakLen
      });
    }

    // ★ 不正解側: streakWrongLenDelta（連続不正解長）の扱い
    //   - local と server が同じ連続不正解長なら送らない
    //   - 違う場合のみ「最新値」として送る
    if (localWrongStreakLen !== serverWrongStreakLen) {
      streakWrongLenDeltaObj[qid] = localWrongStreakLen;
      console.log("[SYNC-B] streakWrongLenDelta set (local != server):", {
        qid: qid,
        localWrongStreakLen: localWrongStreakLen,
        serverWrongStreakLen: serverWrongStreakLen
      });
    } else {
      console.log("[SYNC-B] streakWrongLenDelta not set (local == server):", {
        qid: qid,
        localWrongStreakLen: localWrongStreakLen,
        serverWrongStreakLen: serverWrongStreakLen
      });
    }

    // ★ 最終日情報: local と server が異なる場合のみ「最新日付」で上書きする Delta を付与
    if (hasLastSeenDayDiff && localLastSeenDay !== null) {
      lastSeenDayDeltaObj[qid] = localLastSeenDay;
      console.log("[SYNC-B] lastSeenDayDelta set:", {
        qid: qid,
        localLastSeenDay: localLastSeenDay,
        serverLastSeenDay: serverLastSeenDay
      });
    }
    if (hasLastCorrectDayDiff && localLastCorrectDay !== null) {
      lastCorrectDayDeltaObj[qid] = localLastCorrectDay;
      console.log("[SYNC-B] lastCorrectDayDelta set:", {
        qid: qid,
        localLastCorrectDay: localLastCorrectDay,
        serverLastCorrectDay: serverLastCorrectDay
      });
    }
    if (hasLastWrongDayDiff && localLastWrongDay !== null) {
      lastWrongDayDeltaObj[qid] = localLastWrongDay;
      console.log("[SYNC-B] lastWrongDayDelta set:", {
        qid: qid,
        localLastWrongDay: localLastWrongDay,
        serverLastWrongDay: serverLastWrongDay
      });
    }

    // ====== ⑥ 上記 delta 群をまとめて payload を構築 ======
    var payload = {
      // ★ 追加: payload のトップレベルに種別を明示し、「diff（差分）」送信であることをサーバ側に伝える
      payloadType: "diff",

      correctDelta:  correctDeltaObj,
      incorrectDelta: incorrectDeltaObj,
      streak3Delta:  streak3DeltaObj,
      streakLenDelta: streakLenDeltaObj,            // streakLen は上書き
      streak3WrongDelta: streak3WrongDeltaObj,      // 不正解側 3連続の増分
      streakWrongLenDelta: streakWrongLenDeltaObj,  // 不正解側 連続長の最新値
      lastSeenDayDelta: lastSeenDayDeltaObj,        // 最終学習日
      lastCorrectDayDelta: lastCorrectDayDeltaObj,  // 最終正解日
      lastWrongDayDelta: lastWrongDayDeltaObj,      // 最終不正解日
      updatedAt: Date.now()                         // クライアント側での更新時刻
    };

    // ★ 追加: 総問題数（cscs_total_questions）を global.totalQuestions として付与
    //   - b_judge_record.js が manifest.json から算出・保存した値を唯一のソースとする
    //   - 正の整数が得られた場合のみ payload に含める
    var totalQuestions = readTotalQuestionsFromLocalStorage();
    if (totalQuestions !== null) {
      if (!payload.global || typeof payload.global !== "object") {
        payload.global = {};
      }
      payload.global.totalQuestions = totalQuestions;
      console.log("[SYNC-B] attach global.totalQuestions to payload:", {
        totalQuestions: totalQuestions
      });
    }

    // ★ 追加: oncePerDayTodayDelta がある場合は payload に付与
    if (oncePerDayDelta) {
      payload.oncePerDayTodayDelta = oncePerDayDelta;
      console.log("[SYNC-B] oncePerDayTodayDelta attached to payload:", oncePerDayDelta);
    }

    // ★ payload に有効な delta が 1つも無い場合は、
    //    「2回目 save 由来のノイズ送信」とみなして fetch 自体を行わないガード
    //    （ここを通らなかった＝実際に送信された、というのがログで確認できる）
    var hasCorrectDeltaInPayload = Object.prototype.hasOwnProperty.call(correctDeltaObj, qid);
    var hasIncorrectDeltaInPayload = Object.prototype.hasOwnProperty.call(incorrectDeltaObj, qid);
    var hasStreak3DeltaInPayload = Object.prototype.hasOwnProperty.call(streak3DeltaObj, qid);
    var hasStreakLenDeltaInPayload = Object.prototype.hasOwnProperty.call(streakLenDeltaObj, qid);
    var hasStreak3WrongDeltaInPayload = Object.prototype.hasOwnProperty.call(streak3WrongDeltaObj, qid);
    var hasStreakWrongLenDeltaInPayload = Object.prototype.hasOwnProperty.call(streakWrongLenDeltaObj, qid);
    var hasLastSeenDayDeltaInPayload = Object.prototype.hasOwnProperty.call(lastSeenDayDeltaObj, qid);
    var hasLastCorrectDayDeltaInPayload = Object.prototype.hasOwnProperty.call(lastCorrectDayDeltaObj, qid);
    var hasLastWrongDayDeltaInPayload = Object.prototype.hasOwnProperty.call(lastWrongDayDeltaObj, qid);
    var hasOncePerDayDeltaInPayload = !!oncePerDayDelta;
    var hasGlobalTotalQuestionsInPayload =
      !!(payload.global &&
         typeof payload.global === "object" &&
         Object.prototype.hasOwnProperty.call(payload.global, "totalQuestions"));

    if (
      !forceSend &&
      !hasCorrectDeltaInPayload &&
      !hasIncorrectDeltaInPayload &&
      !hasStreak3DeltaInPayload &&
      !hasStreakLenDeltaInPayload &&
      !hasStreak3WrongDeltaInPayload &&
      !hasStreakWrongLenDeltaInPayload &&
      !hasLastSeenDayDeltaInPayload &&
      !hasLastCorrectDayDeltaInPayload &&
      !hasLastWrongDayDeltaInPayload &&
      !hasOncePerDayDeltaInPayload &&
      !hasGlobalTotalQuestionsInPayload
    ) {
      console.log("[SYNC-B] ★送信スキップ（payload に有効な delta が無いため）", {
        qid: qid,
        payload: payload
      });

      // oncePerDayToday 用の delta も payload に含まれていないため「oncePerDayToday: 計測なし」として扱う
      // パネル側にも「送信していない」ことが分かるようステータスを反映
      renderPanel(box, {
        serverCorrect: serverCorrect,
        serverWrong: serverWrong,
        localCorrect: localCorrect,
        localWrong: localWrong,
        diffCorrect: diffCorrect,
        diffWrong: diffWrong,
        serverStreak3: serverStreak3,
        localStreak3: localStreak3,
        diffStreak3: diffStreak3,
        serverStreakLen: serverStreakLen,
        localStreakLen: localStreakLen,
        diffStreakLen: diffStreakLen,
        statusText: "no delta in payload (送信スキップ) / oncePerDayToday: 計測なし",
        odoaModeText: odoaModeText
      });
      return;
    }

    // ★ 手動送信の場合：差分がゼロでも「送信ボタン押下」をサーバへ必ず到達させる
    //   - 既存の delta 仕様は壊さず、追加フィールドだけ付与する
    if (forceSend) {
      payload.forceSend = true;
      payload.forceReason = "manual_button";
      payload.forceQid = qid;
      console.log("[SYNC-B] forceSend ON → send request even if no delta", {
        qid: qid
      });
    }

    console.log("[SYNC-B] sending diff payload:", payload);


```
<<<PART_END>>>
【RECEIPT_INPUT（このメッセージ内だけを真とする）】
EXPECTED_TOTAL: 5
RECEIVED_TOTAL: 3

CUMULATIVE_RECEIVED_PARTIDS:
- CSCSJS-C905F0E5-P01-of-05
- CSCSJS-C905F0E5-P02-of-05
- CSCSJS-C905F0E5-P03-of-05

【ChatGPTへの強制ルール】
・受領確認は、このメッセージ内の CUMULATIVE_RECEIVED_PARTIDS と EXPECTED_PARTIDS のみを使用すること。
・会話履歴から PartID を再収集しないこと（禁止）。
・受領確認OK前に、コード内容の解釈・要約・推測・修正案提示をしないこと（禁止）。

RECEIPT_REQUIRED_RESPONSE_TEMPLATE:
ACK: <PartID> <PartSHA256_8> / WAITING_NEXT

【分割コード(3)の終了】→ 次は 分割コード(4) を送ります
【ChatGPTへの指示】解釈・要約・推測・修正案提示は禁止。返答は次のみ。
ACK: <PartID> / WAITING_NEXT
