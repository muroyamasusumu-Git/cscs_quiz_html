<<<PART_BEGIN>>>
【分割コード(4)の開始】
PartID: CSCSJS-C905F0E5-P04-of-05
PartSHA256: dc93c03e795018e53c55922bbee6dc0a890a76f93af29a5ad69e2965c162e585
Range: chars 114468..158960 (len=44492)
FirstLine:     try {
LastLine: 
EndNewline: YES
PART_SCOPE_HINT: LineRange=L3327..L4468 | BraceDepth=2->1
PART_SCOPE_HINT_TOP_IDENTIFIERS: qid:112, O:54, freshState:50, state:45, odoaModeText:45, data:40, SYNC:39, svb:33, stateAfter:31, localCorrect:30, localWrong:30, correct:29
PART_SCOPE_HINT_DEFINES: refreshAndSend, ensureOnceOdoaWideTitles, ensureLocalOnceOdoaWideCard, applyCollapsed, makeCell, refreshLocalOnceOdoaCard, fmtDay8ToDateText, keyForMerge, response, mergeErrorOncePerDayStatus, freshState, serverCorrect2, serverWrong2, serverStreak3_2, serverStreakLen_2, serverStreak3Wrong2, serverWrongStreakLen2, diffCorrect2, diffWrong2, diffStreak3_2, diffStreakLen_2, diffStreak3Wrong2, diffWrongStreakLen2, pendingAfterPost, data, newServerCorrect, newServerWrong, newServerStreak3, newServerStreakLen, newServerStreak3Wrong, newServerWrongStreakLen, cVal, wVal, sVal, slVal, s3wVal, slwVal, newDiffCorrect, newDiffWrong, newDiffStreak3

```javascript
    try {
      // ============================================================
      // 重要（設計確定）:
      //   X-CSCS-Key は /api/sync/state から再取得しない。
      //   key の唯一の確定ルートは cscs_sync_bootstrap_a.js であり、
      //   window.__CSCS_SYNC_KEY_PROMISE__ の resolve をもって確定とする。
      //
      //   state を「key取得目的」で叩くことは禁止。
      // ============================================================

      if (!window.__CSCS_SYNC_KEY_PROMISE__ || typeof window.__CSCS_SYNC_KEY_PROMISE__.then !== "function") {
        throw new Error("SYNC_BOOTSTRAP_NOT_READY");
      }

      await window.__CSCS_SYNC_KEY_PROMISE__;

      var keyForMerge = "";
      try {
        keyForMerge = String(readSyncKey() || "").trim();
      } catch (_e1) {
        keyForMerge = "";
      }

      if (!keyForMerge) {
        // bootstrap 完了後にも key が無い場合は異常。
        // フォールバックで継続せず、問題を顕在化させる。
        throw new Error("X-CSCS-Key missing after bootstrap");
      }
      
      

      if (!keyForMerge) {
        console.error("[SYNC-B] ❌ X-CSCS-Key missing → abort merge POST", {
          endpoint: SYNC_MERGE_ENDPOINT,
          qid: qid,
          forceSend: !!forceSend
        });
        renderPanel(box, {
          serverCorrect: serverCorrect,
          serverWrong: serverWrong,
          localCorrect: localCorrect,
          localWrong: localWrong,
          diffCorrect: diffCorrect,
          diffWrong: diffWrong,
          serverStreak3: serverStreak3,
          localStreak3: localStreak3,
          diffStreak3: diffStreak3,
          serverStreakLen: serverStreakLen,
          localStreakLen: localStreakLen,
          diffStreakLen: diffStreakLen,
          statusText: "X-CSCS-Key missing (merge送信中止)",
          odoaModeText: odoaModeText
        });
        return;
      }

      var response = await fetch(SYNC_MERGE_ENDPOINT, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-CSCS-Key": keyForMerge
        },
        body: JSON.stringify(payload),
        keepalive: true,
        credentials: "include"
      });

      // サーバーまで届かなかった／保存に失敗した可能性
      if (!response.ok) {
        console.error("[SYNC-B] server returned non-ok status:", response.status);
        var mergeErrorOncePerDayStatus = oncePerDayDelta ? "oncePerDayToday: 計測エラー" : "oncePerDayToday: 計測なし";
        var odoaStatusTextForPanelMergeError;
        if (odoaModeText === "ON") {
          odoaStatusTextForPanelMergeError = "O.D.O.A Mode : ON nocount";
        } else {
          odoaStatusTextForPanelMergeError = "O.D.O.A Mode : OFF";
        }
        renderPanel(box, {
          serverCorrect: serverCorrect,
          serverWrong: serverWrong,
          localCorrect: localCorrect,
          localWrong: localWrong,
          diffCorrect: diffCorrect,
          diffWrong: diffWrong,
          serverStreak3: serverStreak3,
          localStreak3: localStreak3,
          diffStreak3: diffStreak3,
          serverStreakLen: serverStreakLen,
          localStreakLen: localStreakLen,
          diffStreakLen: diffStreakLen,
          statusText: "merge " + String(response.status) + " (サーバー保存エラーの可能性) / " + mergeErrorOncePerDayStatus,
          odoaModeText: odoaModeText,
          odoaStatusText: odoaStatusTextForPanelMergeError
        });
        return;
      }

      // ★ 何をしているか:
      //   POST が「ok」で返ってきた（＝HTTPレベルでは到達した）ことをログで確定させる
      console.log("[SYNC-B] POST ok → now fetchState before renderPanel", {
        qid: qid
      });

      // ★ 何をしているか:
      //   POST 完了後に /api/sync/state を取り直し、「最新state」を window.__cscs_sync_state に反映する
      var freshState = null;
      try {
        freshState = await fetchState();
        try {
          window.__cscs_sync_state = freshState;
        } catch (_eAssignFresh) {}

        console.log("[SYNC-B] fetchState ok (after POST) → window.__cscs_sync_state updated", {
          qid: qid,
          hasState: !!freshState
        });
      } catch (eFetchAfterPost) {
        console.error("[SYNC-B] fetchState failed (after POST) → renderPanel uses previous snapshot", {
          qid: qid,
          error: eFetchAfterPost
        });
        freshState = null;
      }

      // ★ 何をしているか:
      //   最新state（freshState優先。無ければ従来の params.server* を使用）からサーバ値を再確定する
      var serverCorrect2 = serverCorrect;
      var serverWrong2 = serverWrong;
      var serverStreak3_2 = serverStreak3;
      var serverStreakLen_2 = serverStreakLen;
      var serverStreak3Wrong2 = serverStreak3Wrong;
      var serverWrongStreakLen2 = serverWrongStreakLen;

      try {
        if (freshState) {
          if (freshState.correct && typeof freshState.correct === "object" && freshState.correct[qid] != null) {
            if (typeof freshState.correct[qid] === "number" && Number.isFinite(freshState.correct[qid]) && freshState.correct[qid] >= 0) {
              serverCorrect2 = freshState.correct[qid];
            }
          }
          if (freshState.incorrect && typeof freshState.incorrect === "object" && freshState.incorrect[qid] != null) {
            if (typeof freshState.incorrect[qid] === "number" && Number.isFinite(freshState.incorrect[qid]) && freshState.incorrect[qid] >= 0) {
              serverWrong2 = freshState.incorrect[qid];
            }
          }
          if (freshState.streak3 && typeof freshState.streak3 === "object" && freshState.streak3[qid] != null) {
            if (typeof freshState.streak3[qid] === "number" && Number.isFinite(freshState.streak3[qid]) && freshState.streak3[qid] >= 0) {
              serverStreak3_2 = freshState.streak3[qid];
            }
          }
          if (freshState.streakLen && typeof freshState.streakLen === "object" && freshState.streakLen[qid] != null) {
            if (typeof freshState.streakLen[qid] === "number" && Number.isFinite(freshState.streakLen[qid]) && freshState.streakLen[qid] >= 0) {
              serverStreakLen_2 = freshState.streakLen[qid];
            }
          }
          if (freshState.streak3Wrong && typeof freshState.streak3Wrong === "object" && freshState.streak3Wrong[qid] != null) {
            if (typeof freshState.streak3Wrong[qid] === "number" && Number.isFinite(freshState.streak3Wrong[qid]) && freshState.streak3Wrong[qid] >= 0) {
              serverStreak3Wrong2 = freshState.streak3Wrong[qid];
            }
          }
          if (freshState.streakWrongLen && typeof freshState.streakWrongLen === "object" && freshState.streakWrongLen[qid] != null) {
            if (typeof freshState.streakWrongLen[qid] === "number" && Number.isFinite(freshState.streakWrongLen[qid]) && freshState.streakWrongLen[qid] >= 0) {
              serverWrongStreakLen2 = freshState.streakWrongLen[qid];
            }
          }
        }
      } catch (ePickFresh) {
        console.error("[SYNC-B] pick server values from freshState failed:", ePickFresh);
      }

      // ★ 何をしているか:
      //   最新の server 値で diff を再計算し、HUDの「送信後の見た目」を確実に最新化する
      var diffCorrect2 = Math.max(0, localCorrect - serverCorrect2);
      var diffWrong2 = Math.max(0, localWrong - serverWrong2);
      var diffStreak3_2 = Math.max(0, localStreak3 - serverStreak3_2);
      var diffStreakLen_2 = Math.max(0, localStreakLen - serverStreakLen_2);
      var diffStreak3Wrong2 = Math.max(0, localStreak3Wrong - serverStreak3Wrong2);
      var diffWrongStreakLen2 = Math.max(0, localWrongStreakLen - serverWrongStreakLen2);

      // ★ 何をしているか:
      //   Pending（未反映っぽい差分）も「最新state基準」で再計算して表示に反映する
      var pendingAfterPost = null;
      try {
        pendingAfterPost = computePendingFlags(freshState || (params && params.syncState ? params.syncState : null), qid);
      } catch (_ePendingAfterPost) {
        pendingAfterPost = null;
      }

      console.log("[SYNC-B] after POST → server snapshot refreshed", {
        qid: qid,
        serverCorrect: serverCorrect2,
        serverWrong: serverWrong2,
        localCorrect: localCorrect,
        localWrong: localWrong,
        diffCorrect: diffCorrect2,
        diffWrong: diffWrong2,
        pending: pendingAfterPost
      });

      // ★ 何をしているか:
      //   POST完了→fetchState完了（または失敗）後に renderPanel を呼び、表示更新の順序を確定させる
      renderPanel(box, {
        serverCorrect: serverCorrect2,
        serverWrong: serverWrong2,
        localCorrect: localCorrect,
        localWrong: localWrong,
        diffCorrect: diffCorrect2,
        diffWrong: diffWrong2,
        serverStreak3: serverStreak3_2,
        localStreak3: localStreak3,
        diffStreak3: diffStreak3_2,
        serverStreakLen: serverStreakLen_2,
        localStreakLen: localStreakLen,
        diffStreakLen: diffStreakLen_2,
        statusText: "POST ok → fetchState → renderPanel",
        pending: pendingAfterPost,
        odoaModeText: odoaModeText,
        odoaStatusText: "__keep__"
      });

      var data = null;
      try {
        data = await response.json();
      } catch (e) {
        data = null;
      }

      console.log("[SYNC-B] sync success:", data);

      // merge のレスポンスから「サーバーに保存された値」を拾う
      var newServerCorrect = serverCorrect;
      var newServerWrong = serverWrong;
      var newServerStreak3 = serverStreak3;
      var newServerStreakLen = serverStreakLen;
      var newServerStreak3Wrong = serverStreak3Wrong;
      var newServerWrongStreakLen = serverWrongStreakLen;

      if (data && data.correct && typeof data.correct === "object" && data.correct !== null) {
        if (Object.prototype.hasOwnProperty.call(data.correct, qid)) {
          var cVal = data.correct[qid];
          if (typeof cVal === "number" && Number.isFinite(cVal) && cVal >= 0) {
            newServerCorrect = cVal;
          }
        }
      }

      if (data && data.incorrect && typeof data.incorrect === "object" && data.incorrect !== null) {
        if (Object.prototype.hasOwnProperty.call(data.incorrect, qid)) {
          var wVal = data.incorrect[qid];
          if (typeof wVal === "number" && Number.isFinite(wVal) && wVal >= 0) {
            newServerWrong = wVal;
          }
        }
      }

      if (data && data.streak3 && typeof data.streak3 === "object" && data.streak3 !== null) {
        if (Object.prototype.hasOwnProperty.call(data.streak3, qid)) {
          var sVal = data.streak3[qid];
          if (typeof sVal === "number" && Number.isFinite(sVal) && sVal >= 0) {
            newServerStreak3 = sVal;
          }
        }
      }

      if (data && data.streakLen && typeof data.streakLen === "object" && data.streakLen !== null) {
        if (Object.prototype.hasOwnProperty.call(data.streakLen, qid)) {
          var slVal = data.streakLen[qid];
          if (typeof slVal === "number" && Number.isFinite(slVal) && slVal >= 0) {
            newServerStreakLen = slVal;
          }
        }
      }

      // ★ 不正解側: merge レスポンスの streak3Wrong / streakWrongLen も拾う
      if (data && data.streak3Wrong && typeof data.streak3Wrong === "object" && data.streak3Wrong !== null) {
        if (Object.prototype.hasOwnProperty.call(data.streak3Wrong, qid)) {
          var s3wVal = data.streak3Wrong[qid];
          if (typeof s3wVal === "number" && Number.isFinite(s3wVal) && s3wVal >= 0) {
            newServerStreak3Wrong = s3wVal;
          }
        }
      }

      if (data && data.streakWrongLen && typeof data.streakWrongLen === "object" && data.streakWrongLen !== null) {
        if (Object.prototype.hasOwnProperty.call(data.streakWrongLen, qid)) {
          var slwVal = data.streakWrongLen[qid];
          if (typeof slwVal === "number" && Number.isFinite(slwVal) && slwVal >= 0) {
            newServerWrongStreakLen = slwVal;
          }
        }
      }

      var newDiffCorrect = Math.max(0, localCorrect - newServerCorrect);
      var newDiffWrong = Math.max(0, localWrong - newServerWrong);
      var newDiffStreak3 = Math.max(0, localStreak3 - newServerStreak3);
      var newDiffStreakLen = Math.max(0, localStreakLen - newServerStreakLen);
      var newDiffStreak3Wrong = Math.max(0, localStreak3Wrong - newServerStreak3Wrong);
      var newDiffWrongStreakLen = Math.max(0, localWrongStreakLen - newServerWrongStreakLen);

      // ★ merge 成功後に /api/sync/state を再取得して、
      //    「保存されたか」「state に反映されたか」を diff ベースで確認する
      try {
        var stateAfter = await fetchState();
        try {
          window.__cscs_sync_state = stateAfter;
        } catch (_e2) {}

        var refreshedServerCorrect = newServerCorrect;
        var refreshedServerWrong = newServerWrong;
        var refreshedServerStreak3 = newServerStreak3;
        var refreshedServerStreakLen = newServerStreakLen;
        var refreshedServerStreak3Wrong = newServerStreak3Wrong;
        var refreshedServerWrongStreakLen = newServerWrongStreakLen;

        if (stateAfter && stateAfter.correct && stateAfter.correct[qid] != null) {
          refreshedServerCorrect = stateAfter.correct[qid];
        }
        if (stateAfter && stateAfter.incorrect && stateAfter.incorrect[qid] != null) {
          refreshedServerWrong = stateAfter.incorrect[qid];
        }
        if (stateAfter && stateAfter.streak3 && stateAfter.streak3[qid] != null) {
          refreshedServerStreak3 = stateAfter.streak3[qid];
        }
        if (stateAfter && stateAfter.streakLen && stateAfter.streakLen[qid] != null) {
          refreshedServerStreakLen = stateAfter.streakLen[qid];
        }
        // ★ 不正解側: stateAfter.streak3Wrong / streakWrongLen も確認
        if (stateAfter && stateAfter.streak3Wrong && stateAfter.streak3Wrong[qid] != null) {
          refreshedServerStreak3Wrong = stateAfter.streak3Wrong[qid];
        }
        if (stateAfter && stateAfter.streakWrongLen && stateAfter.streakWrongLen[qid] != null) {
          refreshedServerWrongStreakLen = stateAfter.streakWrongLen[qid];
        }

        var refreshedDiffCorrect = Math.max(0, localCorrect - refreshedServerCorrect);
        var refreshedDiffWrong = Math.max(0, localWrong - refreshedServerWrong);
        var refreshedDiffStreak3 = Math.max(0, localStreak3 - refreshedServerStreak3);
        var refreshedDiffStreakLen = Math.max(0, localStreakLen - refreshedServerStreakLen);
        var refreshedDiffStreak3Wrong = Math.max(0, localStreak3Wrong - refreshedServerStreak3Wrong);
        var refreshedDiffWrongStreakLen = Math.max(0, localWrongStreakLen - refreshedServerWrongStreakLen);

        // ★ console から不正解ストリークの同期状況を確認しやすくするログ
        console.log("[SYNC-B] wrong-streak after merge+state:", {
          qid: qid,
          refreshedServerStreak3Wrong: refreshedServerStreak3Wrong,
          localStreak3Wrong: localStreak3Wrong,
          refreshedDiffStreak3Wrong: refreshedDiffStreak3Wrong,
          refreshedServerWrongStreakLen: refreshedServerWrongStreakLen,
          localWrongStreakLen: localWrongStreakLen,
          refreshedDiffWrongStreakLen: refreshedDiffWrongStreakLen
        });

        var statusMsg = "merge ok / state synced (保存・反映完了)";
        if (
          refreshedDiffCorrect > 0 ||
          refreshedDiffWrong > 0 ||
          refreshedDiffStreak3 > 0 ||
          refreshedDiffStreakLen > 0 ||
          refreshedDiffStreak3Wrong > 0 ||
          refreshedDiffWrongStreakLen > 0
        ) {
          statusMsg = "merge ok / state に未反映の差分あり";
        }

        // oncePerDayToday の状態（before / after）を見て、
        // ・first time correct  → ON correct
        // ・first time wrong    → ON wrong
        // ・それ以外（すでに回答済み）→ ON nocount
        var oncePerDayStatus = "oncePerDayToday: 計測なし";
        var prevOnceVal = null;
        var newOnceVal = null;
        var localOnceDay = null;

        try {
          var localOnce = readOncePerDayTodayFromLocal();
          localOnceDay = localOnce && typeof localOnce.day === "number" ? localOnce.day : null;

          if (oncePerDayDelta) {
            var syncedOncePerDay = false;
            if (stateAfter && stateAfter.oncePerDayToday && typeof stateAfter.oncePerDayToday === "object") {
              var sOnceAfter = stateAfter.oncePerDayToday;
              if (typeof sOnceAfter.day === "number" && (!localOnceDay || sOnceAfter.day === localOnceDay)) {
                syncedOncePerDay = true;
                var sResultsAfter = sOnceAfter.results || {};
                if (sResultsAfter && typeof sResultsAfter === "object" && Object.prototype.hasOwnProperty.call(sResultsAfter, qid)) {
                  newOnceVal = sResultsAfter[qid];
                }
              }
            }
            if (syncedOncePerDay) {
              oncePerDayStatus = "oncePerDayToday: 計測済";
            } else {
              oncePerDayStatus = "oncePerDayToday: 計測エラー";
            }
          } else {
            oncePerDayStatus = "oncePerDayToday: 計測なし";
          }

          if (syncState && syncState.oncePerDayToday && typeof syncState.oncePerDayToday === "object") {
            var sOnceBefore = syncState.oncePerDayToday;
            if (typeof sOnceBefore.day === "number" && (!localOnceDay || sOnceBefore.day === localOnceDay)) {
              var sResultsBefore = sOnceBefore.results || {};
              if (sResultsBefore && typeof sResultsBefore === "object" && Object.prototype.hasOwnProperty.call(sResultsBefore, qid)) {
                prevOnceVal = sResultsBefore[qid];
              }
            }
          }
        } catch (_eOnce) {
          oncePerDayStatus = "oncePerDayToday: 計測エラー";
        }

        statusMsg += " / " + oncePerDayStatus;

        // ★ O.D.O.A Mode ステータス文字列を確定
        //   - O.D.O.A Mode : ON correct
        //   - O.D.O.A Mode : ON wrong
        //   - O.D.O.A Mode : ON nocount
        //   - O.D.O.A Mode : OFF
        var odoaStatusTextForPanelAfter = "O.D.O.A Mode : OFF";
        if (odoaModeText === "ON") {
          var suffix = "nocount";
          if (prevOnceVal == null && (newOnceVal === "correct" || newOnceVal === "wrong")) {
            suffix = newOnceVal;
          }
          odoaStatusTextForPanelAfter = "O.D.O.A Mode : ON " + suffix;
        }

        renderPanel(box, {
          serverCorrect: refreshedServerCorrect,
          serverWrong: refreshedServerWrong,
          localCorrect: localCorrect,
          localWrong: localWrong,
          diffCorrect: refreshedDiffCorrect,
          diffWrong: refreshedDiffWrong,
          serverStreak3: refreshedServerStreak3,
          localStreak3: localStreak3,
          diffStreak3: refreshedDiffStreak3,
          serverStreakLen: refreshedServerStreakLen,
          localStreakLen: localStreakLen,
          diffStreakLen: refreshedDiffStreakLen,
          statusText: statusMsg,
          odoaModeText: odoaModeText,
          odoaStatusText: odoaStatusTextForPanelAfter
        });
      } catch (e2) {
        console.error("[SYNC-B] state refresh error after merge:", e2);

        var stateErrorOncePerDayStatus = oncePerDayDelta ? "oncePerDayToday: 計測エラー" : "oncePerDayToday: 計測なし";
        var odoaStatusTextForPanelStateError;
        if (odoaModeText === "ON") {
          odoaStatusTextForPanelStateError = "O.D.O.A Mode : ON nocount";
        } else {
          odoaStatusTextForPanelStateError = "O.D.O.A Mode : OFF";
        }
        renderPanel(box, {
          serverCorrect: newServerCorrect,
          serverWrong: newServerWrong,
          localCorrect: localCorrect,
          localWrong: localWrong,
          diffCorrect: newDiffCorrect,
          diffWrong: newDiffWrong,
          serverStreak3: newServerStreak3,
          localStreak3: localStreak3,
          diffStreak3: newDiffStreak3,
          serverStreakLen: newServerStreakLen,
          localStreakLen: localStreakLen,
          diffStreakLen: newDiffStreakLen,
          statusText: "merge ok / state 再取得エラー(保存は成功している可能性) / " + stateErrorOncePerDayStatus,
          odoaModeText: odoaModeText,
          odoaStatusText: odoaStatusTextForPanelStateError
        });
      }
    } catch (e) {
      console.error("[SYNC-B] fetch failed:", e);
      var networkErrorOncePerDayStatus = oncePerDayDelta ? "oncePerDayToday: 計測エラー" : "oncePerDayToday: 計測なし";
      var odoaStatusTextForPanelNetworkError;
      if (odoaModeText === "ON") {
        odoaStatusTextForPanelNetworkError = "O.D.O.A Mode : ON nocount";
      } else {
        odoaStatusTextForPanelNetworkError = "O.D.O.A Mode : OFF";
      }
      renderPanel(box, {
        serverCorrect: serverCorrect,
        serverWrong: serverWrong,
        localCorrect: localCorrect,
        localWrong: localWrong,
        diffCorrect: diffCorrect,
        diffWrong: diffWrong,
        serverStreak3: serverStreak3,
        localStreak3: localStreak3,
        diffStreak3: diffStreak3,
        serverStreakLen: serverStreakLen,
        localStreakLen: localStreakLen,
        diffStreakLen: diffStreakLen,
        statusText: "network error (送信失敗) / " + networkErrorOncePerDayStatus,
        odoaModeText: odoaModeText,
        odoaStatusText: odoaStatusTextForPanelNetworkError
      });
    }
  }

  function refreshAndSend(box, options) {
    // ★ options.suppressDiffSend === true のときは、
    //    sendDiffToServer() を呼ばずに HUD の表示更新だけ行うモード
    options = options || {};
    var suppressDiffSend = !!options.suppressDiffSend;

    fetchState()
      .then(function (state) {
        // ★ /api/sync/state の結果をグローバルへ保存して、
        //    renderPanel から streak3Today を正しく取得できるようにする
        try {
          window.__cscs_sync_state = state;
        } catch (_e) {}

        var serverCorrect = 0;
        var serverWrong = 0;
        var serverStreak3 = 0;
        var serverStreakLen = 0;
        var serverStreak3Wrong = 0;
        var serverWrongStreakLen = 0;

        if (state && state.correct && state.correct[info.qid] != null) {
          serverCorrect = state.correct[info.qid];
        }
        if (state && state.incorrect && state.incorrect[info.qid] != null) {
          serverWrong = state.incorrect[info.qid];
        }
        if (state && state.streak3 && state.streak3[info.qid] != null) {
          serverStreak3 = state.streak3[info.qid];
        }
        if (state && state.streakLen && state.streakLen[info.qid] != null) {
          serverStreakLen = state.streakLen[info.qid];
        }
        // ★ 不正解側: サーバーの 3連続不正解回数と現在の連続不正解長を取得
        if (state && state.streak3Wrong && state.streak3Wrong[info.qid] != null) {
          serverStreak3Wrong = state.streak3Wrong[info.qid];
        }
        if (state && state.streakWrongLen && state.streakWrongLen[info.qid] != null) {
          serverWrongStreakLen = state.streakWrongLen[info.qid];
        }

        var localCorrect = readIntFromLocalStorage("cscs_q_correct_total:" + info.qid);
        var localWrong = readIntFromLocalStorage("cscs_q_wrong_total:" + info.qid);
        var localStreak3 = readIntFromLocalStorage("cscs_q_correct_streak3_total:" + info.qid);
        var localStreakLen = readIntFromLocalStorage("cscs_q_correct_streak_len:" + info.qid);
        // ★ 不正解側: localStorage の 3連続不正解回数と現在の連続不正解長を取得
        var localStreak3Wrong = readIntFromLocalStorage("cscs_q_wrong_streak3_total:" + info.qid);
        var localWrongStreakLen = readIntFromLocalStorage("cscs_q_wrong_streak_len:" + info.qid);

        var diffCorrect = Math.max(0, localCorrect - serverCorrect);
        var diffWrong = Math.max(0, localWrong - serverWrong);
        var diffStreak3 = Math.max(0, localStreak3 - serverStreak3);
        var diffStreakLen = Math.max(0, localStreakLen - serverStreakLen);
        // ★ 不正解側: SYNC と local の差分（0 以上の増分）を計算
        var diffStreak3Wrong = Math.max(0, localStreak3Wrong - serverStreak3Wrong);
        var diffWrongStreakLen = Math.max(0, localWrongStreakLen - serverWrongStreakLen);

        // ★ コンソールで不正解ストリーク同期対象を確認できるようにログ出力
        console.log("[SYNC-B] wrong-streak diff (local vs server):", {
          qid: info.qid,
          serverStreak3Wrong: serverStreak3Wrong,
          localStreak3Wrong: localStreak3Wrong,
          diffStreak3Wrong: diffStreak3Wrong,
          serverWrongStreakLen: serverWrongStreakLen,
          localWrongStreakLen: localWrongStreakLen,
          diffWrongStreakLen: diffWrongStreakLen
        });

        // ★ 何をしているか:
        //   ODOAモードは唯一の参照元 window.CSCS_ODOA_MODE（"on"/"off"）のみを見る
        var odoaModeRaw = null;
        try {
          if (typeof window.CSCS_ODOA_MODE === "string") {
            odoaModeRaw = window.CSCS_ODOA_MODE;
          }
        } catch (_eOdoaModeRaw) {
          odoaModeRaw = null;
        }

        // ★ 何をしているか:
        //   HUDで使う表記を "ON"/"OFF" に正規化（他ソースへはフォールバックしない）
        var odoaModeText = "OFF";
        try {
          var t = (odoaModeRaw == null ? "" : String(odoaModeRaw)).trim().toLowerCase();
          if (t === "on") {
            odoaModeText = "ON";
          } else if (t === "off") {
            odoaModeText = "OFF";
          }
        } catch (_eOdoaModeText) {
          odoaModeText = "OFF";
        }

        console.log("[SYNC-B] detected O.D.O.A from window.CSCS_ODOA_MODE:", {
          odoaModeRaw: odoaModeRaw,
          odoaModeText: odoaModeText
        });

        var statusTextForRender = suppressDiffSend ? "__keep__" : "state ok";

        // ★ 自動検証モード（CSCS_VERIFY_MODE=on）のときは、
        //   b_judge_record.js と同じく「計測ガード中」であることが分かるように
        //   statusText に明示しておく（diff の送信自体は後段でブロックする）
        var verifyModeOn =
          typeof window.CSCS_VERIFY_MODE === "string" && window.CSCS_VERIFY_MODE === "on";
        if (!suppressDiffSend && verifyModeOn) {
          statusTextForRender = "state ok / verify-mode: 計測ガード中(diff送信なし)";
        }

        // 初期表示や diff 送信前の HUD:
        //   - suppressDiffSend===true のときは "__keep__" を渡し、既存表示を維持
        //   - 通常モードでは「ON nocount」/「OFF」で初期表示を行う
        var odoaStatusTextForPanelInit;
        if (suppressDiffSend) {
          odoaStatusTextForPanelInit = "__keep__";
          console.log("[SYNC-B] ODOA HUD: suppressDiffSend=true → '__keep__' で再描画要求");
        } else {
          if (odoaModeText === "ON") {
            odoaStatusTextForPanelInit = "O.D.O.A Mode : ON nocount";
          } else {
            odoaStatusTextForPanelInit = "O.D.O.A Mode : OFF";
          }
          console.log("[SYNC-B] ODOA HUD: initial status set from mode:", odoaStatusTextForPanelInit);
        }

        var pending = computePendingFlags(state, info.qid);
        pending.pendingDiffCounts = (diffCorrect > 0 || diffWrong > 0 || diffStreak3 > 0 || diffStreakLen > 0 || diffStreak3Wrong > 0 || diffWrongStreakLen > 0);

        renderPanel(box, {
          serverCorrect: serverCorrect,
          serverWrong: serverWrong,
          localCorrect: localCorrect,
          localWrong: localWrong,
          diffCorrect: diffCorrect,
          diffWrong: diffWrong,
          serverStreak3: serverStreak3,
          localStreak3: localStreak3,
          diffStreak3: diffStreak3,
          serverStreakLen: serverStreakLen,
          localStreakLen: localStreakLen,
          diffStreakLen: diffStreakLen,
          statusText: statusTextForRender,
          odoaModeText: odoaModeText,
          odoaStatusText: odoaStatusTextForPanelInit,
          pending: pending
        });

        // ★ 何をしているか:
        //   renderPanel() により OncePerDayToday / O.D.O.A Mode（SYNC）カードがDOMに生成された「直後」に、
        //   見出しの "(SYNC)" 付与と、直下への "(local)" カードの追加を確実に実行する
        ensureOnceOdoaWideTitles(box);
        ensureLocalOnceOdoaWideCard(box);

        // ★ 何をしているか:
        //   localStorage 由来の OncePerDayToday / O.D.O.A Mode を「local専用カード」に反映する
        //   （SYNCカードとは独立した表示。diff送信の有無に関係なく、毎回更新する）
        refreshLocalOnceOdoaCard(box, {
          qid: info.qid,
          odoaModeText: odoaModeText
        });

        // ★ suppressDiffSend===true の場合は diff の POST を完全に止め、
        //    HUD 表示のみ更新した状態で終了する（手動 streak3Today テスト用）
        if (suppressDiffSend) {
          console.log("[SYNC-B] refreshAndSend: suppressDiffSend=true → diff POST を実行せず HUD 表示のみ更新", {
            qid: info.qid,
            serverCorrect: serverCorrect,
            serverWrong: serverWrong,
            localCorrect: localCorrect,
            localWrong: localWrong,
            diffCorrect: diffCorrect,
            diffWrong: diffWrong,
            diffStreak3: diffStreak3,
            diffStreakLen: diffStreakLen,
            odoaModeText: odoaModeText
          });
          return;
        }

        // ★ 自動検証モード中（CSCS_VERIFY_MODE=on）は、
        //    b_judge_record.js と同様「計測ガード」として diff POST を完全にブロックする。
        //    これにより、verify モードで流した A→B 自動遷移では
        //    localStorage 側の計測を行わないだけでなく、
        //    SYNC 側の累計・streak3・oncePerDayToday も一切更新されない。
        if (verifyModeOn) {
          console.log("[SYNC-B] refreshAndSend: verify-mode ON → diff POST を実行せず HUD 表示のみ更新（計測ガード）", {
            qid: info.qid,
            serverCorrect: serverCorrect,
            serverWrong: serverWrong,
            localCorrect: localCorrect,
            localWrong: localWrong,
            diffCorrect: diffCorrect,
            diffWrong: diffWrong,
            diffStreak3: diffStreak3,
            diffStreakLen: diffStreakLen,
            odoaModeText: odoaModeText
          });
          return;
        }

        return sendDiffToServer(box, {
          serverCorrect: serverCorrect,
          serverWrong: serverWrong,
          serverStreak3: serverStreak3,
          serverStreakLen: serverStreakLen,
          serverStreak3Wrong: serverStreak3Wrong,
          serverWrongStreakLen: serverWrongStreakLen,
          localCorrect: localCorrect,
          localWrong: localWrong,
          localStreak3: localStreak3,
          localStreakLen: localStreakLen,
          localStreak3Wrong: localStreak3Wrong,
          localWrongStreakLen: localWrongStreakLen,
          diffCorrect: diffCorrect,
          diffWrong: diffWrong,
          diffStreak3: diffStreak3,
          diffStreakLen: diffStreakLen,
          diffStreak3Wrong: diffStreak3Wrong,
          diffWrongStreakLen: diffWrongStreakLen,
          // ★ oncePerDayTodayDelta を作るために /api/sync/state の snapshot を渡す
          syncState: state,
          // ★ O.D.O.A Mode 表示用テキストも sendDiffToServer に引き継ぎ
          odoaModeText: odoaModeText
        });
      })
      .catch(function (e) {
        console.error("[SYNC-B] state fetch error:", e);
        var localCorrect = readIntFromLocalStorage("cscs_q_correct_total:" + info.qid);
        var localWrong = readIntFromLocalStorage("cscs_q_wrong_total:" + info.qid);
        var localStreak3 = readIntFromLocalStorage("cscs_q_correct_streak3_total:" + info.qid);
        var localStreakLen = readIntFromLocalStorage("cscs_q_correct_streak_len:" + info.qid);

        var odoaModeText = "不明(state error)";
        var odoaStatusTextForPanelStateError;
        odoaStatusTextForPanelStateError = "O.D.O.A Mode : OFF";

        renderPanel(box, {
          serverCorrect: 0,
          serverWrong: 0,
          localCorrect: localCorrect,
          localWrong: localWrong,
          diffCorrect: 0,
          diffWrong: 0,
          serverStreak3: 0,
          localStreak3: localStreak3,
          diffStreak3: 0,
          serverStreakLen: 0,
          localStreakLen: localStreakLen,
          diffStreakLen: 0,
          statusText: "state error",
          odoaModeText: odoaModeText,
          odoaStatusText: odoaStatusTextForPanelStateError
        });

        // ★ 何をしているか:
        //   state取得失敗でも OncePerDayToday / O.D.O.A Mode カード自体は renderPanel() で生成されるため、
        //   見出し "(SYNC)" と "(local)" カード追加はここでも確実に実行する
        ensureOnceOdoaWideTitles(box);
        ensureLocalOnceOdoaWideCard(box);

      });
  }

  function ensureOnceOdoaWideTitles(box) {
    // ★ 何をしているか:
    //   OncePerDayToday / O.D.O.A Mode のカードが複数存在する場合でも、
    //   「(SYNC)/(local) は“元の場所（現在3枚目が出ている場所）”」に集約し、
    //   余分に出ている“元カード（現在3枚目）”は非表示にする。
    //   - 表示位置の基準: svb-once-odoa-card（local以外）のうち「最後の1枚」を“元の場所”とみなす
    //   - 先頭に出てしまった(SYNC)カードは、その“元の場所”の直前へ移動する
    //   - localカード（svb-once-odoa-card-local）がある場合は(SYNC)の直後へ移動する
    //   - “元の場所”として使っていた最後のカード（=元カード）は display:none で非表示にする
    try {
      if (!box) return;

      var body = document.getElementById("cscs_sync_view_b_body");
      if (!body) return;

      var all = body.querySelectorAll(".svb-once-odoa-card");
      if (!all || all.length === 0) return;

      // ★ 何をしているか:
      //   localカードは別扱い（ベースクラスに svb-once-odoa-card を含むため除外する）
      var syncCards = [];
      for (var i = 0; i < all.length; i++) {
        var c = all[i];
        if (c && c.className && String(c.className).indexOf("svb-once-odoa-card-local") >= 0) {
          continue;
        }
        syncCards.push(c);
      }
      if (syncCards.length === 0) return;

      // ★ 何をしているか:
      //   “元の場所”扱いにするカード（= local以外の once/odoa の最後の1枚）
      var anchorCard = syncCards[syncCards.length - 1];

      // ★ 何をしているか:
      //   先頭に出てしまっている(SYNC)カード（= local以外の once/odoa の最初の1枚）
      var syncCard = syncCards[0];

      // ★ 何をしているか:
      //   見出しは常に "(SYNC)" に正規化する（表記ゆれ吸収）
      var title = syncCard ? syncCard.querySelector(".cscs-svb-card-title") : null;
      if (title) {
        var base = "OncePerDayToday / O.D.O.A Mode";
        var desired = "OncePerDayToday / O.D.O.A Mode (SYNC)";
        if (title.textContent && title.textContent.indexOf(base) >= 0) {
          if (title.textContent !== desired) {
            title.textContent = desired;
          }
        }
      }

      // ★ 何をしているか:
      //   (SYNC)カードを“元の場所（anchorCard）”の直前へ移動し、
      //   localカードがある場合は(SYNC)の直後へ移動する。
      if (syncCard && anchorCard && syncCard !== anchorCard) {
        body.insertBefore(syncCard, anchorCard);

        var localCard = body.querySelector(".svb-once-odoa-card-local");
        if (localCard) {
          if (syncCard.nextSibling) {
            body.insertBefore(localCard, syncCard.nextSibling);
          } else {
            body.appendChild(localCard);
          }
        }

        // ★ 何をしているか:
        //   “元の場所”として利用していた（現在3枚目として出てしまっている）カードは非表示にして、
        //   二重表示を完全に止める。
        try {
          anchorCard.style.display = "none";
        } catch (_eHide) {}
      }
    } catch (_e) {}
  }

  function ensureLocalOnceOdoaWideCard(box) {
    // ★ 何をしているか:
    //   SYNCカードの直下に、localStorage由来の値だけを表示する「local専用ワイドカード」を1枚作る（重複作成しない）
    try {
      if (!box) return;

      var body = document.getElementById("cscs_sync_view_b_body");
      if (!body) return;

      // ★ 何をしているか:
      //   localカードの差し込み先は「現在の(SYNC)カード直後」に固定する。
      //   ただし、once/odoa が複数ある場合に先頭を拾うと“ステータス最上段”に刺さってしまうため、
      //   local以外の once/odoa のうち「最初の1枚（= (SYNC)扱い）」を基準にする。
      var allCards = body.querySelectorAll(".svb-once-odoa-card");
      if (!allCards || allCards.length === 0) return;

      var syncCard = null;
      for (var i = 0; i < allCards.length; i++) {
        var c = allCards[i];
        if (c && c.className && String(c.className).indexOf("svb-once-odoa-card-local") >= 0) {
          continue;
        }
        syncCard = c;
        break;
      }
      if (!syncCard) return;

      // すでに local 用が存在するなら何もしない
      if (body.querySelector(".svb-once-odoa-card-local")) return;

      var card = document.createElement("div");

      // ★ 何をしているか:
      //   既存の (SYNC) OncePerDayToday / O.D.O.A Mode カードと「完全に同じ className」をコピーして、
      //   local カードにも “同じスタイル（中身含む）” を確実に適用する。
      //   そのうえで、検索・更新のための識別子として svb-once-odoa-card-local を必ず付与する（重複付与はしない）。
      var baseClass = (syncCard && typeof syncCard.className === "string") ? syncCard.className : "cscs-svb-card is-wide svb-once-odoa-card";
      if (baseClass.indexOf("svb-once-odoa-card-local") < 0) {
        baseClass = baseClass + " svb-once-odoa-card-local";
      }
      card.className = baseClass;

      // ★ 何をしているか:
      //   localカードの「中身DOM」を (SYNC)カードと同じ構造・同じクラス名に寄せる。
      //   これにより、OncePerDayToday / O.D.O.A Mode 用の既存CSSが local 側にも完全に効く。
      var head = document.createElement("div");
      head.className = "svb-once-odoa-head";

      var title = document.createElement("div");
      title.className = "cscs-svb-card-title";
      title.textContent = "OncePerDayToday / O.D.O.A Mode (local)";

      var btn = document.createElement("button");
      btn.className = "svb-once-odoa-toggle";
      btn.type = "button";
      btn.setAttribute("aria-expanded", "true");

      var chev = document.createElement("span");
      chev.className = "svb-once-odoa-chev";
      chev.textContent = "▼";

      var btnText = document.createTextNode("hide");
      btn.appendChild(chev);
      btn.appendChild(btnText);

      // ★ 何をしているか:
      //   (SYNC)と同じ「内容コンテナ」を作る（2列×3行 + 単行ODOA）
      var details = document.createElement("div");
      details.className = "svb-wide-dual-grid";

      var collapsedKey = "cscs_sync_view_b_once_odoa_local_collapsed";
      var isCollapsed = false;
      try {
        isCollapsed = (localStorage.getItem(collapsedKey) === "1");
      } catch (_e0) {
        isCollapsed = false;
      }

      function applyCollapsed() {
        // ★ 何をしているか:
        //   (SYNC)と同じ「▼/▶︎ + hide/show + aria-expanded」を再現する
        if (isCollapsed) {
          details.style.display = "none";
          btn.setAttribute("aria-expanded", "false");
          chev.textContent = "▶︎";
          while (btn.childNodes.length > 1) btn.removeChild(btn.lastChild);
          btn.appendChild(document.createTextNode("show"));
        } else {
          details.style.display = "";
          btn.setAttribute("aria-expanded", "true");
          chev.textContent = "▼";
          while (btn.childNodes.length > 1) btn.removeChild(btn.lastChild);
          btn.appendChild(document.createTextNode("hide"));
        }
      }

      btn.addEventListener("click", function (ev) {
        ev.preventDefault();
        ev.stopPropagation();

        isCollapsed = !isCollapsed;
        try {
          localStorage.setItem(collapsedKey, isCollapsed ? "1" : "0");
        } catch (_e1) {}
        applyCollapsed();
      });

      // ★ 何をしているか:
      //   (SYNC)と同じセルクラスで「表示行」を作る（後で refreshLocalOnceOdoaCard() がこの行テキストを上書きする）
      function makeCell(text, className) {
        var d = document.createElement("div");
        d.className = className;
        d.textContent = text;
        return d;
      }

      // 2列×3行（SYNC同型）
      details.appendChild(makeCell("oncePerDayToday   -", "svb-wide-dual-cell svb-wide-dual-strong"));
      details.appendChild(makeCell("計測: - ｜結果: -", "svb-wide-dual-cell is-right"));

      details.appendChild(makeCell("Today             -", "svb-wide-dual-cell"));
      details.appendChild(makeCell("qid: -", "svb-wide-dual-cell is-right"));

      details.appendChild(makeCell("count対象         -", "svb-wide-dual-cell"));
      details.appendChild(makeCell("記録: -", "svb-wide-dual-cell is-right"));

      // ODOA（単行SYNC同型）
      var odoaLine = makeCell("ODOA              -", "svb-wide-single");
      details.appendChild(odoaLine);

      head.appendChild(title);
      head.appendChild(btn);

      card.appendChild(head);

      // ★ 何をしているか:
      //   (SYNC)は head の下に grid 本体が直で来ているため、local も同じ並びにする
      card.appendChild(details);

      // SYNCカードの直後に挿入
      if (syncCard.nextSibling) {
        body.insertBefore(card, syncCard.nextSibling);
      } else {
        body.appendChild(card);
      }

      applyCollapsed();
    } catch (_e) {}
  }

  function refreshLocalOnceOdoaCard(box, params) {
    // ★ 何をしているか:
    //   local専用カードの行テキストを、localStorage由来の値だけで更新する
    try {
      if (!box) return;

      var body = document.getElementById("cscs_sync_view_b_body");
      if (!body) return;

      var card = body.querySelector(".svb-once-odoa-card-local");
      if (!card) return;

      var qid = (params && typeof params.qid === "string") ? params.qid : "";
      var odoaModeText = (params && typeof params.odoaModeText === "string") ? params.odoaModeText : "OFF";

      // local oncePerDayToday を読む（既存ヘルパーがあればそれを優先）
      var localOnceDay = null;
      var localOnceVal = null;

      try {
        if (typeof readOncePerDayTodayFromLocal === "function") {
          var localOnce = readOncePerDayTodayFromLocal();
          if (localOnce && typeof localOnce.day === "number") {
            localOnceDay = localOnce.day;
          }
          if (localOnce && localOnce.results && typeof localOnce.results === "object" && qid) {
            if (Object.prototype.hasOwnProperty.call(localOnce.results, qid)) {
              localOnceVal = localOnce.results[qid];
            }
          }
        }
      } catch (_eOnce) {
        localOnceDay = null;
        localOnceVal = null;
      }

      function fmtDay8ToDateText(dayNum) {
        if (typeof dayNum !== "number" || !Number.isFinite(dayNum) || dayNum <= 0) return "-";
        var s = String(dayNum);
        if (s.length !== 8) return s;
        return s.slice(0, 4) + "-" + s.slice(4, 6) + "-" + s.slice(6, 8);
      }

      var onceStateLabel = (localOnceVal === "correct" || localOnceVal === "wrong") ? "計測済" : "未開始";
      var onceTodayDateLabel = (localOnceDay != null) ? fmtDay8ToDateText(localOnceDay) : "-";
      var onceQidLabel = qid || "-";
      var onceCountableLabel = (localOnceVal === "correct" || localOnceVal === "wrong") ? "No（計測済）" : "Yes（未計測）";

      var onceRecordLabel = (localOnceVal === "correct" || localOnceVal === "wrong") ? String(localOnceVal) : "-";

      var verifyModeOn = false;
      try {
        verifyModeOn = (typeof window.CSCS_VERIFY_MODE === "string" && window.CSCS_VERIFY_MODE.toLowerCase() === "on");
      } catch (_eVerify) {
        verifyModeOn = false;
      }

      var odoaIsOn = false;
      try {
        odoaIsOn = (typeof odoaModeText === "string" && odoaModeText.trim().toUpperCase() === "ON");
      } catch (_eOdoaOn) {
        odoaIsOn = false;
      }

      var odoaResultSuffix = "nocount";
      if (onceRecordLabel === "correct") {
        odoaResultSuffix = "Correct";
      } else if (onceRecordLabel === "wrong") {
        odoaResultSuffix = "Wrong";
      }

      var addNo = false;
      if (verifyModeOn) addNo = true;
      if (odoaIsOn) addNo = true;

      var onceOdoaLabel = "-";
      if (odoaIsOn) {
        onceOdoaLabel = "ON（累計加算: " + (addNo ? "No" : "Yes") + "）  " + odoaResultSuffix;
      } else {
        onceOdoaLabel = "OFF（累計加算: Yes）  " + odoaResultSuffix;
      }
      var onceRecordLabel = (localOnceVal === "correct" || localOnceVal === "wrong") ? String(localOnceVal) : "-";

      var onceOdoaLabel = "-";
      if (odoaModeText === "ON") {
        if (onceRecordLabel !== "-") {
          onceOdoaLabel = "ON（累計加算: No）  " + onceRecordLabel;
        } else {
          onceOdoaLabel = "ON（累計加算: No）";
        }
      } else if (odoaModeText === "OFF") {
        onceOdoaLabel = "OFF（累計加算: Yes）";
      } else {
        onceOdoaLabel = String(odoaModeText);
      }

      // ★ 何をしているか:
      //   local専用カードの「SYNC同型DOM（svb-wide-dual-grid）」を前提に、
      //   行単位（左セル/右セル + 最下段 single）でテキストを上書き更新する
      var grid = card.querySelector(".svb-wide-dual-grid");
      if (!grid) return;

      var dualCells = grid.querySelectorAll(".svb-wide-dual-cell");
      var singleCell = grid.querySelector(".svb-wide-single");

      // ★ 何をしているか:
      //   必要なセル数（dual: 6セル = 3行×2列、single: 1セル）を満たさない場合は更新しない
      if (!dualCells || dualCells.length < 6) return;
      if (!singleCell) return;

      // ★ 何をしているか:
      //   SYNCカードと同じ表示並びで、local由来の内容を行単位で反映する
      //   0: oncePerDayToday（左） / 1: 計測＋結果（右）
      var rec = (localOnceVal === "correct" || localOnceVal === "wrong") ? String(localOnceVal) : "-";
      var okng = (rec !== "-") ? "OK" : "NG";
      var odoaSuffix = "nocount";
      if (localOnceVal === "correct") {
        odoaSuffix = "Correct";
      } else if (localOnceVal === "wrong") {
        odoaSuffix = "Wrong";
      }

      var odoaLine = "";
      if (String(odoaModeText).toUpperCase() === "ON") {
        odoaLine = "ON（累計加算: No）  -";
      } else {
        odoaLine = "OFF（累計加算: Yes）  " + odoaSuffix;
      }

      dualCells[0].textContent = "oncePerDayToday   " + onceStateLabel;
      dualCells[1].textContent = "計測: " + okng + " ｜結果: " + rec;

      //   2: Today（左） / 3: qid（右）
      dualCells[2].textContent = "Today             " + onceTodayDateLabel;
      dualCells[3].textContent = "qid: " + onceQidLabel;

      //   4: count対象（左） / 5: 記録（右）
      dualCells[4].textContent = "count対象         " + onceCountableLabel;

      var recordForDisplay = rec;
      if (String(onceCountableLabel).indexOf("No") === 0) {
        recordForDisplay = "-";
      }
      dualCells[5].textContent = "記録: " + recordForDisplay;

      // ★ 何をしているか:
      //   最下段の single 行（ODOA）を更新する
      singleCell.textContent = "ODOA              " + odoaLine;

    } catch (_e) {}
  }


```
<<<PART_END>>>
【RECEIPT_INPUT（このメッセージ内だけを真とする）】
EXPECTED_TOTAL: 5
RECEIVED_TOTAL: 4

CUMULATIVE_RECEIVED_PARTIDS:
- CSCSJS-C905F0E5-P01-of-05
- CSCSJS-C905F0E5-P02-of-05
- CSCSJS-C905F0E5-P03-of-05
- CSCSJS-C905F0E5-P04-of-05

【ChatGPTへの強制ルール】
・受領確認は、このメッセージ内の CUMULATIVE_RECEIVED_PARTIDS と EXPECTED_PARTIDS のみを使用すること。
・会話履歴から PartID を再収集しないこと（禁止）。
・受領確認OK前に、コード内容の解釈・要約・推測・修正案提示をしないこと（禁止）。

RECEIPT_REQUIRED_RESPONSE_TEMPLATE:
ACK: <PartID> <PartSHA256_8> / WAITING_NEXT

【分割コード(4)の終了】→ 次は 分割コード(5) を送ります
【ChatGPTへの指示】解釈・要約・推測・修正案提示は禁止。返答は次のみ。
ACK: <PartID> / WAITING_NEXT
