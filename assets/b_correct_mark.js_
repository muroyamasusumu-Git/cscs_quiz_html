// assets/b_correct_mark.js

(function(){

  // ▼ 1. cscs-meta から正解を取得
  //   <script id="cscs-meta">{"Correct":"A", ...}</script> のような JSON を想定
  function getCorrectFromMeta(){
    try{
      var el = document.getElementById("cscs-meta");
      if (!el) return "";
      // textContent を JSON としてパース
      var meta = JSON.parse(el.textContent || "{}");
      // Correct または correct フィールドから正解を取得
      var c = meta.Correct || meta.correct;
      if (typeof c === "string") return c.trim().toUpperCase();
      return "";
    }catch(_){
      // パースに失敗したら空文字（＝取得失敗）
      return "";
    }
  }

  // ▼ 2. #judge の文章から正解を抽出
  //   例: 「正解: A」「正解：B」「正しいのは C」などをマッチング
  function getCorrectFromJudge(){
    try{
      var j = document.getElementById("judge");
      if (!j) return "";
      var t = (j.textContent || j.innerText || "").trim();
      // [正せ][解い] で「正解 / 正しい」などをざっくりマッチ
      // その後ろに : or ： があって A〜D のいずれかを拾う
      var m = t.match(/[正せ][解い]\s*[:：]?\s*([ABCD])/i);
      return (m && m[1]) ? m[1].toUpperCase() : "";
    }catch(_){
      return "";
    }
  }

  // ▼ 3. .answer の文章から正解を抽出
  //   例: <div class="answer">正解: A<span ...>本文...</span></div>
  function getCorrectFromAnswer(){
    try{
      var a = document.querySelector(".answer");
      if (!a) return "";
      var t = (a.textContent || "").trim();
      var m = t.match(/[正せ][解い]\s*[:：]?\s*([ABCD])/i);
      return (m && m[1]) ? m[1].toUpperCase() : "";
    }catch(_){
      return "";
    }
  }

  // ▼ 4. 実際に選択肢リストに「正解マーク」を付ける処理
  //   corr: "A"〜"D" を想定
  function markOnce(corr){
    // A〜D 以外なら何もしない
    if (!/^[ABCD]$/.test(corr)) return false;

    // Bパート以外では何もしない（責務を限定）
    try{
      if (!document.body || !document.body.classList || !document.body.classList.contains("mode-b")) {
        return false;
      }
    }catch(_){
      return false;
    }

    // 選択肢リストの <ol class="opts"> を取得（フェード用クローン配下は除外）
    var ol = null;
    try{
      var all = document.querySelectorAll("ol.opts");
      for (var i = 0; i < all.length; i++) {
        var cand = all[i];
        if (!cand) continue;

        // #cscs-fade-highlight-layer 配下は「フェード用クローン」なので対象外
        try{
          if (cand.closest && cand.closest("#cscs-fade-highlight-layer")) {
            continue;
          }
        }catch(_){}

        ol = cand;
        break;
      }
    }catch(_){
      ol = null;
    }
    if (!ol) return false;

    // A〜D → li の順番へのマッピング
    var map = { A: 1, B: 2, C: 3, D: 4 };

    // nth-child で該当の li を取得
    var li = ol.querySelector("li:nth-child(" + map[corr] + ")");
    if (!li) return false;

    // li 自体に is-correct を付与（従来どおり）
    try{
      li.classList.add("is-correct");
    }catch(_){}

    // ▼ 下線は marker を巻き込まないよう「中身」だけに当てる
    // 1) B結果演出でラップされる .sa-correct-pulse-inner を優先
    // 2) 無ければ a.opt-link
    // 3) それも無ければ li 内の a
    var textEl = null;

    try{
      textEl = li.querySelector(".sa-correct-pulse-inner");
    }catch(_){
      textEl = null;
    }

    if (!textEl) {
      try{
        textEl = li.querySelector("a.opt-link");
      }catch(_){
        textEl = null;
      }
    }

    if (!textEl) {
      try{
        textEl = li.querySelector("a");
      }catch(_){
        textEl = null;
      }
    }

    // 下線（underline）の付与は廃止：
    // - 正解行のマーキングは is-correct クラス付与のみで行う
    // - 文言側（a / .sa-correct-pulse-inner）への装飾は一切しない

    // さらに中の <a class="opt-link"> があれば、それにもクラスを追加（従来どおり）
    var a = li.querySelector("a.opt-link");
    if (a) {
      try{
        a.classList.add("is-correct");
      }catch(_){}
    }

    return true;
  }

  // ▼ 5. Bパートの正解マーク付けロジックのみを保持（スライドイン演出は cscs_slide_in.js に集約）
  // このファイルではアニメーション用のスタイル定義やクラス付与は行わない。

  // ▼ 6. 正解取得 → マーク付けを一通り試みる関数
  function tryMark(){
    // まずは meta から
    var corr = getCorrectFromMeta();
    // ダメなら judge から
    if (!corr) corr = getCorrectFromJudge();
    // それでもダメなら .answer から
    if (!corr) corr = getCorrectFromAnswer();  // .answer からも拾う

    // 見つかった正解で markOnce を実行（アニメーションは cscs_slide_in.js に任せる）
    return markOnce(corr);
  }

  // ▼ 7. DOM 準備状態に応じて初回実行タイミングを調整
  if (document.readyState === "loading") {
    // 読み込み途中の場合は DOMContentLoaded と load で tryMark を呼ぶ
    document.addEventListener("DOMContentLoaded", tryMark);
    window.addEventListener("load", tryMark);
  } else {
    // すでに DOM 構築済みならすぐ実行し、さらに load 後にも再度実行
    tryMark();
    window.addEventListener("load", tryMark);
  }

  // ▼ 8. setTimeout で何度か後追い実行
  //    非同期で judge や answer が描画されるケースに備えて、
  //    わずかな遅延で何回か tryMark を再実行している
  setTimeout(tryMark, 0);
  setTimeout(tryMark, 50);
  setTimeout(tryMark, 200);

  // ▼ 9. #judge の中身が後から書き換わるケースに備えた監視
  var judge = document.getElementById("judge");
  if (judge && window.MutationObserver) {
    var obs = new MutationObserver(tryMark);
    // 子ノードの追加・削除・テキストの変更すべてで tryMark を呼び直す
    obs.observe(judge, { childList: true, subtree: true, characterData: true });
  }

  // ▼ 10. .answer の中身が後から書き換わるケースに備えた監視
  var ans = document.querySelector(".answer");
  if (ans && window.MutationObserver) {
    var obs2 = new MutationObserver(tryMark);
    obs2.observe(ans, { childList: true, subtree: true, characterData: true });
  }

  // ▼ 11. ol.opts の中身が後から差し替わるケースに備えた監視（B結果演出で span が作り直される対策）
  // - 監視対象は body.mode-b 配下の「フェード用クローンではない」 ol.opts のみ
  // - childList 変化のみを監視（attributes を監視すると自分の class/style 変更で自己ループしやすい）
  // - 連続変化は requestAnimationFrame で 1フレームに1回へまとめる
  (function setupOptsObserver(){
    try{
      if (!window.MutationObserver) return;

      // Bパート以外では監視しない（責務を限定）
      try{
        if (!document.body || !document.body.classList || !document.body.classList.contains("mode-b")) {
          return;
        }
      }catch(_){
        return;
      }

      var optsRoot = null;
      try{
        var all = document.querySelectorAll("ol.opts");
        for (var i = 0; i < all.length; i++) {
          var cand = all[i];
          if (!cand) continue;

          // #cscs-fade-highlight-layer 配下は「フェード用クローン」なので対象外
          try{
            if (cand.closest && cand.closest("#cscs-fade-highlight-layer")) {
              continue;
            }
          }catch(_){}

          optsRoot = cand;
          break;
        }
      }catch(_){
        optsRoot = null;
      }
      if (!optsRoot) return;

      var scheduled = false;

      function scheduleTryMark(){
        if (scheduled) return;
        scheduled = true;
        requestAnimationFrame(function(){
          scheduled = false;
          tryMark();
        });
      }

      var obs3 = new MutationObserver(function(mutations){
        for (var i = 0; i < mutations.length; i++) {
          var m = mutations[i];
          if (!m) continue;
          if (m.type === "childList") {
            scheduleTryMark();
            return;
          }
        }
      });

      obs3.observe(optsRoot, { childList: true, subtree: true });
    }catch(_){
    }
  })();

})();