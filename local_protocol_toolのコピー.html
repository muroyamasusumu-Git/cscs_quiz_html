<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Protocol Splitter Local Tool</title>
  <style>
    :root{
      --bg: #0b0d10;
      --panel: #11151b;
      --panel2: #0f1217;
      --border: #242b36;
      --text: #e7eaf0;
      --muted: #9aa4b2;
      --codebg: #0a0c10;

      /* 見出しの水色（.sectionTitle と合わせる） */
      --accent: rgba(125, 211, 252, 0.95);
      /* ホバー等で少し弱めに使う水色 */
      --accentSoft: rgba(125, 211, 252, 0.70);

      --focus: #3b82f6;
      --ok: #22c55e;
      --danger: #ef4444;
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans JP";
      font-size: 15px; /* 全体の基準文字サイズを少し上げて読みやすくする */
      line-height: 1.65; /* 行間を広げて可読性を上げる */
      letter-spacing: 0.01em; /* わずかに字間を広げて読みやすくする */
      margin: 16px 20px;
      background: radial-gradient(1200px 600px at 30% -10%, #111827 0%, var(--bg) 55%);
      color: var(--text);
    }

    h2 {
      margin: 6px 0 10px;
      font-size: 24px; /* 見出しとして視認性を上げる */
      line-height: 1.25; /* 見出しの詰まりを防ぐ */
      letter-spacing: 0.02em; /* 見出しは少し字間を広げる */
      text-align: center;
    }

    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: flex-end; }

    .card {
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 12px 15px;
      margin: 12px 0;

      /* 各 card ごとの色味調整用（デフォルト） */
      background: linear-gradient(
        180deg,
        var(--card-panel, var(--panel)) 0%,
        var(--card-panel2, var(--panel2)) 100%
      );

      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }

    /* JSファイルブロックのカードだけ、ほんの少し明るくする */
    .card.card-file {
      --card-panel:  #16202a;
      --card-panel2: #141d27;
    }

    /* ============================================================
       card ごとの色味バリエーション（並び順ベース）
       ------------------------------------------------------------
       目的:
         - 視線誘導の補助
         - セクション境界を直感的に分かりやすくする
         - コントラストは変えず、色相のみを微調整
    ============================================================ */

    .card:nth-of-type(1n) {
      --card-panel:  #11151b; /* 基本（既存） */
      --card-panel2: #0f1217;
    }

    .card:nth-of-type(2n) {
      --card-panel:  #101824; /* わずかに青寄り */
      --card-panel2: #0e141d;
    }

    .card:nth-of-type(3n) {
      --card-panel:  #121826; /* 少しシアン寄り */
      --card-panel2: #101624;
    }

    .card:nth-of-type(4n) {
      --card-panel:  #141827; /* わずかに紫寄り */
      --card-panel2: #121524;
    }

    textarea {
      box-sizing: border-box; /* padding/border込みでwidth計算し、親からはみ出さないようにする */
      width: 100%;
      min-height: 80px;
      font-size: 14px; /* 入力文字を読みやすくする */
      line-height: 1.6; /* 入力欄の行間を少し広げる */
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Noto Sans Mono";
      background: #0c1016;
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px; /* 視認性のため少し余白を増やす */
      outline: none;

      overflow: auto;  /* リサイズ/UIと相性が良い */
      resize: vertical; /* デフォルトは縦リサイズ可 */
    }

    textarea#instruction {
      overflow: hidden; /* autosize用：内部スクロール無し */
      resize: none;     /* autosize用：手動リサイズ無し */
    }

    select, input[type="number"], input#prefix {
      box-sizing: border-box; /* input/selectも同様に、横はみ出し防止 */
      width: 100%; /* 4列の各セル内に確実に収める */
      font-size: 14px; /* ラベル/入力値を読みやすくする */
      line-height: 1.4; /* 高さのバランスを整える */
      padding: 9px 10px; /* 視認性のため少しだけ余白を増やす */
      border-radius: 12px;
      border: 1px solid var(--border);
      background: #0c1016;
      color: var(--text);
      outline: none;
      height: 34px;
    }

    /* extract: カンマ区切り入力は「大きめ」にする（打ちやすさ優先） */
    input#extractSymbols, input#extractNeedles, input#extractSessionId, input#extractPurpose, input#extractDepends {
      box-sizing: border-box;
      width: 100%;
      font-size: 14px;
      line-height: 1.4;
      padding: 11px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: #0c1016;
      color: var(--text);
      outline: none;
      height: 44px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Noto Sans Mono";
    }
    
    /* =========================
   全 input の placeholder を薄くする
   ========================= */

    input::placeholder {
      color: rgba(231, 234, 240, 0.30);
      opacity: 1; /* Safari / Chrome 対策 */
    }
    
    /* Firefox 対応 */
    input::-moz-placeholder {
      color: rgba(231, 234, 240, 0.30);
      opacity: 1;
    }
    
    /* Edge / 旧仕様互換（念のため） */
    input:-ms-input-placeholder {
      color: rgba(231, 234, 240, 0.30);
    }

    /* extract: 数値2つは「小さめ」にする（面積を取りすぎない） */
    input#extractContextLines, input#extractMaxMatches {
      box-sizing: border-box;
      width: 100%;
      font-size: 12px;
      line-height: 1.2;
      padding: 6px 8px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: #0c1016;
      color: var(--text);
      outline: none;
      height: 30px;
    }

    input[type="file"] {
      color: var(--muted);
    }

    textarea:focus, select:focus, input[type="number"]:focus, input#prefix:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(125, 211, 252, 0.18);
    }

    button {
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: #0c1016;
      color: var(--text);
      font-size: 14px; /* ボタン文字の読みやすさを上げる */
      line-height: 1.2; /* ボタン内の縦詰まりを防ぐ */
      transition: transform 80ms ease, box-shadow 120ms ease, border-color 120ms ease, background 120ms ease, opacity 120ms ease;
      box-shadow: 0 8px 18px rgba(0,0,0,0.35);
      user-select: none;
      cursor: pointer;
    }

    /* 指定ボタン（生成 / 抽出 / 入力モード切替 / このパートをコピー / 次のパートを表示）：横幅を大きくして押しやすくする */
    #run, #runExtract, #copyCurrent, #copyNext, #copyExtract, #modeSplitBtn, #modeExtractBtn {
      min-width: 220px;     /* 横幅を確保（画面幅が狭い時は折り返しに任せる） */
      padding-left: 16px;   /* 見た目の“横に大きい”感を出す */
      padding-right: 16px;  /* 同上 */
    }

    /* マウスオーバー時：ボーダー色を見出しの水色に合わせる */
    button:hover {
      border-color: var(--accentSoft);
      box-shadow: 0 10px 22px rgba(0,0,0,0.45);
    }

    button:active {
      transform: translateY(1px) scale(0.99);
      box-shadow: 0 4px 10px rgba(0,0,0,0.35);
    }

    /* ON（強調）状態：primary のボーダー色も見出し水色に合わせる */
    button.primary {
      border-color: var(--accent);
      box-shadow: 0 12px 26px rgba(125,211,252,0.10), 0 10px 22px rgba(0,0,0,0.45);
    }

    button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    button.flash-ok {
      border-color: rgba(34,197,94,0.9);
      box-shadow: 0 0 0 3px rgba(34,197,94,0.18), 0 12px 26px rgba(0,0,0,0.45);
    }

    button.flash-ng {
      border-color: rgba(239,68,68,0.9);
      box-shadow: 0 0 0 3px rgba(239,68,68,0.18), 0 12px 26px rgba(0,0,0,0.45);
    }

    @keyframes partSwitchPulse {
      0% {
        box-shadow: 0 0 0 0 rgba(125,211,252,0.00);
        border-color: var(--border);
      }
      40% {
        box-shadow: 0 0 0 4px rgba(125,211,252,0.20);
        border-color: var(--accent);
      }
      100% {
        box-shadow: 0 0 0 0 rgba(125,211,252,0.00);
        border-color: var(--border);
      }
    }

    .flash-part-switch {
      animation: partSwitchPulse 520ms ease-out 1;
      border-radius: 14px;
    }

    pre {
      background: var(--codebg);
      color: #e8edf7;
      padding: 12px;
      margin: 5px 0;
      border-radius: 14px;
      overflow: auto;
      border: 1px solid var(--border);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.04);
      font-size: 13px; /* コードを読みやすくする */
      line-height: 1.55; /* コード行間を確保する */
    }

    .muted { color: var(--muted); }
    .muted.small  {
    font-size: 12px;
    }
    
    .sectionTitle {
      font-weight: 700; /* 見出しを太字 */
      color: rgba(125, 211, 252, 0.95); /* 水色っぽい（少し淡いシアン） */
      margin-bottom: 5px;
      font-size: 18px; 
    }

    .sectionTitleHist {
      color: rgba(231,234,240,0.78); /* 白で薄く（過去の指示 見出しだけ） */
    }

    .currentPartMeta {
      color: rgba(231,234,240,0.72); /* 白で薄め（情報表示用） */
      font-weight: 400;             /* 見出しより軽く */
    }

    .histMeta {
      font-size: 11px; /* 参照先などの補助情報は小さく */
      line-height: 1.25;
      color: rgba(154,164,178,0.78); /* さらに薄め */
    }

    .parts { display: grid; grid-template-columns: 1fr; gap: 6px; }

    /* パート一覧（#partsList）だけ、カード同士の上下余白を詰める */
    #partsList .card {
      margin: 0;      /* .card の 12px 0 を打ち消す */
      padding: 10px;  /* ついでに少し詰めたいなら。不要なら消してOK */
    }

    .partHeader { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }

    .partTitleRow {
      display: flex;
      align-items: baseline;
      justify-content: space-between; /* 右端にパート切替ボタン列を置く */
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 0px;
    }

    .partJump {
      display: flex;              /* パート番号ボタン列 */
      gap: 6px;
      flex-wrap: wrap;
      justify-content: flex-end;
      align-items: center;
      min-width: 0;
    }

    .partJumpBtn {
      padding: 6px 10px;          /* 小さめの番号ボタン */
      min-width: 38px;
      border-radius: 999px;
      font-size: 13px;
      line-height: 1.1;
    }

    .pillBig {
      font-size: 14px;     /* ← ここが視認性UPの本体 */
      padding: 6px 10px;   /* ← pill自体も少し大きく */
      color: var(--text);  /* 重要情報は少し白寄せ */
    }

    .pill {
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.03);
      color: var(--muted);
    }

    #status {
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.03);
    }

    body.dragover {
      outline: 2px dashed rgba(59,130,246,0.85); /* ドラッグ中であることを分かりやすく表示する */
      outline-offset: 10px; /* 画面端から少し内側に表示して視認性を上げる */
    }
    
    details.adv {
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 10px 12px;
      background: rgba(255,255,255,0.02);
    }

    summary.advSummary {
      cursor: pointer;
      user-select: none;
      color: var(--text);
      font-weight: 600;
      list-style: none;
      outline: none;
    }

    summary.advSummary::-webkit-details-marker {
      display: none;
    }

    summary.advSummary::before {
      content: "▶";
      display: inline-block;
      margin-right: 8px;
      color: var(--muted);
      transform: translateY(-1px);
    }

    details[open] > summary.advSummary::before {
      content: "▼";
    }
    
    .advGrid {
      display: grid;
      gap: 6px;
      align-items: end;

      /* 4列が成立する時だけ4列（1カラムの最低幅を小さくして4列成立しやすくする） */
      grid-template-columns: repeat(4, minmax(100px, 1fr));
    }

    /* 4列が成立しない幅になったら、必ず縦1列 */
    @media (max-width: 400px) {
      .advGrid {
        grid-template-columns: 1fr;
      }
    }

    .advItem {
      min-width: 0; /* grid内で要素がはみ出すのを防ぐ */
    }

    .splitModePick {
      display: flex;
      gap: 8px;
      align-items: center;
      padding: 9px 10px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: #0c1016;
      color: var(--text);
      min-height: 34px;
      box-sizing: border-box;
      user-select: none;
      cursor: pointer;
    }

    .splitModePick input[type="radio"] {
      transform: translateY(1px);
    }

    .splitModeDesc {
      margin-top: 6px;
      font-size: 12px;
      line-height: 1.35;
      color: rgba(154,164,178,0.86);
    }

    /* ============================================================
       履歴（過去の指示）だけ：視認性を下げて“詰める”
       ------------------------------------------------------------
       目的:
         - フォントを小さめ
         - 行間を詰める
         - 余白/カード間隔を詰める
         - ボタン・pillも小さめ
         ※ 他の .card / pre / .partHeader には影響させない
    ============================================================ */
    #instructionHistory .card {
      padding: 8px;
      margin: 0px 0px;
      border-radius: 12px;
    }

    #instructionHistory .partHeader {
      gap: 6px;
      margin-bottom: 6px;
    }

    #instructionHistory .pill {
      font-size: 10px;
      padding: 2px 6px;
    }

    #instructionHistory button {
      padding: 6px 8px;
      font-size: 11px;
      line-height: 1.15;
      border-radius: 10px;
      box-shadow: 0 6px 14px rgba(0,0,0,0.28);
    }

    #instructionHistory pre {
      padding: 8px;
      font-size: 9px;
      line-height: 1.35;
      border-radius: 12px;
      margin: 0;
      color: rgba(231,234,240,0.72); /* 履歴本文だけ薄くする */

      /* ===== はみ出し防止（ここが本体） ===== */
      box-sizing: border-box;
      max-width: 100%;
      min-width: 0;

      /* 横スクロールにせず折り返す */
      overflow-x: hidden;
      overflow-y: hidden;
      white-space: pre-wrap;
      overflow-wrap: anywhere;
      word-break: break-word;
    }

    #instructionHistory .pill {
      color: rgba(154,164,178,0.72); /* pill もさらに薄く */
    }

    #instructionHistory .muted {
      color: rgba(154,164,178,0.68); /* 履歴内の muted も薄く */
    }

    #instructionHistory button {
      color: rgba(231,234,240,0.78); /* ボタン文字も少し薄く */
    }

    /* extract 専用グリッド：2行×2列 */
    .extractGrid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-auto-rows: auto;
      gap: 10px 14px;
    }

    /* 上段（symbols / needles）は少し広く見せたい */
    .extractWide {
      min-height: 72px;
    }

    /* 下段（数値）はコンパクトに */
    .extractNarrow {
      min-height: 48px;
    }
    
    /* extract結果表示専用：長文なのでスクロール可＋高さを確保 */
    textarea#extractPreview {
      overflow: auto;
      resize: vertical;
      font-size: 14px; /* 追加した処理: extractPreview の既定文字サイズ（JSで上書き可） */
    }

    /* 追加した処理: EXEC_TASK（instruction原文）入力欄は長文になりやすいので高さを確保し、折り返して見やすくする */
    textarea#extractExecTask {
      min-height: 80px;
      overflow: auto !important;
      resize: vertical !important;
      white-space: pre-wrap;
      overflow-wrap: anywhere;
    }
    
    .ta-resize-wrap {
      position: relative;
      width: 100%;
    }
    
    /* 細い標準グリップを消して、ハンドルに一本化 */
    .ta-resize-wrap textarea{
      resize: none !important;
      padding-bottom: 34px; /* 右下オーバーレイのハンドルに被らないための余白 */
    }
    
    /* 右下オーバーレイ・広い掴み領域（幅1/3）＋文言で明示 */
    .ta-resize-handle{
      position: absolute;
      right: 6px;
      bottom: 6px;
    
      width: 25%;
      height: 24px;
    
      display: flex;
      align-items: center;
      justify-content: center;
    
      font-size: 12px;
      line-height: 1;
      white-space: nowrap;
    
      cursor: ns-resize;
      user-select: none;
    
      border-radius: 999px;
      background: rgba(231,234,240,0.18);
      border: 1px solid rgba(231,234,240,0.28);
      backdrop-filter: blur(2px);
      opacity: 0.85;
    }
    
    /* hoverで「掴める感」を強調 */
    .ta-resize-wrap:hover .ta-resize-handle{
      opacity: 1;
      background: rgba(231,234,240,0.26);
      border-color: rgba(231,234,240,0.45);
    }
    
    /* ドラッグ中の強調 */
    .ta-resize-wrap.is-resizing .ta-resize-handle{
      background: rgba(120,180,255,0.30);
      border-color: rgba(120,180,255,0.60);
    }
    
    /* 旧hintは使わないなら非表示（残すならこの行を消してOK） */
    .ta-resize-hint{
      opacity: 0.85;
    }
    
  </style>
</head>
<body>
  <h2>Protocol Splitter（ローカル専用）</h2>
  <div class="muted">① assets内のJSを選ぶ（ドラッグ&ドロップも可） → ② 指示を書く → ③ 生成 → ④ パートを表示してコピー</div>
  <div class="muted small">cd /Users/muroyamasusumu/Documents/cscs_video_quiz/quiz_html<br>
  python3 local_protocol_tool.py<br>
  http://127.0.0.1:8787</div>
  

  <div class="card card-file">
    <div class="row">
      <div>
        <div class="muted sectionTitle">JSファイル</div>
        <input id="file" type="file" accept=".js,.mjs,.cjs,.txt" />
      </div>
    </div>

    <details class="adv" style="margin-top:10px;">
      <summary class="advSummary">詳細設定（Prefix / Lang / split制限）</summary>

      <div class="advGrid" style="margin-top:10px;">
        <div class="advItem">
          <div class="muted">Prefix</div>
          <input id="prefix" value="CSCSJS" />
        </div>
        <div class="advItem">
          <div class="muted">Lang</div>
          <select id="lang">
            <option value="javascript">javascript</option>
            <option value="text">text</option>
          </select>
        </div>
        <div class="advItem">
          <div class="muted">maxchars</div>
          <input id="maxchars" type="number" value="60000" />
        </div>
        <div class="advItem">
          <div class="muted">maxlines</div>
          <input id="maxlines" type="number" value="1200" />
        </div>

        <div class="advItem">
          <div class="muted">maxlogs</div>
          <input id="maxlogs" type="number" value="50" />
        </div>

        <div class="advItem">
          <div class="muted">splitMode (C)</div>
          <label class="splitModePick">
            <input type="radio" name="splitModeRadio" value="C">
            <span>C: 通常</span>
          </label>
          <div class="muted splitModeDesc">
            上限（maxchars/maxlines）をまず守る方針。上限内の末尾付近で
            <code style="color:rgba(231,234,240,0.88);">})();</code> /
            <code style="color:rgba(231,234,240,0.88);">});</code> /
            <code style="color:rgba(231,234,240,0.88);">}</code>
            など“境界っぽい行”を後方探索し、見つからなければ改行で切る。
            サイズは安定するが、IIFEの途中で切れる可能性がある。
          </div>
        </div>

        <div class="advItem">
          <div class="muted">splitMode (B)</div>
          <label class="splitModePick">
            <input type="radio" name="splitModeRadio" value="B">
            <span>B: ハイブリッド</span>
          </label>
          <div class="muted splitModeDesc">
            上限付近から <b style="color:rgba(231,234,240,0.88);">上限+30%</b> まで「少し粘って」
            IIFE終端 <code style="color:rgba(231,234,240,0.88);">})();</code> を探す。
            見つかれば“キレイに切る”、見つからなければ改行で切ってサイズを安定させる。
            運用が一番バランス良く、破綻しにくい。
          </div>
        </div>

        <div class="advItem">
          <div class="muted">splitMode (A)</div>
          <label class="splitModePick">
            <input type="radio" name="splitModeRadio" value="A">
            <span>A: IIFE終端最優先</span>
          </label>

          <input type="hidden" id="splitMode" value="C" />

          <div class="muted splitModeDesc">
            IIFE終端 <code style="color:rgba(231,234,240,0.88);">})();</code> を最優先で探して「そこで切る」。
            上限は“目安”になりやすく、巨大IIFEだと 1パートが上限を大幅に超えて大きくなることがある。
            その代わり「IIFE途中で切って壊す」リスクを強く避けられる。
          </div>
        </div>
      </div>
    </details>

    <div style="margin-top:12px;">
      <div class="row" style="align-items:center;">
        <div class="muted sectionTitle" style="margin-bottom:0;">入力モード</div>
        <button class="primary" id="modeSplitBtn" type="button">指示（--instruction）</button>
        <button id="modeExtractBtn" type="button">symbols / needles</button>
      </div>

      <!-- Split（指示）入力欄 -->
      <div id="modeSplitBox" style="margin-top:10px;">
        <div class="muted sectionTitle">指示（--instruction）</div>
        <div class="ta-resize-wrap" data-target="instruction">
          <textarea id="instruction" placeholder="ここに作業指示を書く（この内容が最終パートの EXEC_TASK になる）"></textarea>
          <div class="ta-resize-handle" role="separator" aria-label="Resize instruction textarea"> <div class="ta-resize-hint">⇕ ここをドラッグして高さ変更</div></div>         
        </div>
      </div>

      <!-- Extract（symbols/needles）入力欄 -->
      <div id="modeExtractBox" style="margin-top:10px; display:none;">
        <div class="muted sectionTitle">symbols / needles（extract用）</div>

        <div class="advGrid extractGrid" style="margin-top:10px;">
          <!-- 上段：文字系（横2列） -->
          <div class="advItem extractWide">
            <div class="muted">EXTRACT_SYMBOLS（必須 / カンマ区切り）</div>
            <input id="extractSymbols" value="" placeholder="例: split_by_limits, build_exec_task_block" />
          </div>

          <div class="advItem extractWide">
            <div class="muted">EXTRACT_NEEDLES（カンマ区切り / 空も可）</div>
            <input id="extractNeedles" value="" placeholder="例: SCOPE_INDEX, RECEIPT_CHECK" />
          </div>

          <!-- 追加した処理: split直後の result.session_id を受け取り、extractヘッダへ必ず出すための入力欄 -->
          <div class="advItem extractWide">
            <div class="muted">SESSION_ID（split直後に自動入力 / 手入力・コピペ可）</div>
            <input id="extractSessionId" value="" placeholder="例: CSCSJS-1A2B3C4D" />
          </div>

          <!-- 追加した処理: CODE_ONLY を SESSION_ID の隣に移動し、抽出実行前に“表示モード”を並べて確認できるようにする -->
          <div class="advItem extractNarrow">
            <div class="muted">CODE_ONLY（厳格 / 抽出コード以外を表示しない）</div>
            <label class="splitModePick" style="height: 44px; padding:6px 13px; margin-bottom: 4px;">
              <input id="extractCodeOnly" type="checkbox" />
              <span>ON</span>
            </label>
          </div>

          <!-- 追加した処理: split直後の instruction 原文（EXEC_TASK）を保持し、extractヘッダへ必ず出すための入力欄 -->
          <div class="advItem extractWide" style="grid-column: 1 / -1;">
            <div class="muted">EXEC_TASK（split直後に自動入力 / 手入力・コピペ可）</div>
            <div class="ta-resize-wrap" data-target="extractExecTask">
              <textarea id="extractExecTask" placeholder="例: ここに split の指示（--instruction 原文）が入る（EXEC_TASK）"></textarea>
              <div class="ta-resize-handle" role="separator" aria-label="Resize EXEC_TASK textarea"><div class="ta-resize-hint">⇕ ここをドラッグして高さ変更</div></div>
            </div>
          </div>

          <!-- 追加した処理: 抽出の目的（LLMの判断ブレ低減）を1行で添える -->
          <div class="advItem extractWide">
            <div class="muted">PURPOSE（1行）</div>
            <input id="extractPurpose" value="" placeholder="例: createPanel 内の「手動送信クリック後HUD再描画」周辺を修正したい" />
          </div>

          <!-- 追加した処理: 依存関数/依存データの“存在だけ”をメタで列挙（中身不要） -->
          <div class="advItem extractWide">
            <div class="muted">DEPENDS（カンマ区切り / 任意）</div>
            <input id="extractDepends" value="" placeholder="例: fetchState, renderPanel, readIntFromLocalStorage, computePendingFlags, info.qid" />
          </div>

          <!-- 下段：数値系（横2列） -->
          <div class="advItem extractNarrow">
            <div class="muted">EXTRACT_CONTEXT_LINES</div>
            <input id="extractContextLines" type="number" value="25" />
          </div>

          <div class="advItem extractNarrow">
            <div class="muted">EXTRACT_MAX_MATCHES</div>
            <input id="extractMaxMatches" type="number" value="50" />
          </div>
        </div>

        <div class="muted" style="margin-top:8px;">
          ※ symbols は「関数まるごと抽出」対象、needles は「周辺行抽出」対象（複数指定OK）
        </div>
      </div>
    </div>

    <div class="row" style="margin-top:12px;">
      <button class="primary" id="run">生成（split）</button>
      <button id="runExtract" style="display:none;">抽出（extract）</button>
      <button id="copyExtract" style="display:none;" disabled>抽出結果をコピー</button>
      <button id="resetExtract" style="display:none;" disabled>抽出をリセット</button>
      <button id="copyNext" disabled>次のパートを表示</button>
      <button id="resetGen" disabled>生成をリセット</button>
      <span class="muted" id="status" style="display:none;"></span>
    </div>
  </div>

  <!-- Split（分割）モード用：現在のパート -->
  <div class="card" id="currentPartCard">
    <div class="partTitleRow">
      <div class="muted sectionTitle" id="currentPartTitle">
        <span class="currentPartLabel">現在のパート</span>
        <span class="currentPartMeta">　Part: - / -　(SessionID: -)</span>
      </div>

      <!-- 右端：パート番号ボタン -->
      <div id="partJump" class="partJump"></div>
    </div>

    <div class="partHeader">
      <span class="pill pillBig" id="pidPill">PartID: -</span>
      <span class="pill pillBig" id="sha8Pill">SHA8: -</span>
      <button id="copyCurrent" disabled>このパートをコピー</button>
      <button id="toggleAll" disabled>ALL: OFF</button>
    </div>
    <pre id="preview">(まだ生成していません)</pre>
  </div>

  <!-- Extract（抽出）モード用：抽出結果専用 -->
  <div class="card" id="extractResultCard" style="display:none;">
    <!-- 追加した処理: 抽出結果も split と同様に「ALL: OFF/ON」で全文/一部表示を切替できるようにする -->
    <div class="partHeader" style="justify-content:space-between; gap:10px;">
      <div class="muted sectionTitle" style="margin-bottom:0;">抽出結果（extract）</div>

      <div class="row" style="align-items:center; margin:0; gap:10px;">
        <!-- 追加した処理: extractPreview の文字サイズをスライダーで変更 -->
        <span class="pill" style="display:flex; align-items:center; gap:8px;">
          <span style="color:rgba(154,164,178,0.90);">Font</span>
          <input id="extractPreviewFont"
                 type="range"
                 min="10"
                 max="28"
                 step="1"
                 value="14"
                 style="width:160px; height:18px;" />
          <span id="extractPreviewFontLabel" style="min-width:44px; text-align:right;">14px</span>
        </span>

        <button id="toggleExtractAll" disabled>ALL: OFF</button>
      </div>
    </div>

    <div class="muted" style="margin-top:6px;">
      ※ ここに <<<EXTRACT_BEGIN>>> から全部出ます（そのままコピペ用途）
    </div>
    
    <div class="ta-resize-wrap" data-target="extractPreview">
      <textarea
        id="extractPreview"
        readonly
        placeholder="(まだ抽出していません)">
      </textarea>
      <div class="ta-resize-handle"><div class="ta-resize-hint">⇕ ここをドラッグして高さ変更</div></div>
    </div>

    <!-- 追加した処理: FOUND:false をコピー対象外の“小ログ”として textarea 外に表示する -->
    <div class="muted" id="extractNotFoundLog"
         style="margin-top:10px; font-size:12px; line-height:1.35; white-space:pre-wrap; opacity:0.85;">
    </div>
  </div>

  <div class="card">
    <div class="muted sectionTitle">パート一覧</div>
    <div class="parts" id="partsList"></div>
  </div>

  <div class="card">
    <div class="muted sectionTitle sectionTitleHist">過去の指示（--instruction）</div>
    <div class="muted histMeta" id="histRoot" style="margin-top:6px;">参照先: （未取得）</div>
    <div class="row" style="margin-top:10px;">
      <button id="histClear">履歴クリア</button>
      <span class="muted" id="histStatus"></span>
    </div>
    <div class="parts" id="instructionHistory" style="margin-top:6px;"></div>
  </div>

<script>
  const $ = (id) => document.getElementById(id);

  const UI_STATE_KEY = "protocol_splitter_ui_state_v1";

  function loadUiState() {
    try {
      const raw = localStorage.getItem(UI_STATE_KEY);
      if (!raw) return null;
      const obj = JSON.parse(raw);
      if (!obj || typeof obj !== "object") return null;
      return obj;
    } catch (e) {
      return null;
    }
  }

  function saveUiState() {
    try {
      const s = {
        prefix: String(($("prefix") && $("prefix").value) || ""),
        lang: String(($("lang") && $("lang").value) || ""),
        maxchars: Number(($("maxchars") && $("maxchars").value) || 0),
        maxlines: Number(($("maxlines") && $("maxlines").value) || 0),
        maxlogs: Number(($("maxlogs") && $("maxlogs").value) || 0),
        splitMode: String(($("splitMode") && $("splitMode").value) || "C"),
        instruction: String(($("instruction") && $("instruction").value) || ""),
        uiMode: String((window.__uiMode || "split")),
        extractSymbols: String(($("extractSymbols") && $("extractSymbols").value) || ""),
        extractNeedles: String(($("extractNeedles") && $("extractNeedles").value) || ""),
        /* 追加した処理: splitで得た session_id を extractヘッダへ必ず出すため、UI状態として保存 */
        extractSessionId: String(($("extractSessionId") && $("extractSessionId").value) || ""),
        /* 追加した処理: splitの instruction 原文（EXEC_TASK）を extractヘッダへ必ず出すため、UI状態として保存 */
        extractExecTask: String(($("extractExecTask") && $("extractExecTask").value) || ""),
        /* 追加した処理: 抽出結果に PURPOSE を確実に添えるため、UI状態として保存 */
        extractPurpose: String(($("extractPurpose") && $("extractPurpose").value) || ""),
        /* 追加した処理: 抽出結果に DEPENDS を確実に添えるため、UI状態として保存 */
        extractDepends: String(($("extractDepends") && $("extractDepends").value) || ""),
        extractContextLines: Number(($("extractContextLines") && $("extractContextLines").value) || 25),
        extractMaxMatches: Number(($("extractMaxMatches") && $("extractMaxMatches").value) || 50),
        /* 追加した処理: 「コードのみ（厳格）」スイッチもUI状態として保存し、毎回の操作ブレを防ぐ */
        extractCodeOnly: !!(($("extractCodeOnly") && $("extractCodeOnly").checked) ? true : false),
        currentIndex: Number(currentIndex || 0),
        previewAllOn: !!previewAllOn,
        /* 追加した処理: extract結果の全文表示/一部表示（ALL: OFF/ON）状態も保存する */
        extractPreviewAllOn: !!extractPreviewAllOn,

        /* 追加した処理: extractPreview の文字サイズ(px)も保存する */
        extractPreviewFontPx: Number(($("extractPreviewFont") && $("extractPreviewFont").value) || 14),
      };
      localStorage.setItem(UI_STATE_KEY, JSON.stringify(s));
    } catch (e) {}
  }

  function restoreUiState() {
    const s = loadUiState();
    if (!s) return;

    if ($("prefix") && typeof s.prefix === "string" && s.prefix) {
      $("prefix").value = s.prefix;
    }
    if ($("lang") && typeof s.lang === "string" && s.lang) {
      $("lang").value = s.lang;
    }
    if ($("maxchars") && typeof s.maxchars === "number" && s.maxchars > 0) {
      $("maxchars").value = String(s.maxchars);
    }
    if ($("maxlines") && typeof s.maxlines === "number" && s.maxlines > 0) {
      $("maxlines").value = String(s.maxlines);
    }
    if ($("maxlogs") && typeof s.maxlogs === "number" && s.maxlogs > 0) {
      $("maxlogs").value = String(s.maxlogs);
    }

    if ($("splitMode") && typeof s.splitMode === "string" && s.splitMode) {
      $("splitMode").value = s.splitMode;

      const radios = document.querySelectorAll('input[name="splitModeRadio"]');
      for (let i = 0; i < radios.length; i++) {
        const r = radios[i];
        const v = String(r && r.value ? r.value : "");
        r.checked = (v === s.splitMode);
      }
    }

    if ($("instruction") && typeof s.instruction === "string") {
      $("instruction").value = s.instruction;
    }

    if ($("extractSymbols") && typeof s.extractSymbols === "string") {
      $("extractSymbols").value = s.extractSymbols;
    }
    if ($("extractNeedles") && typeof s.extractNeedles === "string") {
      $("extractNeedles").value = s.extractNeedles;
    }
    /* 追加した処理: SESSION_ID / EXEC_TASK も復元して、split→extract の往復で情報が消えないようにする */
    if ($("extractSessionId") && typeof s.extractSessionId === "string") {
      $("extractSessionId").value = s.extractSessionId;
    }
    if ($("extractExecTask") && typeof s.extractExecTask === "string") {
      $("extractExecTask").value = s.extractExecTask;
    }
    /* 追加した処理: PURPOSE / DEPENDS も復元して、抽出コピーの定型が崩れないようにする */
    if ($("extractPurpose") && typeof s.extractPurpose === "string") {
      $("extractPurpose").value = s.extractPurpose;
    }
    if ($("extractDepends") && typeof s.extractDepends === "string") {
      $("extractDepends").value = s.extractDepends;
    }
    if ($("extractContextLines") && (typeof s.extractContextLines === "number" || typeof s.extractContextLines === "string")) {
      const v = Number(s.extractContextLines);
      if (isFinite(v) && v >= 0) $("extractContextLines").value = String(v);
    }
    if ($("extractMaxMatches") && (typeof s.extractMaxMatches === "number" || typeof s.extractMaxMatches === "string")) {
      const v = Number(s.extractMaxMatches);
      if (isFinite(v) && v > 0) $("extractMaxMatches").value = String(v);
    }

    /* 追加した処理: 「コードのみ（厳格）」スイッチも復元する（ON/OFFを保持） */
    if ($("extractCodeOnly") && typeof s.extractCodeOnly === "boolean") {
      $("extractCodeOnly").checked = !!s.extractCodeOnly;
    }

    if (typeof s.previewAllOn === "boolean") {
      previewAllOn = s.previewAllOn;
    }

    /* 追加した処理: extract結果の全文表示/一部表示（ALL: OFF/ON）状態も復元する */
    if (typeof s.extractPreviewAllOn === "boolean") {
      extractPreviewAllOn = s.extractPreviewAllOn;
    }

    /* 追加した処理: extractPreview の文字サイズ(px)も復元する */
    (function(){
      const slider = $("extractPreviewFont");
      const label  = $("extractPreviewFontLabel");
      const ta     = $("extractPreview");

      let px = 14;
      if (typeof s.extractPreviewFontPx === "number" || typeof s.extractPreviewFontPx === "string") {
        const v = Number(s.extractPreviewFontPx);
        if (isFinite(v) && v >= 10 && v <= 28) px = v;
      }

      if (slider) slider.value = String(px);
      if (label)  label.textContent = String(px) + "px";
      if (ta)     ta.style.fontSize = String(px) + "px";
    })();

    if (typeof s.uiMode === "string" && s.uiMode) {
      window.__uiMode = s.uiMode;
    } else {
      window.__uiMode = "split";
    }
  }

  function restoreUiStatePostResult() {
    const s = loadUiState();
    if (!s) return;

    if (typeof s.currentIndex === "number" && isFinite(s.currentIndex)) {
      const idx = Math.max(0, Math.floor(s.currentIndex));
      if (result && result.parts && result.parts.length > 0) {
        currentIndex = Math.min(idx, result.parts.length - 1);
      } else {
        currentIndex = 0;
      }
    }
  }

  function autosizeInstruction() {
    const ta = $("instruction");
    if (!ta) return;

    ta.style.height = "auto";
    const next = ta.scrollHeight;
    ta.style.height = String(next) + "px";
  }

  function setFileFromDrop(file) {
    if (!file) return;

    const name = String(file.name || "");
    const okExt = /\.(js|mjs|cjs|txt)$/i.test(name);

    if (!okExt) {
      setStatus("非対応の拡張子です（.js/.mjs/.cjs/.txt）: " + name);
      return;
    }

    const dt = new DataTransfer();
    dt.items.add(file);
    $("file").files = dt.files;

    setStatus("ファイル選択: " + name + "（ドラッグ&ドロップ）");
    runSyntaxCheckForFile(file);
  }

  window.addEventListener("dragover", (ev) => {
    ev.preventDefault(); /* drop を有効化する */
    document.body.classList.add("dragover"); /* ドラッグ中の視覚表現 */
  });

  window.addEventListener("dragleave", (ev) => {
    ev.preventDefault();
    document.body.classList.remove("dragover"); /* ドラッグ終了で解除 */
  });

  window.addEventListener("drop", (ev) => {
    ev.preventDefault(); /* ブラウザのデフォルト（開く/移動）を抑止する */
    document.body.classList.remove("dragover"); /* ドラッグ表現を解除 */

    const files = ev.dataTransfer && ev.dataTransfer.files ? ev.dataTransfer.files : null;
    if (!files || files.length === 0) {
      setStatus("ドロップされたファイルが見つかりません");
      return;
    }

    setFileFromDrop(files[0]); /* 先頭の1ファイルのみ扱う */
  });

  let result = null;
  let currentIndex = 0;

  let previewAllOn = false;

  /* 追加した処理: extract結果は常に全文表示にする（折りたたみ無し） */
  let extractPreviewAllOn = true;

  /* extract結果（<<<EXTRACT_BEGIN>>>..<<<EXTRACT_END>>>）を保持してコピーできるようにする */
  let lastExtractText = "";

  /* extract表示の折りたたみ上限（先頭何行まで見せるか） */
  const EXTRACT_PREVIEW_HEAD_MAX_LINES = 18;

  /* extract表示の折りたたみ上限（行数で切った後の保険：文字数） */
  const EXTRACT_PREVIEW_HEAD_MAX_CHARS = 1800;

  function buildExtractPreviewText(fullText) {
    /*
     * 何をしているか:
     *   - extract結果は常に全文表示に固定する（折りたたみ無し）。
     *   - 既存の ALL: OFF/ON ロジックは保持していても表示は常に全文になる。
     */
    const s = String(fullText || "");
    return s;
  }

  function updateToggleExtractAllButton() {
    const btn = $("toggleExtractAll");
    if (!btn) return;

    /*
     * 何をしているか:
     *   - extract結果は常に全文表示に固定するため、ALL切替ボタンは常に無効化する。
     *   - ただし「コピー」「リセット」は抽出結果がある時だけ押せるように維持する。
     */
    const ta = $("extractPreview");
    const hasLast = (String(lastExtractText || "").length > 0);
    const hasTA = !!(ta && String(ta.value || "").trim() !== "");

    const enabled = (hasLast || hasTA);

    /* ALL 切替は使わない（常に全文表示） */
    btn.disabled = true;
    btn.textContent = "ALL: ON";

    /* extractPreviewAllOn も常に true に寄せる（UI状態復元で false になっても戻す） */
    extractPreviewAllOn = true;

    /* 追加した処理: extract結果がある時だけ Copy/Reset も押せるようにする */
    const btnCopy = $("copyExtract");
    if (btnCopy) btnCopy.disabled = !enabled;

    const btnReset = $("resetExtract");
    if (btnReset) btnReset.disabled = !enabled;
  }

  function renderExtractPreview() {
    const ta = $("extractPreview");
    if (!ta) return;

    /* 追加した処理: extract結果の表示は「全文 or 先頭のみ」を buildExtractPreviewText で統一する */
    ta.value = buildExtractPreviewText(lastExtractText);

    updateToggleExtractAllButton();
  }

  /* 追加した処理: extract結果カードの ALL: OFF/ON ボタンを動作させる */
  (function(){
    const btn = $("toggleExtractAll");
    if (!btn) return;

    btn.onclick = () => {
      /*
       * 何をしているか:
       *   - extractPreviewAllOn を反転
       *   - textarea 表示を再描画
       *   - UI状態を保存
       */
      extractPreviewAllOn = !extractPreviewAllOn;
      renderExtractPreview();
      saveUiState();
      setStatus("extract：ALL 表示を切替（" + (extractPreviewAllOn ? "ON" : "OFF") + "）");
    };
  })();

  /* 追加した処理: extractPreview のフォントサイズをスライダーで変更（即反映＋保存） */
  (function(){
    const slider = $("extractPreviewFont");
    const label  = $("extractPreviewFontLabel");
    const ta     = $("extractPreview");

    if (!slider) return;

    function apply(px) {
      const v = Number(px);
      const clamped = Math.max(10, Math.min(28, isFinite(v) ? v : 14));

      if (label) label.textContent = String(clamped) + "px";
      if (ta) ta.style.fontSize = String(clamped) + "px";

      saveUiState();
    }

    slider.addEventListener("input", function(){
      apply(slider.value);
      setStatus("extract：文字サイズを変更（" + String(slider.value) + "px）");
    });

    /* 初期値（HTML側の value=14 を反映） */
    apply(slider.value);
  })();
  
  window.__uiMode = "split";

  function applyUIMode(nextMode) {
    const mode = (String(nextMode || "") === "extract") ? "extract" : "split";
    window.__uiMode = mode;

    const splitBox = $("modeSplitBox");
    const extractBox = $("modeExtractBox");
    const btnSplit = $("modeSplitBtn");
    const btnExtract = $("modeExtractBtn");

    const btnRunSplit = $("run");
    const btnRunExtract = $("runExtract");

    if (splitBox) splitBox.style.display = (mode === "split") ? "" : "none";
    if (extractBox) extractBox.style.display = (mode === "extract") ? "" : "none";

    if (btnRunSplit) btnRunSplit.style.display = (mode === "split") ? "" : "none";
    if (btnRunExtract) btnRunExtract.style.display = (mode === "extract") ? "" : "none";

    const btnCopyExtract = $("copyExtract");
    if (btnCopyExtract) btnCopyExtract.style.display = (mode === "extract") ? "" : "none";

    const btnResetExtract = $("resetExtract");
    if (btnResetExtract) btnResetExtract.style.display = (mode === "extract") ? "" : "none";

    if (btnSplit) {
      if (mode === "split") btnSplit.classList.add("primary");
      else btnSplit.classList.remove("primary");
    }
    if (btnExtract) {
      if (mode === "extract") btnExtract.classList.add("primary");
      else btnExtract.classList.remove("primary");
    }

    /* 追加した処理: extractモード時は「現在のパート」カードを非表示にし、抽出結果カードに切り替える */
    const currentPartCard = $("currentPartCard");
    const extractResultCard = $("extractResultCard");
    if (currentPartCard) currentPartCard.style.display = (mode === "split") ? "" : "none";
    if (extractResultCard) extractResultCard.style.display = (mode === "extract") ? "" : "none";

    /* 追加した処理: extractモードでは split操作ボタンを無効化して誤操作を防ぐ */
    const btnCopyCurrent = $("copyCurrent");
    const btnCopyNext = $("copyNext");
    const btnToggleAll = $("toggleAll");
    if (btnCopyCurrent) btnCopyCurrent.disabled = (mode === "extract") ? true : !!(btnCopyCurrent.disabled && false);
    if (btnCopyNext) btnCopyNext.disabled = (mode === "extract") ? true : !!(btnCopyNext.disabled && false);
    if (btnToggleAll) btnToggleAll.disabled = (mode === "extract") ? true : !!(btnToggleAll.disabled && false);

    saveUiState();

    try {
      if (mode === "split" && $("instruction")) $("instruction").focus();
      if (mode === "extract" && $("extractSymbols")) $("extractSymbols").focus();
    } catch (e) {}
  }

  /* 折りたたみ時の縦サイズ上限（= 先頭何行まで見せるか） */
  const PREVIEW_HEAD_MAX_LINES = 18;

  /* 折りたたみ時の文字数上限（行数で切った後の保険） */
  const PREVIEW_HEAD_MAX_CHARS = 1200;

  function renderPartJumpButtons() {
    const box = $("partJump");
    if (!box) return;

    box.innerHTML = "";

    if (!result || !result.parts || result.parts.length === 0) {
      return;
    }

    for (let i = 0; i < result.parts.length; i++) {
      const p = result.parts[i];

      const btn = document.createElement("button");
      btn.className = "partJumpBtn" + (i === currentIndex ? " primary" : "");
      btn.textContent = String(p.index); /* 1..N の番号だけ */

      btn.onclick = () => {
        currentIndex = i;
        renderCurrent();
        saveUiState();
        setStatus("表示: part_" + String(p.index).padStart(2, "0"));
      };

      box.appendChild(btn);
    }
  }

  function buildPreviewText(fullText) {
    const s = String(fullText || "");
    if (previewAllOn) return s;

    const lines = s.split("\n");
    const headLines = lines.slice(0, PREVIEW_HEAD_MAX_LINES).join("\n");

    let out = headLines;
    if (out.length > PREVIEW_HEAD_MAX_CHARS) {
      out = out.slice(0, PREVIEW_HEAD_MAX_CHARS);
    }

    const isTruncatedByLines = lines.length > PREVIEW_HEAD_MAX_LINES;
    const isTruncatedByChars = headLines.length > PREVIEW_HEAD_MAX_CHARS;

    if (isTruncatedByLines || isTruncatedByChars || out.length < s.length) {
      out += "\n\n…（折りたたみ中：ALL を ON にすると全文表示）";
    }

    return out;
  }

  const HIST_PREVIEW_MAX_LINES = 10;

  function getHistoryMaxCharsByWidth(preEl) {
    /* 幅に応じて省略量を変える（狭いほど短く） */
    try {
      if (!preEl) return 900;

      const rect = preEl.getBoundingClientRect();
      const w = Math.max(0, rect.width);

      /* 履歴preは monospace 11px。だいたい 1文字=7px前後で概算 */
      const approxCharPx = 7;
      const charsPerLine = Math.max(12, Math.floor(w / approxCharPx));

      /* 行数上限×1行文字数に少しバッファ（改行やヘッダ分） */
      const maxChars = (HIST_PREVIEW_MAX_LINES * charsPerLine) + 120;

      /* 極端に大きくしない（広い画面でもダラダラ全文にならない） */
      return Math.min(Math.max(220, maxChars), 2200);
    } catch (e) {
      return 900;
    }
  }

  function buildHistoryPreviewText(fullText, preEl) {
    const s = String(fullText || "");
    const lines = s.split("\n");
    const headLines = lines.slice(0, HIST_PREVIEW_MAX_LINES).join("\n");

    const maxChars = getHistoryMaxCharsByWidth(preEl);

    let out = headLines;
    if (out.length > maxChars) {
      out = out.slice(0, maxChars);
    }

    const isTruncatedByLines = lines.length > HIST_PREVIEW_MAX_LINES;
    const isTruncatedByChars = headLines.length > maxChars;

    if (isTruncatedByLines || isTruncatedByChars || out.length < s.length) {
      out += "\n\n…（省略：このRUNの指示は全文ではありません）";
    }

    return out;
  }

  function updateToggleAllButton() {
    const btn = $("toggleAll");
    if (!btn) return;

    /*
     * 何をしているか:
     *   - Split結果があるか（result.parts）に加えて、
     *     現在プレビューに表示している文字列が空でないかも判定に含める。
     *   - result の参照タイミングや render の順序がズレても、
     *     「表示が出ているなら ALL は押せる」を保証する。
     */
    const pre = $("preview");
    const hasResult = !!(result && result.parts && result.parts.length > 0);
    const hasPreviewText = !!(pre && String(pre.textContent || "").trim() !== "");

    const enabled = (hasResult || hasPreviewText);
    btn.disabled = !enabled;

    if (!enabled) {
      btn.textContent = "ALL: OFF";
      return;
    }

    btn.textContent = previewAllOn ? "ALL: ON" : "ALL: OFF";
  }

  /* 追加した処理: split側（現在のパート）の ALL: OFF/ON ボタンを動作させる */
  (function(){
    const btn = $("toggleAll");
    if (!btn) return;

    btn.onclick = () => {
      /*
       * 何をしているか:
       *   - previewAllOn を反転
       *   - 現在表示中パートの描画をやり直す
       *   - UI状態を保存
       */
      previewAllOn = !previewAllOn;
      renderCurrent();
      saveUiState();
      setStatus("split：ALL 表示を切替（" + (previewAllOn ? "ON" : "OFF") + "）");
    };
  })();

  let lastSyntaxCheckOk = null;
  let lastSyntaxCheckMessage = "";

  async function runSyntaxCheckForFile(file) {
    if (!file) return;

    lastSyntaxCheckOk = null;
    lastSyntaxCheckMessage = "";
    setStatus("構文チェック中...");

    let text = "";
    try {
      text = await file.text();
    } catch (e) {
      lastSyntaxCheckOk = false;
      lastSyntaxCheckMessage = "ファイル読み取り失敗: " + String(e);
      setStatus(lastSyntaxCheckMessage);
      return;
    }

    try {
      const res = await fetch("/api/check", {
        method: "POST",
        headers: { "Content-Type": "application/json; charset=utf-8" },
        body: JSON.stringify({ filename: file.name, content: text })
      });

      if (!res.ok) {
        lastSyntaxCheckOk = false;
        lastSyntaxCheckMessage = "構文チェックAPI失敗: HTTP " + String(res.status);
        setStatus(lastSyntaxCheckMessage);
        return;
      }

      const data = await res.json();
      const ok = !!(data && data.ok);
      const err = String((data && data.error) || "").trim();

      lastSyntaxCheckOk = ok;
      lastSyntaxCheckMessage = ok ? "OK" : (err || "構文エラー");

      if (ok) {
        setStatus("構文チェックOK: " + String(file.name || ""));
      } else {
        setStatus("構文チェックNG: " + String(file.name || "") + " / " + lastSyntaxCheckMessage);
      }
    } catch (e) {
      lastSyntaxCheckOk = false;
      lastSyntaxCheckMessage = "構文チェック例外: " + String(e);
      setStatus(lastSyntaxCheckMessage);
    }
  }

  function setHistRoot(msg) {
    const el = $("histRoot");
    if (!el) return;
    el.textContent = String(msg || "");
  }

  async function fetchInstructionHistoryFromServer() {
    try {
      const res = await fetch("/api/instructions", { method: "GET" });
      if (!res.ok) {
        return { outroot: "", total_dirs: 0, items: [], error: "HTTP " + String(res.status) };
      }
      const data = await res.json();

      const outroot = String((data && data.outroot) || "");
      const total_dirs = Number((data && data.total_dirs) || 0);
      const items = (data && Array.isArray(data.items)) ? data.items : [];

      return { outroot, total_dirs, items, error: "" };
    } catch (e) {
      return { outroot: "", total_dirs: 0, items: [], error: String(e) };
    }
  }

  async function renderInstructionHistory() {
    const box = $("instructionHistory");
    if (!box) return;

    box.innerHTML = "";
    setHistStatus("読み込み中...");

    const data = await fetchInstructionHistoryFromServer();

    if (data.outroot) {
      setHistRoot("参照先: " + data.outroot + "（dirs: " + String(data.total_dirs) + "）");
    } else {
      setHistRoot("参照先: （未取得）");
    }

    if (data.error) {
      const div = document.createElement("div");
      div.className = "muted";
      div.textContent = "（読み込み失敗）: " + data.error;
      box.appendChild(div);
      setHistStatus("");
      return;
    }

    const items = data.items;

    if (!items || items.length === 0) {
      const div = document.createElement("div");
      div.className = "muted";
      div.textContent = "（まだ履歴がありません：一度「生成（split）」すると out_protocol_local_tool に保存され、ここに出ます）";
      box.appendChild(div);
      setHistStatus("件数: 0");
      return;
    }

    for (let i = 0; i < items.length; i++) {
      const it = items[i] || {};
      const instr = String(it.instruction || "").trim();

      const div = document.createElement("div");
      div.className = "card";

      const header = document.createElement("div");
      header.className = "partHeader";

      const t1 = document.createElement("span");
      t1.className = "pill";
      t1.textContent = "RUN" + String(i + 1).padStart(2, "0");

      const t2 = document.createElement("span");
      t2.className = "pill";
      t2.textContent = String(it.created_at || "");

      const t3 = document.createElement("span");
      t3.className = "pill";
      t3.textContent = String(it.session_id || "");

      const btnUse = document.createElement("button");
      btnUse.textContent = "入力へ反映";
      btnUse.disabled = !instr;
      btnUse.onclick = () => {
        $("instruction").value = instr;
        autosizeInstruction();
        try { $("instruction").focus(); } catch (e) {}
        setHistStatus("入力欄に反映しました: " + String(it.session_id || ""));
      };

      const btnCopy = document.createElement("button");
      btnCopy.textContent = "コピー";
      btnCopy.disabled = !instr;
      btnCopy.onclick = async () => {
        try {
          await navigator.clipboard.writeText(instr);
          flashButton(btnCopy, "ok");
          setHistStatus("コピーしました: " + String(it.session_id || ""));
          const old = btnCopy.textContent;
          btnCopy.textContent = "Copied ✓";
          window.setTimeout(() => (btnCopy.textContent = old), 650);
        } catch (e) {
          flashButton(btnCopy, "ng");
          setHistStatus("コピー失敗（ブラウザ権限/HTTPS制約の可能性）: " + String(e));
        }
      };

      const btnDel = document.createElement("button");
      btnDel.textContent = "削除";
      btnDel.disabled = !String(it.output_dir || "");
      btnDel.onclick = async () => {
        const dir = String(it.output_dir || "");
        if (!dir) return;

        const ok = window.confirm("この履歴を削除しますか？\n\n" + dir);
        if (!ok) return;

        btnDel.disabled = true;
        setHistStatus("削除中...: " + String(it.session_id || ""));

        try {
          const res = await fetch("/api/instructions/delete", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ output_dir: dir })
          });

          if (!res.ok) {
            setHistStatus("削除失敗: HTTP " + String(res.status));
            btnDel.disabled = false;
            return;
          }

          const data = await res.json();
          if (data && data.ok) {
            setHistStatus("削除しました: " + String(it.session_id || ""));
            await renderInstructionHistory();
          } else {
            setHistStatus("削除失敗: " + String((data && data.error) || "unknown error"));
            btnDel.disabled = false;
          }
        } catch (e) {
          setHistStatus("削除例外: " + String(e));
          btnDel.disabled = false;
        }
      };

      const btnCopySrc = document.createElement("button");
      btnCopySrc.textContent = "元JSコピー";
      btnCopySrc.disabled = !String(it.output_dir || "") || !String(it.original_saved_copy || "");
      btnCopySrc.onclick = async () => {
        const dir = String(it.output_dir || "");
        if (!dir) return;

        setHistStatus("元JS取得中...: " + String(it.session_id || ""));

        try {
          const url = "/api/instructions/original?output_dir=" + encodeURIComponent(dir);
          const res = await fetch(url, { method: "GET" });

          if (!res.ok) {
            setHistStatus("元JS取得失敗: HTTP " + String(res.status));
            flashButton(btnCopySrc, "ng");
            return;
          }

          const text = await res.text();
          await navigator.clipboard.writeText(text);

          flashButton(btnCopySrc, "ok");
          setHistStatus("元JSをコピーしました: " + String(it.session_id || ""));

          const old = btnCopySrc.textContent;
          btnCopySrc.textContent = "Copied ✓";
          window.setTimeout(() => (btnCopySrc.textContent = old), 650);
        } catch (e) {
          flashButton(btnCopySrc, "ng");
          setHistStatus("元JSコピー失敗（権限/HTTP制約等）: " + String(e));
        }
      };

      header.appendChild(t1);
      header.appendChild(t2);
      header.appendChild(t3);
      header.appendChild(btnUse);
      header.appendChild(btnCopy);
      header.appendChild(btnDel);
      header.appendChild(btnCopySrc);

      // 追加した処理: 「元JSコピー」ボタンの右に、対象JSのファイル名を表示する
      const jsNamePill = document.createElement("span");
      jsNamePill.className = "pill";
      (function(){
        const targetFile = String(it.target_file || "").trim();
        const savedCopy  = String(it.original_saved_copy || "").trim();

        let name = targetFile;
        if (!name && savedCopy) {
          const parts = savedCopy.split(/[\\/]/);
          name = parts.length ? String(parts[parts.length - 1] || "").trim() : "";
        }

        jsNamePill.textContent = name ? ("JS: " + name) : "JS: (unknown)";
      })();
      header.appendChild(jsNamePill);

      const pre = document.createElement("pre");
      if (instr) {
        pre.dataset.fullInstruction = instr;
        pre.textContent = buildHistoryPreviewText(instr, pre);
      } else {
        pre.textContent = "（この run の manifest.json に instruction がありません）";
      }

      div.appendChild(header);
      div.appendChild(pre);
      box.appendChild(div);
    }

    setHistStatus("件数: " + items.length);
  }

  function setStatus(msg) {
    const el = $("status");
    if (!el) return;

    /* 表示内容を文字列化して扱う（null/undefined 対策） */
    const s = String(msg || "");

    /* 空メッセージなら、status 自体を非表示にする（未選択時など） */
    if (s.trim() === "") {
      el.textContent = "";
      el.style.display = "none";
      return;
    }

    /* メッセージがある時だけ表示する */
    el.textContent = s;
    el.style.display = "";
  }

  function setHistStatus(msg) {
    const el = $("histStatus");
    if (!el) return;
    el.textContent = msg;
  }

  function flashButton(btn, kind) {
    if (!btn) return;
    const cls = (kind === "ng") ? "flash-ng" : "flash-ok";
    btn.classList.add(cls);
    window.setTimeout(() => btn.classList.remove(cls), 220);
  }

  function flashPartSwitchCue(options) {
    const title = $("currentPartTitle");
    const pre = $("preview");

    const opt = (options && typeof options === "object") ? options : {};
    const doScroll = (opt.scroll === false) ? false : true;

    if (title) {
      title.classList.add("flash-part-switch");
      window.setTimeout(() => title.classList.remove("flash-part-switch"), 560);
    }
    if (pre) {
      pre.classList.add("flash-part-switch");
      window.setTimeout(() => pre.classList.remove("flash-part-switch"), 560);
    }

    /* 追加した処理: スクロール（ページ内ジャンプ）を抑止できるようにする */
    if (!doScroll) return;

    /* 追加した処理: 切替直後に「今どこを見れば良いか」を明確にするため、プレビューへスクロールする */
    try {
      if (pre && typeof pre.scrollIntoView === "function") {
        pre.scrollIntoView({ behavior: "smooth", block: "start" });
      }
    } catch (e) {}
  }

  function goNextPartWithCue(originLabel, options) {
    if (!result || !result.parts || result.parts.length === 0) return false;

    if (currentIndex < result.parts.length - 1) {
      const prev = result.parts[currentIndex];
      currentIndex += 1;
      const next = result.parts[currentIndex];

      /* 追加した処理: 表示を切り替える（次のパート） */
      renderCurrent();
      saveUiState();

      /* 追加した処理: 切り替わったことを水色フラッシュで明示する（必要ならスクロール抑止） */
      flashPartSwitchCue(options);

      /* 追加した処理: 状態表示に「コピー→次へ」等の由来を含め、何が起きたか分かるようにする */
      const origin = String(originLabel || "操作");
      setStatus(origin + "：表示を切替（" + prev.part_id + " → " + next.part_id + "）");

      return true;
    }

    return false;
  }

  async function copyCurrent() {
    if (!result) return;
    const p = result.parts[currentIndex];
    const btn = $("copyCurrent");
    try {
      await navigator.clipboard.writeText(p.payload);
      flashButton(btn, "ok");

      /* 追加した処理: コピー成功後、次のパートへ自動で切り替える（ただしスクロールはしない） */
      const moved = goNextPartWithCue("コピー→次のパートへ", { scroll: false });

      if (!moved) {
        setStatus("コピーしました（最後のパート）: " + p.part_id);
      }

      const old = btn.textContent;
      btn.textContent = "Copied ✓";
      window.setTimeout(() => (btn.textContent = old), 650);
    } catch (e) {
      flashButton(btn, "ng");
      setStatus("コピー失敗（ブラウザ権限/HTTPS制約の可能性）: " + String(e));
    }
  }

  async function copyNext() {
    if (!result) return;
    const btn = $("copyNext");

    if (currentIndex < result.parts.length - 1) {
      flashButton(btn, "ok");

      /* 追加した処理: 「次のパートを表示」でも同じ強い明示（フラッシュ＋ステータス）を出す */
      goNextPartWithCue("次のパートを表示");

      const old = btn.textContent;
      btn.textContent = "表示 ✓";
      window.setTimeout(() => (btn.textContent = old), 650);
    } else {
      flashButton(btn, "ng");
      setStatus("これが最後のパートです: " + result.parts[currentIndex].part_id);
    }
  }

  function renderCurrent() {
    if (!result || !result.parts || result.parts.length === 0) {
      $("preview").textContent = "(まだ生成していません)";
      if ($("currentPartTitle")) {
        const root = $("currentPartTitle");
        const label = root.querySelector(".currentPartLabel");
        const meta  = root.querySelector(".currentPartMeta");

        if (label && meta) {
          /* span構造を維持したまま「未生成」表示に戻す */
          label.textContent = "現在のパート";
          meta.textContent  = "　Part: - / -　(SessionID: -)";
        } else {
          /* 旧DOM（spanが無い）対策：最小限の復元（フォールバックではなくDOM整形） */
          root.innerHTML =
            '<span class="currentPartLabel">現在のパート</span>' +
            '<span class="currentPartMeta">　Part: - / -　(SessionID: -)</span>';
        }
      }
      $("pidPill").textContent = "PartID: -";
      if ($("sha8Pill")) {
        $("sha8Pill").textContent = "SHA8: -";
      }

      previewAllOn = false;
      updateToggleAllButton();
      return;
    }
    
    const p = result.parts[currentIndex];
    $("preview").textContent = buildPreviewText(p.payload);
    if ($("currentPartTitle")) {
      const root = $("currentPartTitle");
      const label = root.querySelector(".currentPartLabel");
      const meta  = root.querySelector(".currentPartMeta");

      if (label) {
        label.textContent = "現在のパート";
      }
      if (meta) {
        meta.textContent =
          "　Part: " + p.index + " / " + p.total +
          "　(SessionID: " + result.session_id + ")";
      }
    }
    $("pidPill").textContent = "PartID: " + p.part_id;
    if ($("sha8Pill")) {
      const s8 = (p && typeof p.part_sha8 === "string" && p.part_sha8) ? p.part_sha8 : "-";
      $("sha8Pill").textContent = "SHA8: " + s8;
    }
    $("copyNext").disabled = false;
    $("copyCurrent").disabled = false;

    updateToggleAllButton();
    renderPartJumpButtons(); /* 右端のパート番号ボタンを更新 */
  }

  function renderList() {
    const box = $("partsList");
    box.innerHTML = "";
    if (!result || !result.parts) return;

    for (let i = 0; i < result.parts.length; i++) {
      const p = result.parts[i];
      const div = document.createElement("div");
      div.className = "card";
      const btnGo = document.createElement("button");
      btnGo.textContent = "表示";
      btnGo.onclick = () => {
        currentIndex = i;
        renderCurrent();
        saveUiState();
        setStatus("表示: part_" + String(p.index).padStart(2, "0"));
      };

      const btnCopy = document.createElement("button");
      btnCopy.textContent = "コピー";
      btnCopy.onclick = async () => {
        try {
          await navigator.clipboard.writeText(p.payload);
          flashButton(btnCopy, "ok");
          setStatus("コピーしました: " + p.part_id);
          const old = btnCopy.textContent;
          btnCopy.textContent = "Copied ✓";
          window.setTimeout(() => (btnCopy.textContent = old), 650);
        } catch (e) {
          flashButton(btnCopy, "ng");
          setStatus("コピー失敗（ブラウザ権限/HTTPS制約の可能性）: " + String(e));
        }
      };

      const header = document.createElement("div");
      header.className = "partHeader";
      const t1 = document.createElement("span");
      t1.className = "pill";
      t1.textContent = "part_" + String(p.index).padStart(2, "0") + ".txt";
      const t2 = document.createElement("span");
      t2.className = "pill";
      t2.textContent = p.part_id;

      const t3 = document.createElement("span");
      t3.className = "pill";
      const s8 = (p && typeof p.part_sha8 === "string" && p.part_sha8) ? p.part_sha8 : "-";
      t3.textContent = "SHA8:" + s8;

      header.appendChild(t1);
      header.appendChild(t2);
      header.appendChild(t3);
      header.appendChild(btnGo);
      header.appendChild(btnCopy);

      div.appendChild(header);
      box.appendChild(div);
    }
  }

  function resetGeneratedOnly() {
    /* 生成結果だけをリセット（instruction は触らない） */
    result = null;
    currentIndex = 0;
    previewAllOn = false;

    $("partsList").innerHTML = "";
    $("preview").textContent = "(まだ生成していません)";
    if ($("idxPill")) {
      $("idxPill").textContent = "Part: -";
    }
    $("pidPill").textContent = "PartID: -";
    if ($("currentSessionInline")) {
      $("currentSessionInline").textContent = "(SessionID: -)";
    }

    $("copyNext").disabled = true;
    $("copyCurrent").disabled = true;

    if ($("resetGen")) {
      $("resetGen").disabled = true;
    }

    saveUiState();
    renderPartJumpButtons(); /* 右端のパート番号ボタンを消す/更新 */
    setHistRoot("参照先: （未取得）");
    setStatus("生成結果をリセットしました（指示は保持）");
  }

  function resetExtractOnly() {
    /*
     * 何をしているか:
     *   extract結果だけを完全に初期状態へ戻す。
     *   - 抽出テキストを消す
     *   - ALL を OFF に戻す
     *   - 表示・ボタン状態を render 系に一本化して同期する
     *   ※ symbols / needles 入力は一切触らない
     */

    lastExtractText = "";
    extractPreviewAllOn = false;

    /*
     * 表示更新は renderExtractPreview に委譲する
     * （textarea への直書きは行わない）
     */
    renderExtractPreview();

    const btnCopyExtract = $("copyExtract");
    if (btnCopyExtract) btnCopyExtract.disabled = true;

    const btnResetExtract = $("resetExtract");
    if (btnResetExtract) btnResetExtract.disabled = true;

    /*
     * ALL トグルボタンの有効状態とラベルを同期
     */
    updateToggleExtractAllButton();

    saveUiState();
    setStatus("抽出結果をリセットしました（入力は保持）");
  }

  async function doSplit() {
    const f = $("file").files[0];
    if (!f) {
      setStatus("JSファイルを選んでください");
      return;
    }

    if (lastSyntaxCheckOk === false) {
      setStatus("構文チェックNGのため生成を中止します: " + String(lastSyntaxCheckMessage || ""));
      return;
    }

    const instr = String($("instruction").value || "").trim();
    if (!instr) {
      /* 生成時に instruction が空なら止める（空EXEC_TASK防止） */
      setStatus("指示（--instruction）が空です。必ず記入してください。");
      try { $("instruction").focus(); } catch (e) {}
      return;
    }

    const text = await f.text();
    const payload = {
      filename: f.name,
      content: text,
      prefix: $("prefix").value || "CSCSJS",
      lang: $("lang").value || "javascript",
      maxchars: Number($("maxchars").value || 60000),
      maxlines: Number($("maxlines").value || 1200),
      maxlogs: Number($("maxlogs").value || 50),
      split_mode: ($("splitMode") && $("splitMode").value) ? String($("splitMode").value) : "C",
      iife_grace_ratio: 0.30,
      instruction: instr
    };

    setStatus("分割中...");
    $("run").disabled = true;
    $("copyNext").disabled = true;
    $("copyCurrent").disabled = true;

    const res = await fetch("/api/split", {
      method: "POST",
      headers: { "Content-Type": "application/json; charset=utf-8" },
      body: JSON.stringify(payload)
    });

    $("run").disabled = false;

    if (!res.ok) {
      const t = await res.text();
      setStatus("エラー: " + t);
      return;
    }

    result = await res.json();
    currentIndex = 0;
    restoreUiStatePostResult();
    renderList();
    renderCurrent();
    renderInstructionHistory();
    autosizeInstruction();

    /* 追加した処理: split直後の result.session_id を extract用 SESSION_ID に自動入力する（手入力も可） */
    if ($("extractSessionId") && result && typeof result.session_id === "string") {
      $("extractSessionId").value = String(result.session_id || "");
    }

    /* 追加した処理: split直後の instruction 原文（EXEC_TASK）を extract用に自動入力する（手入力も可） */
    if ($("extractExecTask")) {
      $("extractExecTask").value = String(instr || "");
    }

    saveUiState();

    if ($("resetGen")) {
      $("resetGen").disabled = false;
    }

    setStatus("生成完了: " + result.session_id + " / parts=" + result.parts.length);
  }

  $("run").onclick = doSplit;

  if ($("resetExtract")) {
    $("resetExtract").onclick = () => resetExtractOnly();
  }
  
  if ($("modeSplitBtn")) {
    $("modeSplitBtn").onclick = () => applyUIMode("split");
  }
  if ($("modeExtractBtn")) {
    $("modeExtractBtn").onclick = () => applyUIMode("extract");
  }

  /* 追加した処理: extract結果も「ALL: OFF/ON」で全文/一部表示を切替する */
  if ($("toggleExtractAll")) {
    $("toggleExtractAll").onclick = () => {
      extractPreviewAllOn = !extractPreviewAllOn;
      renderExtractPreview();
      saveUiState();
      setStatus("extract表示: " + (extractPreviewAllOn ? "ALL: ON（全文）" : "ALL: OFF（一部）"));
    };
  }

  if ($("extractSymbols")) {
    $("extractSymbols").addEventListener("input", () => saveUiState());
  }
  if ($("extractNeedles")) {
    $("extractNeedles").addEventListener("input", () => saveUiState());
  }
  /* 追加した処理: SESSION_ID / EXEC_TASK も入力変更で即保存（split後の自動入力→手修正も保持） */
  if ($("extractSessionId")) {
    $("extractSessionId").addEventListener("input", () => saveUiState());
  }
  if ($("extractExecTask")) {
    $("extractExecTask").addEventListener("input", () => saveUiState());
  }
  /* 追加した処理: PURPOSE / DEPENDS も入力変更で即保存 */
  if ($("extractPurpose")) {
    $("extractPurpose").addEventListener("input", () => saveUiState());
  }
  if ($("extractDepends")) {
    $("extractDepends").addEventListener("input", () => saveUiState());
  }
  if ($("extractContextLines")) {
    $("extractContextLines").addEventListener("input", () => saveUiState());
  }
  if ($("extractMaxMatches")) {
    $("extractMaxMatches").addEventListener("input", () => saveUiState());
  }

  /* 追加した処理: 「コードのみ（厳格）」切替でも即保存し、意図しない表示混入を防ぐ */
  if ($("extractCodeOnly")) {
    $("extractCodeOnly").addEventListener("change", () => saveUiState());
  }

  async function doExtract() {
    const f = $("file").files[0];
    if (!f) {
      setStatus("JSファイルを選んでください");
      return;
    }

    if (lastSyntaxCheckOk === false) {
      setStatus("構文チェックNGのため抽出を中止します: " + String(lastSyntaxCheckMessage || ""));
      return;
    }

    const sym = String(($("extractSymbols") && $("extractSymbols").value) || "").trim();
    const ndl = String(($("extractNeedles") && $("extractNeedles").value) || "").trim();

    const ctxRaw = String(($("extractContextLines") && $("extractContextLines").value) || "25").trim();
    const mxmRaw = String(($("extractMaxMatches") && $("extractMaxMatches").value) || "50").trim();

    /* 追加した処理: 「抽出したコード以外は一切表示しない」厳格モード（メタ/ログ/フェンスも禁止） */
    const codeOnly = !!(($("extractCodeOnly") && $("extractCodeOnly").checked) ? true : false);

    const symbols = sym ? sym.split(",").map(s => String(s).trim()).filter(s => s) : [];
    const needles = ndl ? ndl.split(",").map(s => String(s)).filter(s => s !== "") : [];

    const context_lines = ctxRaw ? Number(ctxRaw) : 25;
    const max_matches = mxmRaw ? Number(mxmRaw) : 50;

    const text = await f.text();

    const payload = {
      filename: f.name,
      content: text,
      symbols: symbols,
      needles: needles,
      context_lines: context_lines,
      max_matches: max_matches
    };

    setStatus("抽出中...");
    $("run").disabled = true;
    if ($("runExtract")) $("runExtract").disabled = true;

    try {
      const res = await fetch("/api/extract", {
        method: "POST",
        headers: { "Content-Type": "application/json; charset=utf-8" },
        body: JSON.stringify(payload)
      });

      $("run").disabled = false;
      if ($("runExtract")) $("runExtract").disabled = false;

      if (!res.ok) {
        const t = await res.text();
        setStatus("抽出エラー: " + t);
        return;
      }

      const data = await res.json();
      if (!data || !data.ok) {
        setStatus("抽出失敗: " + String((data && data.error) || "unknown"));
        return;
      }

      /* 追加した処理: 抽出成功時点で「コピー」と「リセット」を有効化する */
      if ($("copyExtract")) $("copyExtract").disabled = false;
      if ($("resetExtract")) $("resetExtract").disabled = false;

      /* 追加した処理: コードブロック先頭の空行だけを除去し、```javascript の直後が必ず実コード行になるようにする */
      function trimLeadingBlankLinesForFence(codeText) {
        const s = String(codeText || "");
        return s.replace(/^\n+/, "");
      }

      const outLines = [];

      /* 追加した処理:
         codeOnly=ON のときは「抽出コード以外は一切表示しない」ため、ヘッダ行の生成自体をスキップする */
      if (!codeOnly) {
        outLines.push("<<<EXTRACT_BEGIN>>>");
        outLines.push("FILE: " + String(data.filename || ""));
        outLines.push("SYMBOLS: " + String((data.symbols || []).join(", ")));
        outLines.push("NEEDLES: " + String((data.needles || []).join(", ")));

        /* 追加した処理: split直後の result.session_id を extractヘッダへ必ず出す（手入力/コピペも可） */
        outLines.push("SESSION_ID: " + String((($("extractSessionId") && $("extractSessionId").value) || "")).trim());

        /* 追加した処理: split直後の instruction 原文（EXEC_TASK）を extractヘッダへ必ず出す
           ※ ヘッダを1行=1項目で崩さないため、改行は \\n にエスケープして1行化する */
        (function(){
          const raw = String((($("extractExecTask") && $("extractExecTask").value) || ""));
          const one = raw.replace(/\r\n/g, "\n").replace(/\n/g, "\\n");
          outLines.push("EXEC_TASK: " + one);
        })();

        /* 追加した処理: “抽出の目的”を1行で明示（LLMの判断がブレにくくなる） */
        outLines.push("PURPOSE: " + String((($("extractPurpose") && $("extractPurpose").value) || "")).trim());

        /* 追加した処理: 依存の“存在だけ”をメタで列挙（中身不要 / 推測を減らす） */
        outLines.push("DEPENDS: " + String((($("extractDepends") && $("extractDepends").value) || "")).trim());

        outLines.push("");
      }

      /* 追加した処理: 「FOUND:true（コピー対象）」テキストから、コードフェンス内部だけを抽出して連結する */
      function extractOnlyCodeBlocks(foundText) {
        const s = String(foundText || "");
        const lines = s.split("\n");

        const blocks = [];
        let inFence = false;
        let cur = [];

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];

          // ```lang または ``` でトグル（langは不問）
          if (/^\s*```/.test(line)) {
            if (!inFence) {
              inFence = true;
              cur = [];
            } else {
              inFence = false;
              const body = cur.join("\n").replace(/^\n+/, "").replace(/\n+$/, "");
              if (body.trim() !== "") blocks.push(body);
              cur = [];
            }
            continue;
          }

          if (inFence) {
            cur.push(line);
          }
        }

        return blocks.join("\n\n");
      }

      /* 追加した処理: 出力テキストを後処理で「FOUND:true（コピー対象）」と
         「FOUND:false（コピー対象外ログ）」に振り分ける（data構造に依存しない） */
      function splitExtractTextByFoundFlags(fullText) {
        const s = String(fullText || "");
        const lines = s.split("\n");

        const keep = [];      // textarea（コピー対象）
        const nf = [];        // textarea外ログ（コピー対象外）

        // textarea 側に「絶対に残さない」行（FOUND:false / HEADER:not found）
        function stripForbiddenLines(blockText) {
          const t = String(blockText || "");
          return t
            .replace(/^\s*FOUND:\s*false\b.*$/gmi, "")
            .replace(/^\s*HEADER:\s*not\s+found\b.*$/gmi, "")
            .replace(/\n{3,}/g, "\n\n")
            .trimEnd();
        }

        // ブロック単位： "【...】" で開始する塊をひとまず作る
        let cur = [];
        function flush() {
          if (!cur.length) return;

          const blockText = cur.join("\n");

          // ★ 追加した処理:
          // textarea に出したくない判定を FOUND:false だけに限定せず、
          // HEADER:not found も同様に “コピー対象外ログ” へ退避する
          const hasFoundFalse = /\nFOUND:\s*false\b/i.test("\n" + blockText);
          const hasHeaderNotFound = /\nHEADER:\s*not\s+found\b/i.test("\n" + blockText);

          // FOUND:true があっても「禁則行」は textarea に残さない（= strip は必ず通す）
          const cleaned = stripForbiddenLines(blockText);

          if (hasFoundFalse || hasHeaderNotFound) {
            // ★ 追加した処理: コピー対象外ログにも、見やすさのため禁則行除去後を入れる
            // （FOUND:false/HEADER:not found 自体を見せたくない運用なら、ここも同様に消える）
            if (cleaned.trim()) nf.push(cleaned);
          } else {
            // ★ 追加した処理: textarea 側も必ず禁則行を除去してから入れる（残留を物理的に防ぐ）
            if (cleaned.trim()) keep.push(cleaned);
          }

          cur = [];
        }

        for (let i = 0; i < lines.length; i++) {
          const ln = lines[i];

          // "【" から始まる行をブロック境界として扱う（今の出力形式と一致）
          if (ln.startsWith("【") && cur.length > 0) {
            flush();
          }
          cur.push(ln);
        }
        flush();

        // ★ 追加した処理: keep 側全体にも最終防波堤を掛けて、混入を “絶対” に潰す
        const keepTextFinal = stripForbiddenLines(keep.join("\n"));

        return {
          keepText: keepTextFinal,
          notFoundText: nf.join("\n").trim()
        };
      }

      const blocks = data.blocks || [];
      for (let i = 0; i < blocks.length; i++) {
        const b = blocks[i] || {};
        if (b.kind === "function_whole") {
          outLines.push("【FUNCTION_WHOLE】 " + String(b.name || ""));
          outLines.push("FOUND: " + String(!!b.found));
          outLines.push("HEADER: " + String(b.header || ""));
          outLines.push("SHA256: " + String(b.sha256 || ""));
          outLines.push("```javascript");
          outLines.push(trimLeadingBlankLinesForFence(b.text));
          outLines.push("```");
          outLines.push("");
          continue;
        }

        if (b.kind === "context") {
          outLines.push("【CONTEXT】 " + String(b.needle || ""));
          outLines.push("HITS: " + String(b.hit_count || 0));
          outLines.push("LINES: ±" + String(b.context_lines || 0));
          outLines.push("MAX_MATCHES: " + String(b.max_matches || 0));
          outLines.push("");

          const items = b.items || [];
          for (let k = 0; k < items.length; k++) {
            const it = items[k] || {};
            outLines.push("HEADER: " + String(it.header || ""));
            outLines.push("SHA256: " + String(it.sha256 || ""));
            outLines.push("```javascript");
            outLines.push(trimLeadingBlankLinesForFence(it.text));
            outLines.push("```");
            outLines.push("");
          }
        }
      }

      outLines.push("<<<EXTRACT_END>>>");

      // ============================================================
      // ★ 追加: FOUND:false / HEADER:not found をコピー対象から除外する
      // ------------------------------------------------------------
      // - textarea（コピー対象）: FOUND:true のみ
      // - textarea外ログ         : FOUND:false / HEADER:not found のみ
      // ============================================================
      const __fullOutText = outLines.join("\n");
      const __split = splitExtractTextByFoundFlags(__fullOutText);

      // textarea（コピー対象）は FOUND:true だけ（+ 先頭メタ部は維持）
      lastExtractText = __split.keepText;

      /* 追加した処理: 抽出結果は専用textareaへ表示（splitの「現在のパート」カードは触らない） */
      const ex = $("extractPreview");
      if (ex) {
        ex.value = lastExtractText;
        try { ex.scrollTop = 0; } catch (e) {}
      }

      // FOUND:false / HEADER:not found は textarea 外に“小ログ”として表示（コピー対象外）
      const nfEl = $("extractNotFoundLog");
      if (nfEl) {
        const t = String(__split.notFoundText || "").trim();
        if (t) {
          nfEl.textContent = "FOUND: false（コピー対象外ログ）\n" + t;
        } else {
          nfEl.textContent = "";
        }
      }

      const btnCopyExtract = $("copyExtract");
      if (btnCopyExtract) {
        btnCopyExtract.disabled = !String(lastExtractText || "").trim();
      }

      setStatus("抽出完了（FOUND:false はコピー対象外ログへ分離しました）。「抽出結果をコピー」でそのまま貼れます。");
    } catch (e) {
      $("run").disabled = false;
      if ($("runExtract")) $("runExtract").disabled = false;
      setStatus("抽出例外: " + String(e));
    }
  }

  if ($("runExtract")) {
    $("runExtract").onclick = doExtract;
  }

  $("copyCurrent").onclick = copyCurrent;
  $("copyNext").onclick = copyNext;

  async function copyExtract() {
    const btn = $("copyExtract");
    try {
      const text = String(lastExtractText || "");
      if (!text.trim()) {
        flashButton(btn, "ng");
        setStatus("抽出結果が空です（先に「抽出（extract）」を実行してください）");
        return;
      }

      await navigator.clipboard.writeText(text);
      flashButton(btn, "ok");

      const old = btn.textContent;
      btn.textContent = "Copied ✓";
      window.setTimeout(() => (btn.textContent = old), 650);

      setStatus("抽出結果をコピーしました（<<<EXTRACT_BEGIN>>> から全部）");
    } catch (e) {
      flashButton(btn, "ng");
      setStatus("抽出結果コピー失敗（ブラウザ権限/HTTPS制約の可能性）: " + String(e));
    }
  }

  if ($("copyExtract")) {
    $("copyExtract").onclick = copyExtract;
  }

  if ($("instruction")) {
    $("instruction").addEventListener("input", () => {
      autosizeInstruction();
      saveUiState();
    });
  }

  if ($("toggleAll")) {
    $("toggleAll").onclick = () => {
      previewAllOn = !previewAllOn;
      updateToggleAllButton();
      renderCurrent();
      saveUiState();
    };
  }
  
  if ($("prefix")) {
    $("prefix").addEventListener("input", () => {
      saveUiState();
    });
  }

  if ($("lang")) {
    $("lang").addEventListener("change", () => {
      saveUiState();
    });
  }

  if ($("maxchars")) {
    $("maxchars").addEventListener("input", () => {
      saveUiState();
    });
  }

  if ($("maxlines")) {
    $("maxlines").addEventListener("input", () => {
      saveUiState();
    });
  }

  if ($("maxlogs")) {
    $("maxlogs").addEventListener("input", () => {
      saveUiState();
    });
  }

  (function(){
    const hidden = $("splitMode");
    const radios = document.querySelectorAll('input[name="splitModeRadio"]');

    if (radios && radios.length > 0) {
      for (let i = 0; i < radios.length; i++) {
        const r = radios[i];
        r.addEventListener("change", () => {
          if (!r.checked) return;

          const v = String(r.value || "C");
          if (hidden) {
            hidden.value = v;
          }
          saveUiState();
        });
      }
    }
  })();

  if ($("file")) {
    $("file").addEventListener("change", async () => {
      const f = $("file").files && $("file").files[0] ? $("file").files[0] : null;
      if (!f) return;
      runSyntaxCheckForFile(f);
    });
  }

  if ($("resetGen")) {
    $("resetGen").onclick = resetGeneratedOnly;
    $("resetGen").disabled = true;
  }

  if ($("histClear")) {
    $("histClear").disabled = true;
  }

  restoreUiState();
  applyUIMode(window.__uiMode || "split");

  (function(){
    const hidden = $("splitMode");
    const v = String(hidden && hidden.value ? hidden.value : "C");
    const radios = document.querySelectorAll('input[name="splitModeRadio"]');
    for (let i = 0; i < radios.length; i++) {
      const r = radios[i];
      const rv = String(r && r.value ? r.value : "");
      r.checked = (rv === v);
    }
  })();

  autosizeInstruction();
  updateToggleAllButton();
  renderCurrent();
  renderInstructionHistory();
  saveUiState();

  /* 初期表示では status を出さない（ファイル未選択時の非表示） */
  setStatus("");
  
  window.addEventListener("resize", () => {
    try {
      const box = $("instructionHistory");
      if (!box) return;

      const cards = box.querySelectorAll(".card");
      for (let i = 0; i < cards.length; i++) {
        const c = cards[i];
        const pre = c.querySelector("pre");
        if (!pre) continue;

        /* 元の全文 instruction は pre の dataset に保持しておく */
        const raw = pre.dataset && typeof pre.dataset.fullInstruction === "string"
          ? pre.dataset.fullInstruction
          : null;

        if (raw !== null) {
          pre.textContent = buildHistoryPreviewText(raw, pre);
        }
      }
    } catch (e) {}
  });

  /* 初期表示では status を出さない（ファイル未選択時の非表示） */
  setStatus("");

  // ============================================================
  // textarea 高さリサイズ（広いハンドルでドラッグできるようにする）
  // ------------------------------------------------------------
  // 使い方:
  //   <div class="ta-resize-wrap" data-target="TEXTAREA_ID">
  //     <textarea id="TEXTAREA_ID"></textarea>
  //     <div class="ta-resize-handle"></div>
  //     <div class="ta-resize-hint">...</div>
  //   </div>
  // ============================================================
  (function () {
    "use strict";

    function setupResizeWrap(wrap) {
      var targetId = wrap.getAttribute("data-target");
      var ta = document.getElementById(targetId);
      var handle = wrap.querySelector(".ta-resize-handle");
      if (!ta || !handle) return;

      var startY = 0;
      var startH = 0;
      var active = false;

      function onMove(e) {
        if (!active) return;
        var clientY = (e.touches && e.touches[0]) ? e.touches[0].clientY : e.clientY;
        var dy = clientY - startY;
        var next = Math.max(80, startH + dy); /* 最小高さ 80px */
        ta.style.height = String(next) + "px";
        e.preventDefault();
      }

      function onUp() {
        if (!active) return;
        active = false;
        wrap.classList.remove("is-resizing");
        document.removeEventListener("mousemove", onMove, { passive: false });
        document.removeEventListener("mouseup", onUp);
        document.removeEventListener("touchmove", onMove, { passive: false });
        document.removeEventListener("touchend", onUp);
      }

      function onDown(e) {
        active = true;
        wrap.classList.add("is-resizing");
        startY = (e.touches && e.touches[0]) ? e.touches[0].clientY : e.clientY;

        var rect = ta.getBoundingClientRect();
        var computed = window.getComputedStyle(ta);
        var h = rect.height;
        if (computed && computed.height) {
          var parsed = parseFloat(computed.height);
          if (!Number.isNaN(parsed)) h = parsed;
        }
        startH = h;

        document.addEventListener("mousemove", onMove, { passive: false });
        document.addEventListener("mouseup", onUp);
        document.addEventListener("touchmove", onMove, { passive: false });
        document.addEventListener("touchend", onUp);

        e.preventDefault();
      }

      handle.addEventListener("mousedown", onDown);
      handle.addEventListener("touchstart", onDown, { passive: false });
    }

    function init() {
      var wraps = document.querySelectorAll(".ta-resize-wrap[data-target]");
      for (var i = 0; i < wraps.length; i++) setupResizeWrap(wraps[i]);
    }

    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", init);
    } else {
      init();
    }
  })();

  window.addEventListener("resize", () => {
    try {
      const box = $("instructionHistory");
      if (!box) return;

      const cards = box.querySelectorAll(".card");
      for (let i = 0; i < cards.length; i++) {
        const c = cards[i];
        const pre = c.querySelector("pre");
        if (!pre) continue;

        /* 元の全文 instruction は pre の dataset に保持しておく */
        const raw = pre.dataset && typeof pre.dataset.fullInstruction === "string"
          ? pre.dataset.fullInstruction
          : null;

        if (raw !== null) {
          pre.textContent = buildHistoryPreviewText(raw, pre);
        }
      }
    } catch (e) {}
  });  

  
</script>
</body>
</html>