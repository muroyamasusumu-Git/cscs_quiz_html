<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1">
<meta name="cscs-qid" content="20251012-023">
  <meta charset="utf-8">
  <style>
html, body {
  margin: 0;
  padding: 0;
  background: #111;
  color: #fff;
  width: 100%;
  height: 100%;
}

.wrap {
  margin: 40px auto;
  font-family: -apple-system, BlinkMacSystemFont,
               "Hiragino Kaku Gothic ProN", "Yu Gothic", "Meiryo", sans-serif;
  line-height: 1.5;
  font-size: 32px;
}


.top-title  { opacity:.95; color:#fff; }
.top-date   { color:#a8b0b8; opacity:.95; }
.top-number { color:#c9c9c9; }
.top-level  { color:#a8a8a8; }
.crumb-field{font-size:26px;font-weight:400}
.crumb-sep{opacity:.6}
.crumb-theme{font-size:22px;opacity:.85}

/* ヘッダー部（左右ブロック＋右端日付） */
.topmeta {
  display: flex;
  justify-content: space-between;  /* 左右を分ける */
  align-items: center;
  gap: 16px;
  font-size: 24px;
  font-weight: 500;
  color: rgba(255, 255, 255, 0.7);
  opacity: 0.85;
  margin-bottom: 6px;
  flex-wrap: wrap;
}

/* 左ブロック（タイトル／番号／レベル） */
.topmeta-left {
  display: flex;
  flex-wrap: wrap;
  gap: 14px;
  align-items: center;
}

/* 右ブロック（日付だけ右端に寄せる） */
.topmeta-right {
  margin-left: auto;
  text-align: right;
  white-space: nowrap;
}

.qno {
  font-size: 20px;
  opacity: .9;
  margin: 6px 0 2px;
}

/* 問題文 */
h1 {
  font-size: 44px;
  margin: 10px 0 10px;
  color: #66d9ff;     /* 明るい水色 */
  line-height: 1.10;  /* タイトに */
  overflow-wrap: anywhere;
  word-break: break-word;
}

/* 選択肢 */
.opts {
  padding-left: 1.1em;
  margin-left: 15px;
  margin-top: 0;
}

ol.opts {
    margin-bottom: 20px;
}

.opts li {
  margin-top: 2px;
  margin-bottom: 2px;
}

/* 区切り線 */
.hr {
  height: 1px;
  background: #444;
  margin: 0 0 8px;
}

/* 正解 */
.answer { margin-top: 12px; font-weight: 600; }
.answer { word-break: break-word; }
.answer {
  font-size: 40px;
  margin-top: 0;
  margin-left: 0;
  color: #fff34d;  /* 明るい黄色 */
}

/* Bパートの「正解: A　本　文」の“本文”だけ少し小さく */
.answer .opt-small {
  font-size: 0.85em;   /* ← ほんの少し小さく（0.85〜0.95で調整） */
  line-height: 1.25;  /* 任意：行間を少し詰める */
  opacity: 0.95;      /* 任意：わずかに落として主役のAを強調 */
  margin-left: 10px;
}

/* 解説 */
.explain {
  font-size: 16px;
  margin-top: 4px;
  margin-left: 0;
  opacity: .92;
  white-space: pre-wrap;
}

/* ヒント（B未表示段階） */
.hint {
  font-size: 22px;
  opacity: .6;
  margin-top: 0;
  margin-left: 0;
}
  







</style>

<script src="../../assets/correct_star.js" defer></script>


<script src="../../assets/cscs_fade_overlay.js" defer></script>


<script src="../../assets/b_judge.js" data-stem="q023" data-audio-base="/_build_cscs_20251012/audio" data-ext=".wav"></script>


<script src="../../assets/backfill_suppress.js"></script>
<script src="../../assets/b_judge_record.js" defer></script>


<link rel="stylesheet" href="../../assets/wrong_badge.css">
<script src="../../assets/wrong_badge.js" defer></script>


<link rel="stylesheet" href="../../assets/fav_modal.css">
<script src="../../assets/fav_modal.js" defer></script>


<link rel="stylesheet" href="../../assets/deep_dive.css">
<script src="../../assets/deep_dive.js" data-mode="dynamic" data-autoload="1" defer></script>
<script>window.DeepDive&&typeof window.DeepDive.init==="function"&&window.DeepDive.init({mode:"dynamic"});</script>
<script src="../../assets/deep_dive_inline.js" defer></script>


<script src="../../assets/consistency_check_debug.js" data-part="b" defer></script>


<script src="../../assets/a_auto_next.js" defer></script>

<script src="../../assets/next_nav.js" data-next="q024_a.html" defer></script>

<style>
/* 全ページ強制：html/body の高さ指定を解除 */
html, body { height: auto !important; min-height: 0 !important; }
</style>


<link rel="stylesheet" href="../../assets/main.css">




<style>
/* 後から --h1-lh で自由に変更可（既定は normal） */
h1 { line-height: var(--h1-lh, normal); }
</style>


<style>
/* 後から --h1-fs で自由に変更可（既定は inherit。UA既定や main.css が決める） */
h1 { font-size: var(--h1-fs, inherit); }
</style>


<script src="../../assets/correct_star.js" defer></script>


<style>
/* 不正解表示一帯のインラインstyleを後勝ちで無力化。値はCSS変数を参照し、main.cssで定義する */
#judge span[style*="font-size"] { font-size: var(--judge-choice-fs, 0.95em) !important; }
#judge span[style*="color"] { color: var(--judge-dim-color, #c9c9c9) !important; }
/* ここでは --judge-choice-fs / --judge-dim-color を再定義しない（main.cssで指定する） */
</style>

<!-- JUDGE_OVERRIDE_CSS_APPLIED -->

<style></style>

<!-- B_CORRECT_UNDERLINE_APPLIED -->

<script src="../../assets/b_correct_mark.js" defer></script>

</head>
<body class="mode-b">
<div id="root">
  <div class="wrap">
    <div class='topmeta'><div class='topmeta-left'><div class='top-title'>NSCA CSCS 問題集 (17/90)</div><div class='top-number'>番号: <span class='top-number-val'>23/30</span></div><div class='top-level'>Lv 4</div></div><div class='topmeta-right'></div></div>
    <div class='qno'><span class="correct_star">⭐️</span><span class="consistency_status">◎</span><span class="top-date">2025年10月12日</span><span class='crumb-field'>栄養学</span><span class='crumb-sep'> ＞ </span><span class='crumb-theme'>食事タイミング</span></div>
    <h1 style="">持久運動前に推奨される食事内容はどれか？</h1>
    <ol class='opts' type='A'><li>高脂肪食</li><li>高繊維食</li><li class="is-correct">高炭水化物食</li><li>高タンパク食</li></ol>
    <div id="judge" class="answer" aria-live="polite"></div>
    <div class='hr'></div><div class='answer'>正解: C<span class='opt-small'>高炭水化物食</span></div><div class='explain'><span class="explain-text">運動2〜3時間前に炭水化物中心の食事を摂取することで、グリコーゲン貯蔵を最大化できる。</span></div>
    <!-- <div class="footer">（このスライドは自動生成です）</div> -->
  </div>
<script type="application/json" id="cscs-meta">{"qid": "2025年10月12日-023", "field": "栄養学", "theme": "食事タイミング", "level": "Level 4", "date": "2025年10月12日", "number": "23", "quiztype": "単一分野", "tags": {"cause": "運動前炭水化物摂取", "process": "グリコーゲン貯蔵増加", "outcome": "持久力向上"}}</script>

<script>
(function(){
  // Bページの URL から qid = "YYYYMMDD-NNN" を取得
  function detectInfo(){
    const m = location.pathname.match(/_build_cscs_(\d{8})\/slides\/q(\d{3})_b/);
    if (!m) return null;
    const day = m[1];       // 例: "20250926"
    const n3  = m[2];       // 例: "001"
    const qid = `${day}-${n3}`;
    return { day, n3, qid };
  }

  const info = detectInfo();
  if (!info) return;

  // b_judge_record.js が管理している「本物の累積キー」
  const KEY_COR        = `cscs_q_correct_total:${info.qid}`;
  const KEY_WRG        = `cscs_q_wrong_total:${info.qid}`;
  const KEY_S3         = `cscs_q_correct_streak3_total:${info.qid}`;
  const KEY_STREAK_LEN = `cscs_q_correct_streak_len:${info.qid}`;

  // B側だけで使う「最後に SYNC 済みだったときの累積値」
  const KEY_LAST_COR = `cscs_sync_last_c:${info.qid}`;
  const KEY_LAST_WRG = `cscs_sync_last_w:${info.qid}`;
  const KEY_LAST_S3  = `cscs_sync_last_s3:${info.qid}`;

  function loadInt(key){
    const v = localStorage.getItem(key);
    if (v == null) return 0;
    const n = parseInt(v, 10);
    return Number.isFinite(n) ? n : 0;
  }

  function saveInt(key, value){
    localStorage.setItem(key, String(value));
  }

  // 今日の「新規⭐️」メタ情報を localStorage から読み出すヘルパー
  function loadStreak3TodayMeta(){
    var dayKey   = "cscs_streak3_today_day";
    var qidsKey  = "cscs_streak3_today_qids";
    var countKey = "cscs_streak3_today_unique_count";

    var day = "";
    try {
      day = localStorage.getItem(dayKey) || "";
    } catch (_e) {
      day = "";
    }

    var count = 0;
    try {
      var rawCount = localStorage.getItem(countKey);
      var n = parseInt(rawCount || "0", 10);
      count = Number.isFinite(n) && n >= 0 ? n : 0;
    } catch (_e) {
      count = 0;
    }

    var qids = [];
    try {
      var rawQids = localStorage.getItem(qidsKey);
      qids = JSON.parse(rawQids || "[]");
      if (!Array.isArray(qids)) {
        qids = [];
      }
    } catch (_e) {
      qids = [];
    }

    // count と配列長がズレていたら、配列長を優先
    if (qids.length > 0 && count !== qids.length) {
      count = qids.length;
    }

    return {
      day: day,
      count: count,
      qids: qids
    };
  }

  async function syncFromTotals(){
    // 1) 現在の累積（b_judge_record.js が書いた値）
    const cNow        = loadInt(KEY_COR);
    const wNow        = loadInt(KEY_WRG);
    const s3Now       = loadInt(KEY_S3);
    const streakLenNow = loadInt(KEY_STREAK_LEN);

    // 2) 前回 SYNC 時点の値（存在しなければ 0 扱い）
    const cLast  = loadInt(KEY_LAST_COR);
    const wLast  = loadInt(KEY_LAST_WRG);
    let s3Last = loadInt(KEY_LAST_S3);

    // local が s3Last より小さい場合 → s3Last を local に強制修正
    if (s3Last > s3Now) {
    console.warn("[SYNC/B] 修正: s3Last が local より大きかったため補正しました");
    s3Last = s3Now;
    saveInt(KEY_LAST_S3, s3Last);
    }

    // 3) 差分（マイナスは送らない）
    const dc  = Math.max(0, cNow  - cLast);
    const dw  = Math.max(0, wNow  - wLast);
    const ds3 = Math.max(0, s3Now - s3Last);

    // streakLenNow が 0 でも「リセットとして送る」ケースがあるので条件に含めない
    if (!dc && !dw && !ds3 && streakLenNow === 0) return;

    // 4) /api/sync/merge へ「差分だけ」を送信（Aパートと同じ Delta 形式）
    const todayMeta = loadStreak3TodayMeta();

    const payload = {
      correctDelta:   dc  > 0 ? { [info.qid]: dc  } : {},
      incorrectDelta: dw  > 0 ? { [info.qid]: dw  } : {},
      streak3Delta:   ds3 > 0 ? { [info.qid]: ds3 } : {},
      streakLenDelta: { [info.qid]: streakLenNow },
      updatedAt: Date.now()
    };

    // ★ 今日ぶんのユニーク⭐️数が更新された場合だけ送る
    if (ds3 > 0 && todayMeta.day) {
      payload.streak3Today = {
        day: todayMeta.day,
        unique_q_count: todayMeta.count
      };
    }

    console.log("[SYNC/B] streak3 merge payload", {
      qid: info.qid,
      cNow,
      wNow,
      s3Now,
      streakLenNow,
      cLast,
      wLast,
      s3Last,
      dc,
      dw,
      ds3,
      payload
    });

    try{
      const res = await fetch("/api/sync/merge", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(payload)
      });
      if (!res.ok) throw new Error(res.status);

      // 5) 成功したら「今回送信後の累積値」を保存して次回差分の基準にする
      if (dc)  saveInt(KEY_LAST_COR, cNow);
      if (dw)  saveInt(KEY_LAST_WRG, wNow);
      if (ds3) saveInt(KEY_LAST_S3,  s3Now);
    }catch(e){
      console.warn("[SYNC/B] merge failed", e);
    }
  }

  // b_judge_record.js の集計が終わったタイミングに近づけるため、
  // DOM 完成後に 1 tick 遅らせて実行
  function schedule(){
    if (document.readyState === "loading") {
      window.addEventListener("DOMContentLoaded", function(){
        setTimeout(syncFromTotals, 0);
      });
    } else {
      setTimeout(syncFromTotals, 0);
    }
  }

  function showStreakStatus(){
    const localTotal  = loadInt(KEY_S3);
    const syncedTotal = loadInt(KEY_LAST_S3);

    console.log("== Bパート: 3連続正解 SYNC ステータス ==");
    console.log("qid:", info.qid);
    console.log("localStorage[KEY_S3] =", localStorage.getItem(KEY_S3), "→", localTotal);
    console.log("localStorage[KEY_LAST_S3] =", localStorage.getItem(KEY_LAST_S3), "→", syncedTotal);

    if (localTotal === 0 && syncedTotal === 0) {
      console.log("ℹ まだこの問題では 3回連続正解が発生していません。");
    } else if (localTotal === syncedTotal) {
      console.log(`✅ 3連続正解回数: SYNC ${syncedTotal} 回 / local ${localTotal} 回（完全一致）です。`);
    } else if (syncedTotal < localTotal) {
      console.warn(
        "⚠ 同期待ちの 3連続正解があります。",
        "SYNC 側 =", syncedTotal, "/ local 側 =", localTotal,
        "（次回の Bパート遷移時に追加送信される可能性があります。）"
      );
    } else {
      console.error(
        "✕ 異常: SYNC 側の 3連続正解回数の方が大きくなっています (SYNC > local)。",
        "SYNC 側 =", syncedTotal, "/ local 側 =", localTotal,
        "一度リセットしてから再テストした方が良いかもしれません。"
      );
    }

    console.log("== Bパート: 3連続正解 SYNC ステータス終了 ==");
  }

  schedule();
  showStreakStatus();
})();
</script>


  <!-- 左下の [次の問題へ] ボタン -->
  <a class="back-to-top" href="q024_a.html" title="次の問題へ">［次の問題へ］</a>


  <!-- A専用：問題一覧（2カラム） -->
  <link rel="stylesheet" href="../../assets/nav_list.css">
  <script src="../../assets/nav_list.js" data-a-nav="1"></script>

</div>
<script>
(function () {
  "use strict";

  var SYNC_STATE_ENDPOINT = "/api/sync/state";
  var SYNC_MERGE_ENDPOINT = "/api/sync/merge";

  function detectInfo() {
    var path = window.location.pathname || "";
    var m = path.match(/_build_cscs_(\d{8})\/slides\/q(\d{3})_b(?:\.html)?$/);
    if (!m) return null;
    var day = m[1];
    var num3 = m[2];
    var qid = day + "-" + num3;
    return { day: day, num3: num3, qid: qid };
  }

  var info = detectInfo();
  if (!info) {
    return;
  }

  function readIntFromLocalStorage(key) {
    try {
      var raw = window.localStorage.getItem(key);
      if (raw === null || raw === undefined) {
        return 0;
      }
      var n = parseInt(raw, 10);
      if (!Number.isFinite(n) || n < 0) {
        return 0;
      }
      return n;
    } catch (e) {
      console.error("[SYNC-B:view] failed to read int from localStorage:", key, e);
      return 0;
    }
  }

  // cscs_sync_view_b_body にテキストをセットするヘルパー
  // "server 0 / 0\nlocal 17 / 2\ndiff 0 / 0\nstatus: error ..."
  // みたいな文字列を行ごとに <div> に分割して縦に並べる
  function updateSyncBody(text) {
    var body = document.getElementById("cscs_sync_view_b_body");
    if (!body) {
      return;
    }

    // 既存の子要素を全部消す
    while (body.firstChild) {
      body.removeChild(body.firstChild);
    }

    // text を行ごとに分解して <div> に入れる
    var lines = String(text).split(/\n/);
    for (var i = 0; i < lines.length; i++) {
      var line = lines[i];

      // 空行はスキップ（必要なら削除してOK）
      if (!line.trim()) {
        continue;
      }

      var lineDiv = document.createElement("div");
      lineDiv.textContent = line;
      body.appendChild(lineDiv);
    }
  }

  function fetchState() {
    return fetch(SYNC_STATE_ENDPOINT, { method: "GET" }).then(function (res) {
      if (!res.ok) {
        throw new Error(String(res.status));
      }
      return res.json();
    });
  }

  function createPanel() {
    var box = document.createElement("div");
    box.id = "cscs_sync_view_b";

    var title = document.createElement("div");
    title.id = "cscs_sync_view_b_title";
    title.textContent = "SYNC(B): " + info.qid;

    var body = document.createElement("div");
    body.id = "cscs_sync_view_b_body";

    // 初期表示は1行だけなので textContent でOK
    body.textContent = "読み込み中…";

    // statusText を個別に表示する領域
    var statusDiv = document.createElement("div");
    statusDiv.id = "cscs_sync_view_b_status";

    var btn = document.createElement("button");
    btn.id = "cscs_sync_view_b_send_btn";
    btn.type = "button";
    btn.textContent = "SYNC送信";

    box.appendChild(title);
    box.appendChild(body);
    box.appendChild(statusDiv);
    box.appendChild(btn);
    return box;
  }


  function renderPanel(box, payload) {
    try {
      var serverCorrect = payload.serverCorrect || 0;
      var serverWrong = payload.serverWrong || 0;
      var localCorrect = payload.localCorrect || 0;
      var localWrong = payload.localWrong || 0;
      var diffCorrect = payload.diffCorrect || 0;
      var diffWrong = payload.diffWrong || 0;

      var serverStreak3 = payload.serverStreak3 || 0;
      var localStreak3 = payload.localStreak3 || 0;
      var diffStreak3 = payload.diffStreak3 || 0;

      var serverStreakLen = payload.serverStreakLen || 0;
      var localStreakLen = payload.localStreakLen || 0;
      var diffStreakLen = payload.diffStreakLen || 0;

      var statusText = payload.statusText || "";

      // 進捗用: 3連続に対する現在の連続正解長の位置 (0〜2)
      var serverProgress = serverStreakLen % 3;
      var localProgress = localStreakLen % 3;

      var text = "";
      text += "server " + serverCorrect + " / " + serverWrong + "\n";
      text += "local  " + localCorrect + " / " + localWrong + "\n";
      text += "diff   " + diffCorrect + " / " + diffWrong + "\n";
      text += "s3     " + serverStreak3 + " / " + localStreak3 + " (+" + diffStreak3 + ")\n";
      text += "sLen   " + serverStreakLen + " / " + localStreakLen + " (+" + diffStreakLen + ")\n";
      text += "3連続正解回数 (進捗):\n";
      text += "SYNC " + serverStreak3 + " (" + serverProgress + "/3) / local " + localStreak3 + " (" + localProgress + "/3)";

      // server/local/diff/s3/sLen はボディ側に縦並び表示
      updateSyncBody(text);

      // statusText は個別の <div> に分離して表示
      var statusDiv = document.getElementById("cscs_sync_view_b_status");
      if (statusDiv) {
        if (statusText) {
          statusDiv.textContent = "status: " + statusText;
        } else {
          statusDiv.textContent = "";
        }
      }
    } catch (e) {
      // エラー時も同じくヘルパーで表示＋status もエラー表示
      var errorText = "SYNC(B) " + info.qid + "  error: " + (e && e.message ? e.message : e);
      updateSyncBody(errorText);

      var statusDiv = document.getElementById("cscs_sync_view_b_status");
      if (statusDiv) {
        statusDiv.textContent = "status: error";
      }
    }
  }

  async function sendDiffToServer(box, params) {
    var qid = info.qid;
    var diffCorrect = params.diffCorrect;
    var diffWrong = params.diffWrong;
    var diffStreak3 = params.diffStreak3 || 0;
    var diffStreakLen = params.diffStreakLen || 0;

    var localCorrect = params.localCorrect;
    var localWrong = params.localWrong;
    var localStreak3 = params.localStreak3 || 0;
    var localStreakLen = params.localStreakLen || 0;

    var serverCorrect = params.serverCorrect;
    var serverWrong = params.serverWrong;
    var serverStreak3 = params.serverStreak3 || 0;
    var serverStreakLen = params.serverStreakLen || 0;

    // 差分がなく、かつ streakLen もサーバーと同じなら何もしない（表示だけ更新）
    if (diffCorrect <= 0 && diffWrong <= 0 && diffStreak3 <= 0 && localStreakLen === serverStreakLen) {
      renderPanel(box, {
        serverCorrect: serverCorrect,
        serverWrong: serverWrong,
        localCorrect: localCorrect,
        localWrong: localWrong,
        diffCorrect: diffCorrect,
        diffWrong: diffWrong,
        serverStreak3: serverStreak3,
        localStreak3: localStreak3,
        diffStreak3: diffStreak3,
        serverStreakLen: serverStreakLen,
        localStreakLen: localStreakLen,
        diffStreakLen: diffStreakLen,
        statusText: "no diff"
      });
      return;
    }

    // オフラインなら送信しない
    if (!navigator.onLine) {
      renderPanel(box, {
        serverCorrect: serverCorrect,
        serverWrong: serverWrong,
        localCorrect: localCorrect,
        localWrong: localWrong,
        diffCorrect: diffCorrect,
        diffWrong: diffWrong,
        serverStreak3: serverStreak3,
        localStreak3: localStreak3,
        diffStreak3: diffStreak3,
        serverStreakLen: serverStreakLen,
        localStreakLen: localStreakLen,
        diffStreakLen: diffStreakLen,
        statusText: "offline"
      });
      return;
    }

    // Aパートと同じ Delta 形式で /api/sync/merge に送る
    var correctDeltaObj = {};
    var incorrectDeltaObj = {};
    var streak3DeltaObj = {};
    var streakLenDeltaObj = {};
    if (diffCorrect > 0) {
      correctDeltaObj[qid] = diffCorrect;
    }
    if (diffWrong > 0) {
      incorrectDeltaObj[qid] = diffWrong;
    }
    if (diffStreak3 > 0) {
      streak3DeltaObj[qid] = diffStreak3;
    }
    streakLenDeltaObj[qid] = localStreakLen;

    var payload = {
      correctDelta: correctDeltaObj,
      incorrectDelta: incorrectDeltaObj,
      streak3Delta: streak3DeltaObj,
      streakLenDelta: streakLenDeltaObj,
      updatedAt: Date.now()
    };

    console.log("[SYNC-B] sending diff payload:", payload);

    try {
      var response = await fetch(SYNC_MERGE_ENDPOINT, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(payload),
        keepalive: true
      });

      if (!response.ok) {
        console.error("[SYNC-B] server returned non-ok status:", response.status);
        renderPanel(box, {
          serverCorrect: serverCorrect,
          serverWrong: serverWrong,
          localCorrect: localCorrect,
          localWrong: localWrong,
          diffCorrect: diffCorrect,
          diffWrong: diffWrong,
          serverStreak3: serverStreak3,
          localStreak3: localStreak3,
          diffStreak3: diffStreak3,
          serverStreakLen: serverStreakLen,
          localStreakLen: localStreakLen,
          diffStreakLen: diffStreakLen,
          statusText: "merge " + String(response.status)
        });
        return;
      }

      var data = null;
      try {
        data = await response.json();
      } catch (e) {
        data = null;
      }

      console.log("[SYNC-B] sync success:", data);

      // merge のレスポンスは { correct: {qid: total, ...}, incorrect: {...}, streak3: {...}, streakLen: {...} } 形式を想定
      var newServerCorrect = serverCorrect;
      var newServerWrong = serverWrong;
      var newServerStreak3 = serverStreak3;
      var newServerStreakLen = serverStreakLen;

      if (data && data.correct && typeof data.correct === "object" && data.correct !== null) {
        if (Object.prototype.hasOwnProperty.call(data.correct, qid)) {
          var cVal = data.correct[qid];
          if (typeof cVal === "number" && Number.isFinite(cVal) && cVal >= 0) {
            newServerCorrect = cVal;
          }
        }
      }

      if (data && data.incorrect && typeof data.incorrect === "object" && data.incorrect !== null) {
        if (Object.prototype.hasOwnProperty.call(data.incorrect, qid)) {
          var wVal = data.incorrect[qid];
          if (typeof wVal === "number" && Number.isFinite(wVal) && wVal >= 0) {
            newServerWrong = wVal;
          }
        }
      }

      if (data && data.streak3 && typeof data.streak3 === "object" && data.streak3 !== null) {
        if (Object.prototype.hasOwnProperty.call(data.streak3, qid)) {
          var sVal = data.streak3[qid];
          if (typeof sVal === "number" && Number.isFinite(sVal) && sVal >= 0) {
            newServerStreak3 = sVal;
          }
        }
      }

      if (data && data.streakLen && typeof data.streakLen === "object" && data.streakLen !== null) {
        if (Object.prototype.hasOwnProperty.call(data.streakLen, qid)) {
          var slVal = data.streakLen[qid];
          if (typeof slVal === "number" && Number.isFinite(slVal) && slVal >= 0) {
            newServerStreakLen = slVal;
          }
        }
      }

      var newDiffCorrect = Math.max(0, localCorrect - newServerCorrect);
      var newDiffWrong = Math.max(0, localWrong - newServerWrong);
      var newDiffStreak3 = Math.max(0, localStreak3 - newServerStreak3);
      var newDiffStreakLen = Math.max(0, localStreakLen - newServerStreakLen);

      renderPanel(box, {
        serverCorrect: newServerCorrect,
        serverWrong: newServerWrong,
        localCorrect: localCorrect,
        localWrong: localWrong,
        diffCorrect: newDiffCorrect,
        diffWrong: newDiffWrong,
        serverStreak3: newServerStreak3,
        localStreak3: localStreak3,
        diffStreak3: newDiffStreak3,
        serverStreakLen: newServerStreakLen,
        localStreakLen: localStreakLen,
        diffStreakLen: newDiffStreakLen,
        statusText: "ok"
      });
    } catch (e) {
      console.error("[SYNC-B] fetch failed:", e);
      renderPanel(box, {
        serverCorrect: serverCorrect,
        serverWrong: serverWrong,
        localCorrect: localCorrect,
        localWrong: localWrong,
        diffCorrect: diffCorrect,
        diffWrong: diffWrong,
        serverStreak3: serverStreak3,
        localStreak3: localStreak3,
        diffStreak3: diffStreak3,
        serverStreakLen: serverStreakLen,
        localStreakLen: localStreakLen,
        diffStreakLen: diffStreakLen,
        statusText: "error"
      });
    }
  }

  function refreshAndSend(box) {
    fetchState()
      .then(function (state) {
        var serverCorrect = 0;
        var serverWrong = 0;
        var serverStreak3 = 0;
        var serverStreakLen = 0;

        if (state && state.correct && state.correct[info.qid] != null) {
          serverCorrect = state.correct[info.qid];
        }
        if (state && state.incorrect && state.incorrect[info.qid] != null) {
          serverWrong = state.incorrect[info.qid];
        }
        if (state && state.streak3 && state.streak3[info.qid] != null) {
          serverStreak3 = state.streak3[info.qid];
        }
        if (state && state.streakLen && state.streakLen[info.qid] != null) {
          serverStreakLen = state.streakLen[info.qid];
        }

        var localCorrect = readIntFromLocalStorage("cscs_q_correct_total:" + info.qid);
        var localWrong = readIntFromLocalStorage("cscs_q_wrong_total:" + info.qid);
        var localStreak3 = readIntFromLocalStorage("cscs_q_correct_streak3_total:" + info.qid);
        var localStreakLen = readIntFromLocalStorage("cscs_q_correct_streak_len:" + info.qid);

        // diff は「まだサーバーに反映されていない増分」として扱うので 0 未満にはしない
        var diffCorrect = Math.max(0, localCorrect - serverCorrect);
        var diffWrong = Math.max(0, localWrong - serverWrong);
        var diffStreak3 = Math.max(0, localStreak3 - serverStreak3);
        var diffStreakLen = Math.max(0, localStreakLen - serverStreakLen);

        renderPanel(box, {
          serverCorrect: serverCorrect,
          serverWrong: serverWrong,
          localCorrect: localCorrect,
          localWrong: localWrong,
          diffCorrect: diffCorrect,
          diffWrong: diffWrong,
          serverStreak3: serverStreak3,
          localStreak3: localStreak3,
          diffStreak3: diffStreak3,
          serverStreakLen: serverStreakLen,
          localStreakLen: localStreakLen,
          diffStreakLen: diffStreakLen,
          statusText: "state ok"
        });

        return sendDiffToServer(box, {
          serverCorrect: serverCorrect,
          serverWrong: serverWrong,
          serverStreak3: serverStreak3,
          serverStreakLen: serverStreakLen,
          localCorrect: localCorrect,
          localWrong: localWrong,
          localStreak3: localStreak3,
          localStreakLen: localStreakLen,
          diffCorrect: diffCorrect,
          diffWrong: diffWrong,
          diffStreak3: diffStreak3,
          diffStreakLen: diffStreakLen
        });
      })
      .catch(function (e) {
        console.error("[SYNC-B] state fetch error:", e);
        var localCorrect = readIntFromLocalStorage("cscs_q_correct_total:" + info.qid);
        var localWrong = readIntFromLocalStorage("cscs_q_wrong_total:" + info.qid);
        var localStreak3 = readIntFromLocalStorage("cscs_q_correct_streak3_total:" + info.qid);
        var localStreakLen = readIntFromLocalStorage("cscs_q_correct_streak_len:" + info.qid);

        renderPanel(box, {
          serverCorrect: 0,
          serverWrong: 0,
          localCorrect: localCorrect,
          localWrong: localWrong,
          diffCorrect: 0,
          diffWrong: 0,
          serverStreak3: 0,
          localStreak3: localStreak3,
          diffStreak3: 0,
          serverStreakLen: 0,
          localStreakLen: localStreakLen,
          diffStreakLen: 0,
          statusText: "state error"
        });
      });
  }

  function init() {
    var box = createPanel();

    function append() {
      var wrap = document.querySelector("div.wrap");
      if (wrap) {
        if (!wrap.contains(box)) {
          wrap.appendChild(box);
        }
      } else {
        if (!document.body.contains(box)) {
          document.body.appendChild(box);
        }
      }
      var btn = document.getElementById("cscs_sync_view_b_send_btn");
      if (btn) {
        btn.addEventListener("click", function (ev) {
          ev.preventDefault();
          ev.stopPropagation();
          refreshAndSend(box);
        });
      }
      refreshAndSend(box);
    }

    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", append);
    } else {
      append();
    }
  }

  window.addEventListener("online", function () {
    // 既存パネルがあるときだけ、そのパネルで再読み込み＋再送信を試みる
    var box = document.getElementById("cscs_sync_view_b");
    if (!box) return;
    refreshAndSend(box);
  });

  init();
})();
</script>


<script src="../../assets/relocate_panels.js" defer></script>
</body>
</html>