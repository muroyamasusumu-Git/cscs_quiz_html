<!DOCTYPE html>
<html lang="ja">
<head>
  <!-- observer.html　外部JS化は無し。必ずここに全ての機能のスクリプト記載　-->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>CSCS 計測オブザーバ</title>
  <style>
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      margin: 16px;
      background: #1a1a1a;
      color: #eee;
    }
    h1 { font-size: 18px; margin: 0 0 12px; color: #fff; }
    .row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }
    input[type="text"], select {
      padding: 6px 8px;
      border: 1px solid #444;
      border-radius: 6px;
      min-width: 240px;
      background: #222;
      color: #eee;
    }
    select { min-width: auto; }
    button {
      padding: 6px 10px;
      border: 1px solid #555;
      background: #2b2b2b;
      border-radius: 6px;
      cursor: pointer;
      color: #eee;
    }
    button:hover { background: #3a3a3a; }
    .grid {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(360px, 1fr));
    }
    table {
      border-collapse: collapse;
      width: 100%;
      background: #2a2a2a;
    }
    th, td {
      border: 1px solid #444;
      padding: 6px 8px;
      font-size: 13px;
      vertical-align: top;
      /* ===== 折り返しを強制（全テーブル共通） ===== */
      white-space: normal;
      overflow-wrap: anywhere;
      word-break: break-word;
    }
    th {
      background: #333;
      text-align: left;
      color: #fff;
    }
    .kbd {
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size: 12px;
      background: #333;
      padding: 2px 6px;
      border-radius: 4px;
      color: #ccc;
    }
    .muted { color: #888; }
    .ok { color: #00c97f; font-weight: 600; }
    .bad { color: #ff5c5c; font-weight: 600; }
    .warn { color: #f6c24d; font-weight: 600; }
    .changed { color: #7fd7ff; font-weight: 700; } /* ← 差分強調 */
    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      white-space: pre-wrap;
      word-break: break-word;
    }
    details {
      background: #222;
      border: 1px solid #333;
      padding: 8px;
      border-radius: 8px;
      color: #ccc;
    }
    summary { cursor: pointer; color: #eee; }
    .btn-danger {
      border-color:#ff5c5c;
      color:#ff5c5c;
      background:#2b2b2b;
    }
    .btn-danger:hover {
      background:#3b1a1a;
    }
    textarea {
      background:#1e1e1e;
      color:#eee;
      border:1px solid #444;
      border-radius:6px;
    }
  </style>
</head>
<body>
  <h1>CSCS 計測オブザーバ（qid 単位）</h1>

  <div class="row">
    <label>日付フォルダ:</label>
    <select id="daySelect" title="例）20250926"></select>
    <label>問題番号:</label>
    <select id="numSelect" title="001〜030"></select>
    <button id="applySelect">プルダウンを qid に反映</button>
    <span class="muted">→ 下の qid 入力に自動反映</span>
  </div>

  <div class="row">
    <label>qid:</label>
    <input id="qid" type="text" placeholder="例）20250926-001">
    <button id="load">読み込む</button>
    <button id="refresh" title="現在の表示を更新（差分のみ水色で強調）">更新</button>
    <button id="resetAll" title="入力値と画面の表示を初期状態へ（ストレージは消しません）">初期化</button>
    <span class="muted">URL に <span class="kbd">?qid=YYYYMMDD-NNN</span> でも可</span>
  </div>

  <div class="row">
    <strong>オリジン:</strong>
    <span id="origin" class="mono"></span>
    <span class="muted">（8789/8790 など別オリジンでA/Bを跨がないこと）</span>
  </div>

  <div class="grid" id="panel-grid">
    <section>
      <h2>トークン状態（A→B 直後のみ存在）</h2>
      <table>
        <tbody id="tbl-token"></tbody>
      </table>
      <p class="muted">※ B 読み込み時に消去されれば正常。残存＝再利用/直叩き判定の不具合の可能性。</p>
    </section>

    <section>
      <h2>当日ユニーク（JST）</h2>
      <table>
        <thead><tr><th>キー</th><th>値</th></tr></thead>
        <tbody id="tbl-unique"></tbody>
      </table>
      <p class="muted">今日1日のうち最初の正解/不正解で 1 が立つ想定。</p>
    </section>

    <section>
      <h2>qid別 積み上げカウント</h2>
      <table>
        <thead><tr><th>種別</th><th>値</th></tr></thead>
        <tbody id="tbl-qid-counters"></tbody>
      </table>
    </section>

    <section>
      <h2>全体カウンタ</h2>
      <table>
        <thead><tr><th>キー</th><th>値</th></tr></thead>
        <tbody id="tbl-global"></tbody>
      </table>
    </section>

    <section>
      <h2>選択肢カウント（qid別）</h2>
      <table>
        <thead><tr><th>選択肢</th><th>回数</th></tr></thead>
        <tbody id="tbl-choice"></tbody>
      </table>
    </section>

    <section>
      <h2>日別ログ（該当qidのみ抽出）</h2>
      <table>
        <thead><tr><th>日付</th><th>時刻</th><th>結果</th><th>選択肢</th><th>raw</th></tr></thead>
        <tbody id="tbl-daylog"></tbody>
      </table>
      <details>
        <summary>格納形式（例）</summary>
        <div class="mono">localStorage["cscs_daylog:20251110"] = [
  {"qid":"20250926-001","result":"correct","choice":"A","ts":"2025-11-10T01:23:45+09:00"},
  {"qid":"20250926-002","result":"wrong","choice":"C","ts":"2025-11-10T01:25:02+09:00"}
]</div>
      </details>
    </section>

    <!-- 追加①: 自動診断 -->
    <section>
      <h2>自動診断</h2>
      <ul id="diagnosis" class="mono" style="margin:0; padding-left:18px;"></ul>
      <p class="muted">主要な詰まりポイント（トークン/choice/ユニーク/qid積み上げ/ログ）を自動判定。</p>
    </section>

    <!-- 追加②: A/Bクイック起動 -->
    <section>
      <h2>A/B クイック起動</h2>
      <div class="row">
        <label>choice:</label>
        <select id="choiceSelect">
          <option value="A">A</option><option value="B">B</option>
          <option value="C">C</option><option value="D">D</option>
          <option value="E">E</option>
        </select>
        <button id="openA">Aを開く</button>
        <button id="openB">Bを開く（選択肢付）</button>
      </div>
      <p class="muted">パス規則：/_build_cscs_YYYYMMDD/slides/qNNN_a.html / _b.html?choice=X</p>
    </section>

    <!-- 追加③: ストレージ掃除ユーティリティ -->
    <section>
      <h2>ストレージ掃除（観測中の qid のみ）</h2>
      <div class="row">
        <button class="btn-danger" id="clearToken">トークン削除</button>
        <button class="btn-danger" id="clearUnique">当日ユニーク削除</button>
        <button class="btn-danger" id="clearQidCounters">qidカウンタ削除</button>
        <button class="btn-danger" id="clearChoice">choiceカウント削除</button>
        <button class="btn-danger" id="clearDaylog">日別ログ(直近7日・該当qid)削除</button>
      </div>
      <p class="muted">テストのやり直しを高速化。削除後は上の「読み込む」で再描画。</p>
    </section>

    <!-- 追加④: 内部デバッグ情報（追加③の復活・固定配置） -->
    <section>
      <h2>内部デバッグ情報（追加③）</h2>
      <table>
        <thead><tr><th>キー</th><th>値</th></tr></thead>
        <tbody id="tbl-debug"></tbody>
      </table>
      <p class="muted">コンソールで見ていた内部カウンタ／ログ／ストリーク等を直可視化。</p>
    </section>

    <!-- 追加⑥: 計測可否診断（A/B HTML静的解析） -->
    <section>
      <h2>計測可否診断（A/B HTML静的解析）</h2>
      <div class="row">
        <button id="auditMeasure">この qid の A/B を診断する</button>
        <span class="muted">※ 同一オリジンで公開されている必要あり（8789 など）</span>
      </div>
      <table>
        <thead>
          <tr><th>対象</th><th>項目</th><th>判定</th><th>備考</th></tr>
        </thead>
        <tbody id="tbl-audit"></tbody>
      </table>
      <details style="margin-top:8px;">
        <summary>診断内容</summary>
        <ul class="mono" style="margin:6px 0 0 18px;">
          <li>Aページ：<code>_b.html?choice=</code> へのリンク検出</li>
          <li>Aページ：<code>cscs_from_a_token</code> の発行痕跡検出</li>
          <li>Bページ：<code>?choice=</code> 受け取りロジックの痕跡</li>
          <li>Bページ：<code>b_judge_record</code>（または計測呼び出し）痕跡</li>
          <li>Bページ：<code>&lt;script src=".../b_judge_record.js"&gt;</code> の読込痕跡＋実体のSHA一致検証</li>
          <li>両ページ：qid/スキーマ参照痕跡</li>
        </ul>
      </details>
    </section>

    <!-- 追加⑦: ランタイム計測検証（非表示iframeでA→B自動遷移） -->
    <section>
      <h2>ランタイム計測検証（同一オリジン・自動操作）</h2>
      <div class="row">
        <button id="probeRuntime">A→B を自動で辿って localStorage の増分を検証</button>
        <span class="muted">※ Aをiframeで開き、最初の選択肢を自動クリック→Bへ遷移して差分測定</span>
      </div>
      <table>
        <thead><tr><th>キー</th><th>Before</th><th>After</th><th>Δ</th></tr></thead>
        <tbody id="tbl-probe"></tbody>
      </table>
      <iframe id="probeFrame" style="display:none;width:0;height:0;border:0;"></iframe>
    </section>
    
    <!-- 追加⑦: b_judge_record.js 監査（読み込み・ハッシュ・差分） -->
    <section>
      <h2>b_judge_record.js 監査</h2>
      <div class="row">
        <button id="auditJudge">検証する</button>
        <button id="saveJudgeBaseline">現在のファイルを基準に登録</button>
        <button id="clearJudgeBaseline" class="btn-danger">基準を削除</button>
      </div>
      <p class="muted">保存済み基準SHA-256: <span id="judgeBaselineSha">(未設定)</span></p>
      <table>
        <thead><tr><th>項目</th><th>結果</th><th>備考</th></tr></thead>
        <tbody id="tbl-judge-audit"></tbody>
      </table>
      <details style="margin-top:8px;">
        <summary>差分（基準 vs 現行）</summary>
        <pre id="judgeDiff" class="mono" style="white-space:pre-wrap;"></pre>
      </details>
    </section>    

    <!-- 追加⑧: 全期間集計サマリー -->
    <section>
      <h2>全期間集計サマリー</h2>
      <table>
        <thead><tr><th>項目</th><th>値</th></tr></thead>
        <tbody id="tbl-alltime"></tbody>
      </table>
      <h3 style="margin-top:10px;">全期間 選択肢分布（A〜E/その他 合算）</h3>
      <table>
        <thead><tr><th>選択肢</th><th>合計</th></tr></thead>
        <tbody id="tbl-alltime-choice"></tbody>
      </table>
      <p class="muted">※ by_qid合算・daylog合算・グローバルカウンタ・raw系（存在時）を集約表示。</p>
    </section>

    <!-- 追加⑤: レポート出力（ChatGPT貼り付け用） -->
    <section>
      <h2>レポート出力（ChatGPT貼り付け用）</h2>
      <div class="row">
        <button id="genReport">この qid のレポートを生成</button>
        <button id="clearReport" class="btn-danger">レポート削除</button>
        <button id="copyReport">全文コピー</button>
        <button id="downloadReport">.txtとして保存</button>
      </div>
      <textarea id="reportBox" class="mono" rows="18" style="width:100%; box-sizing:border-box;" readonly
        placeholder="ここにレポートが生成されます（ChatGPTにそのまま貼り付け可）"></textarea>
      <p class="muted">含まれる情報：環境・origin・qid・A→Bトークン・当日ユニーク・qid別カウント・全体カウント・choice分布・直近7日の該当qidログ・内部カウンタ群・全期間集計サマリー・localStorageキー一覧（cscs_* 前方一致）・警告/推定原因。</p>
    </section>
  </div>

  <script>
  (function() {
    "use strict";

    // --- アコーディオン化：#panel-grid 直下の <section> を自動で <details> に包む ---
    (function setupAccordion(){
      try{
        const grid = document.getElementById("panel-grid");
        if (!grid) return;
        const sections = Array.from(grid.querySelectorAll(":scope > section"));
        sections.forEach(sec=>{
          // すでに details 化済みならスキップ
          if (sec.firstElementChild && sec.firstElementChild.tagName === "DETAILS") return;

          const h2 = sec.querySelector(":scope > h2");
          const title = h2 ? h2.textContent.trim() : "パネル";
          const rest = Array.from(sec.childNodes).filter(n => !(n === h2));

          const details = document.createElement("details");
          details.open = false; // 既定は閉じる（必要なら true に変更）
          const summary = document.createElement("summary");
          const caret = document.createElement("span");
          caret.className = "caret";
          const label = document.createElement("span");
          label.textContent = title;
          summary.appendChild(caret);
          summary.appendChild(label);

          const body = document.createElement("div");
          body.className = "section-body";

          // h2 は非表示化（見出しは summary に集約）
          if (h2) h2.style.display = "none";

          // 残りのノードを body に移す
          rest.forEach(n => body.appendChild(n));

          details.appendChild(summary);
          details.appendChild(body);
          sec.appendChild(details);
        });

        // すべて開閉ボタン
        const btnOpen = document.getElementById("btnOpenAll");
        const btnClose = document.getElementById("btnCloseAll");
        if (btnOpen) btnOpen.addEventListener("click", ()=>{
          grid.querySelectorAll("details").forEach(d => d.open = true);
        });
        if (btnClose) btnClose.addEventListener("click", ()=>{
          grid.querySelectorAll("details").forEach(d => d.open = false);
        });
      }catch(e){
        console.warn("[observer] setupAccordion error:", e);
      }
    })();

    // ---- 画面内エラーバナー（最初のエラーだけ表示）----
    (function setupInlineErrorBanner(){
      let shown = false;
      window.addEventListener("error", function(ev){
        if (shown) return;
        shown = true;
        const bar = document.createElement("div");
        bar.style.cssText = "position:sticky;top:0;z-index:9999;padding:8px 12px;background:#fee;border:1px solid #c33;color:#c33;font-family:ui-monospace,Menlo,monospace;font-size:12px;border-radius:6px;margin-bottom:10px;";
        const msg = (ev && ev.message) ? ev.message : String(ev);
        bar.textContent = "JSエラー: " + msg;
        document.body.insertBefore(bar, document.body.firstChild);
      });
    })();
    
    // ===== helpers =====
    function qs(id){ return document.getElementById(id); }
    function getQuery(name){
      const m = location.search.match(new RegExp("[?&]"+name+"=([^&]+)"));
      return m ? decodeURIComponent(m[1]) : "";
    }
    function todayYYYYMMDD_JST(){
      const now = new Date();
      const jst = new Date(now.getTime() + 9*60*60*1000);
      return jst.toISOString().slice(0,10).replace(/-/g,"");
    }
    function readJSON(key, def=null){
      try{
        const v = localStorage.getItem(key);
        return v ? JSON.parse(v) : def;
      }catch(_){ return def; }
    }
    function writeJSON(key, obj){
      try{ localStorage.setItem(key, JSON.stringify(obj)); }catch(_){}
    }
    // 差分ハイライト用のスナップショット
    let PREV_SNAPSHOT = null;     // 直前描画の値
    let CURRENT_SNAPSHOT = null;  // 今回描画の値

    function beginRenderSnapshot(){ CURRENT_SNAPSHOT = {}; }
    function endRenderSnapshot(){ PREV_SNAPSHOT = CURRENT_SNAPSHOT; }

    function writeRow(tbody, k, v, prefix){
      const tr  = document.createElement("tr");
      const td1 = document.createElement("td");
      const td2 = document.createElement("td");
      td1.textContent = k;

      // 文字列化して差分判定に使う
      let valStr;
      if (typeof v === "object") {
        valStr = JSON.stringify(v);
        td2.textContent = valStr;
        td2.classList.add("mono");
      } else {
        valStr = String(v);
        td2.textContent = valStr;
      }

      // パネルごとの一意キー（未指定なら tbody.id を使う）
      const pf  = (prefix !== undefined) ? prefix : (tbody && tbody.id ? tbody.id : "");
      const key = `${pf}|${k}`;

      // 現在値を記録
      if (CURRENT_SNAPSHOT) CURRENT_SNAPSHOT[key] = valStr;

      // 前回値と違えばハイライト（初回は比較しない）
      if (PREV_SNAPSHOT && Object.prototype.hasOwnProperty.call(PREV_SNAPSHOT, key)) {
        if (PREV_SNAPSHOT[key] !== valStr) {
          td2.classList.add("changed");
        }
      }

      tr.appendChild(td1);
      tr.appendChild(td2);
      tbody.appendChild(tr);
    }
    function pad(n, len){ return String(n).padStart(len, "0"); }

    // ===== day/num selects =====
    const daySelect = qs("daySelect");
    const numSelect = qs("numSelect");
    const qidInput  = qs("qid");

    function fillDayOptions(){
      // 2025-09-26 〜 2025-12-24 を確実に生成（数値Date＋日付のみインクリメント）
      try {
        const start = new Date(2025, 8, 26);   // 9月 = 8（0始まり）
        const end   = new Date(2025, 11, 24);  // 12月 = 11
        start.setHours(0,0,0,0);
        end.setHours(0,0,0,0);

        // 一旦クリア（再実行対策）
        while (daySelect.options.length) daySelect.remove(0);

        for (let d = new Date(start.getTime()); d.getTime() <= end.getTime(); d.setDate(d.getDate()+1)) {
          const y = d.getFullYear();
          const m = pad(d.getMonth()+1, 2);
          const dd= pad(d.getDate(), 2);
          const val = `${y}${m}${dd}`;
          const opt = document.createElement("option");
          opt.value = val;
          opt.textContent = val;
          daySelect.appendChild(opt);
        }
      } catch (e) {
        // 画面に例外を可視化
        const p = document.createElement("p");
        p.className = "bad mono";
        p.textContent = "fillDayOptions エラー: " + (e && e.message ? e.message : String(e));
        document.querySelector(".row").appendChild(p);
      }
      // 画面にも件数を表示
      const info = document.createElement("span");
      info.className = "muted";
      info.style.marginLeft = "8px";
      info.textContent = `（日付 ${daySelect.options.length}件）`;
      document.querySelectorAll(".row")[0].appendChild(info);
      console.log(`fillDayOptions: ${daySelect.options.length} 日分生成`);
    }

    function fillNumOptions(){
      for (let i=1; i<=30; i++){
        const val = pad(i, 3);
        const opt = document.createElement("option");
        opt.value = val;
        opt.textContent = val;
        numSelect.appendChild(opt);
      }
    }
    function syncSelectsToQid(){
      const day = daySelect.value;
      const num = numSelect.value;
      if (day && num) {
        qidInput.value = `${day}-${num}`;
      }
    }
    function syncQidToSelects(){
      const m = qidInput.value.trim().match(/^(\d{8})-(\d{3})$/);
      if (!m) return;
      const day = m[1], num = m[2];
      const dayOpt = [...daySelect.options].some(o => o.value === day);
      if (dayOpt) daySelect.value = day;
      const numOpt = [...numSelect.options].some(o => o.value === num);
      if (numOpt) numSelect.value = num;
    }
    fillDayOptions();
    fillNumOptions();

    // 件数ダンプ（画面とconsole両方）
    (function(){
      const badge = document.createElement("span");
      badge.className = "muted";
      badge.style.marginLeft = "8px";
      badge.textContent = `（番号 ${numSelect.options.length}件）`;
      document.querySelectorAll(".row")[0].appendChild(badge);
      console.log(`fillNumOptions: ${numSelect.options.length} 件生成`);
    })();

    daySelect.addEventListener("change", syncSelectsToQid);
    numSelect.addEventListener("change", syncSelectsToQid);
    qs("applySelect").addEventListener("click", syncSelectsToQid);
    qidInput.addEventListener("blur", syncQidToSelects);

    // 保険：プルダウンが空なら強い警告（可視＋console）
    if (!daySelect.options.length || !numSelect.options.length) {
      const warn = document.createElement("p");
      warn.className = "bad mono";
      warn.style.marginTop = "4px";
      warn.textContent = `⚠ プルダウンが空です（day=${daySelect.options.length}, num=${numSelect.options.length}）。JavaScriptエラーやHTML構造を確認してください。`;
      document.querySelectorAll(".row")[0].appendChild(warn);
      console.warn("day/num select empty. Check previous JS errors above.");
    }

    // origin 表示
    qs("origin").textContent = location.origin;

    // ===== main render =====
    function render(qid){
      // 差分スナップショット開始
      beginRenderSnapshot();

      // clear panels
      ["tbl-token","tbl-unique","tbl-qid-counters","tbl-global","tbl-choice","tbl-daylog","tbl-debug","tbl-alltime","tbl-alltime-choice"]
        .forEach(id => { const el = qs(id); if (el) el.innerHTML=""; });
      // 診断欄クリア
      const diag = qs("diagnosis");
      diag.innerHTML = "";

      // --- token (session/local, new/old) ---
      const tokenKeys = [
        "cscs_from_a_token:"+qid,
        "cscs_from_a:"+qid
      ];
      const tokenState = { sessionNew:false, sessionOld:false, localNew:false, localOld:false };
      tokenKeys.forEach(k=>{
        let val = null;
        try { val = sessionStorage.getItem(k); } catch(_){}
        writeRow(qs("tbl-token"), "[session] "+k, val===null?"<null>":val||"<empty>");
        if (val) tokenState[k.includes("_token:")?"sessionNew":"sessionOld"] = true;

        val = null;
        try { val = localStorage.getItem(k); } catch(_){}
        writeRow(qs("tbl-token"), "[local] "+k, val===null?"<null>":val||"<empty>");
        if (val) tokenState[k.includes("_token:")?"localNew":"localOld"] = true;
      });

      // --- unique today ---
      const day = todayYYYYMMDD_JST();
      const uniqCorrect = localStorage.getItem("cscs_correct_done:"+day) ? 1 : 0;
      const uniqWrong   = localStorage.getItem("cscs_wrong_done:"+day) ? 1 : 0;
      writeRow(qs("tbl-unique"), "cscs_correct_done:"+day, uniqCorrect);
      writeRow(qs("tbl-unique"), "cscs_wrong_done:"+day,   uniqWrong);

      // --- per-qid counters ---
      const correctMap = readJSON("cscs_correct_by_qid", {});
      const wrongMap   = readJSON("cscs_wrong_by_qid", {});
      const qidCorrect = (correctMap && correctMap[qid])|0;
      const qidWrong   = (wrongMap && wrongMap[qid])|0;
      writeRow(qs("tbl-qid-counters"), "correct_by_qid["+qid+"]", qidCorrect);
      writeRow(qs("tbl-qid-counters"), "wrong_by_qid["+qid+"]",   qidWrong);

      // --- global counters (存在すれば表示) ---
      const gC = localStorage.getItem("cscs_correct_count");
      const gW = localStorage.getItem("cscs_wrong_count");
      if (gC !== null) writeRow(qs("tbl-global"), "cscs_correct_count", gC);
      if (gW !== null) writeRow(qs("tbl-global"), "cscs_wrong_count",   gW);

      // --- choice count per qid ---
      const choiceMap = readJSON("cscs_choice_count:"+qid, null);
      let choiceSum = 0;
      if (choiceMap) {
        ["A","B","C","D","E","その他"].forEach(opt=>{
          const val = choiceMap[opt] || 0;
          choiceSum += val|0;
          writeRow(qs("tbl-choice"), opt, val);
        });
      } else {
        writeRow(qs("tbl-choice"), "(なし)", "-");
      }

      // --- daylog（直近7日 / 指定qid抽出） ---
      let daylogCount = 0;
      for (let back=0; back<7; back++){
        const d = new Date();
        d.setDate(d.getDate() - back);
        const j = new Date(d.getTime() + 9*60*60*1000).toISOString().slice(0,10).replace(/-/g,"");
        const arr = readJSON("cscs_daylog:"+j, []);
        if (!Array.isArray(arr)) continue;
        arr.filter(x => x && x.qid === qid).forEach(item=>{
          const tr = document.createElement("tr");
          const dt = (item.ts||"").split("T");
          const date = j;
          const time = dt[1] ? dt[1].replace("+09:00","") : "";
          const result = item.result || "";
          const choice = item.choice || "";
          const raw = JSON.stringify(item);
          [date, time, result, choice, raw].forEach(txt=>{
            const td = document.createElement("td");
            td.textContent = txt;
            if (txt === raw) td.className = "mono";
            tr.appendChild(td);
          });
          qs("tbl-daylog").appendChild(tr);
          daylogCount++;
        });
      }

      // --- 内部デバッグ情報（固定セクションへ描画） ---
      const debugKeys = [
        // 当日試行カウンタ/ログ（もし採用している場合）
        "cscs_correct_attempts_"+todayYYYYMMDD_JST(),
        "cscs_wrong_attempts_"+todayYYYYMMDD_JST(),
        "cscs_correct_attempt_log_"+todayYYYYMMDD_JST(),
        "cscs_wrong_attempt_log_"+todayYYYYMMDD_JST(),
        // qid別 総量/内訳
        "cscs_q_correct_total:"+qid,
        "cscs_q_wrong_total:"+qid,
        "cscs_q_correct_counted_total:"+qid,
        "cscs_q_wrong_counted_total:"+qid,
        "cscs_q_correct_uncounted_total:"+qid,
        "cscs_q_wrong_uncounted_total:"+qid,
        // 連続正解系
        "cscs_correct_streak_len",
        "cscs_correct_streak3_total",
        "cscs_correct_streak3_log"
      ];
      const dbg = qs("tbl-debug");
      debugKeys.forEach(k=>{
        let val = localStorage.getItem(k);
        if (val === null) val = sessionStorage.getItem(k);
        if (val === null) val = "<null>";
        writeRow(dbg, k, val);
      });

      // --- 全期間集計サマリー（by_qid / daylog / global / raw / choice合算） ---
      (function renderAlltime(){
        try{
          const cm = readJSON("cscs_correct_by_qid", {}) || {};
          const wm = readJSON("cscs_wrong_by_qid", {}) || {};
          let corrSum=0, wrongSum=0, corrQ=0, wrongQ=0;
          Object.keys(cm).forEach(k=>{ const v=cm[k]|0; if(v>0) corrQ++; corrSum += v|0; });
          Object.keys(wm).forEach(k=>{ const v=wm[k]|0; if(v>0) wrongQ++; wrongSum += v|0; });

          // daylog 合算
          let daylogDays=0, daylogTotal=0, daylogCorrect=0, daylogWrong=0;
          for (let i=0;i<localStorage.length;i++){
            const k = localStorage.key(i);
            if (/^cscs_daylog:\d{8}$/.test(k)){
              const arr = readJSON(k, []);
              if (Array.isArray(arr)){
                daylogDays++;
                daylogTotal += arr.length;
                arr.forEach(it=>{
                  if (it && it.result === "correct") daylogCorrect++;
                  else if (it && it.result === "wrong") daylogWrong++;
                });
              }
            }
          }

          // グローバル / raw（存在時）
          const gC = localStorage.getItem("cscs_correct_count");
          const gW = localStorage.getItem("cscs_wrong_count");
          const rawC = localStorage.getItem("cscs_alltime_correct_raw");
          const rawW = localStorage.getItem("cscs_alltime_wrong_raw");

          // 全qidの choice 合算
          const choiceTotals = {A:0,B:0,C:0,D:0,E:0,"その他":0};
          for (let i=0;i<localStorage.length;i++){
            const k = localStorage.key(i);
            if (k.startsWith("cscs_choice_count:")){
              const m = readJSON(k, {});
              ["A","B","C","D","E","その他"].forEach(ch=>{
                choiceTotals[ch] += (m && (m[ch]|0)) || 0;
              });
            }
          }

          // テーブル出力
          writeRow(qs("tbl-alltime"), "by_qid 合算（correct）", corrSum);
          writeRow(qs("tbl-alltime"), "by_qid 合算（wrong）",   wrongSum);
          writeRow(qs("tbl-alltime"), "by_qid 対象qid数（correct>0）", corrQ);
          writeRow(qs("tbl-alltime"), "by_qid 対象qid数（wrong>0）",   wrongQ);
          if (gC !== null) writeRow(qs("tbl-alltime"), "global counter: cscs_correct_count", gC);
          if (gW !== null) writeRow(qs("tbl-alltime"), "global counter: cscs_wrong_count",   gW);
          if (rawC !== null) writeRow(qs("tbl-alltime"), "raw: cscs_alltime_correct_raw", rawC);
          if (rawW !== null) writeRow(qs("tbl-alltime"), "raw: cscs_alltime_wrong_raw",   rawW);
          writeRow(qs("tbl-alltime"), "daylog 集計（日数）", daylogDays);
          writeRow(qs("tbl-alltime"), "daylog 集計（総件数）", daylogTotal);
          writeRow(qs("tbl-alltime"), "daylog 集計（correct）", daylogCorrect);
          writeRow(qs("tbl-alltime"), "daylog 集計（wrong）",   daylogWrong);

          ["A","B","C","D","E","その他"].forEach(ch=>{
            writeRow(qs("tbl-alltime-choice"), ch, choiceTotals[ch] | 0);
          });
        }catch(e){
          writeRow(qs("tbl-alltime"), "エラー", (e && e.message) ? e.message : String(e));
        }
      })();

      // --- 自動診断 ---
      function diagItem(text, cls){
        const li = document.createElement("li");
        if (cls) li.className = cls;
        li.textContent = text;
        diag.appendChild(li);
      }
      diagItem(`origin = ${location.origin}`, "muted");

      const anyToken = tokenState.sessionNew || tokenState.sessionOld || tokenState.localNew || tokenState.localOld;
      if (!anyToken) {
        diagItem("A→Bトークンが見つからない：Aを踏まずにB直叩き/オリジン差/早期returnの可能性。", "bad");
      } else {
        diagItem("A→Bトークン痕跡あり（B読み込みで消えていれば正常）", "ok");
      }

      if (!choiceMap || choiceSum === 0) {
        diagItem("choiceカウントが0：Bの `?choice=` 受け取り失敗か、記録処理未実行。", "warn");
      } else {
        diagItem(`choiceカウントあり（合計 ${choiceSum}）`, "ok");
      }

      if (uniqCorrect===0 && uniqWrong===0) {
        diagItem("当日ユニークが0：counted条件に入っていない可能性（トークン/直叩き/条件分岐）。", "warn");
      } else {
        diagItem(`当日ユニーク OK（correct:${uniqCorrect} / wrong:${uniqWrong}）`, "ok");
      }

      if (qidCorrect===0 && qidWrong===0) {
        diagItem("qid別積み上げが0：observer入力のqidと記録側qidが不一致か、記録フロー未到達。", "warn");
      } else {
        diagItem(`qid別積み上げ OK（correct:${qidCorrect} / wrong:${qidWrong}）`, "ok");
      }

      if (daylogCount===0) {
        diagItem("日別ログに該当qid記録なし：記録そのものが走っていない可能性。", "warn");
      } else {
        diagItem(`日別ログ OK（直近7日で ${daylogCount} 件）`, "ok");
      }

      // 差分スナップショット終了（今回を次回比較の基準に）
      endRenderSnapshot();
    }

    // ===== A/B クイック起動 =====
    function buildPathsFromQid(qid){
      const m = qid.match(/^(\d{8})-(\d{3})$/);
      if (!m) return null;
      const day = m[1], num = m[2];
      const base = `/_build_cscs_${day}/slides/q${num}`;
      return { a: `${base}_a.html`, b: `${base}_b.html` };
    }
    qs("openA").addEventListener("click", ()=>{
      const qid = qidInput.value.trim();
      const p = buildPathsFromQid(qid); if (!p) return;
      window.open(p.a, "_blank");
    });
    qs("openB").addEventListener("click", ()=>{
      const qid = qidInput.value.trim();
      const p = buildPathsFromQid(qid); if (!p) return;
      const ch = qs("choiceSelect").value || "A";
      window.open(`${p.b}?choice=${encodeURIComponent(ch)}`, "_blank");
    });

    // ===== 掃除ユーティリティ =====
    function jstKey(d){ return d.toISOString().slice(0,10).replace(/-/g,""); }
    function iterRecentDays(n=7){
      const arr = [];
      for (let i=0;i<n;i++){
        const d = new Date();
        d.setDate(d.getDate()-i);
        const j = new Date(d.getTime() + 9*60*60*1000);
        arr.push(jstKey(j));
      }
      return arr;
    }
    qs("clearToken").addEventListener("click", ()=>{
      const qid = qidInput.value.trim(); if (!qid) return;
      ["cscs_from_a_token:"+qid, "cscs_from_a:"+qid].forEach(k=>{
        try{ sessionStorage.removeItem(k);}catch(_){}
        try{ localStorage.removeItem(k);}catch(_){}
      });
      alert("トークン削除完了");
    });
    qs("clearUnique").addEventListener("click", ()=>{
      const day = todayYYYYMMDD_JST();
      ["cscs_correct_done:"+day, "cscs_wrong_done:"+day].forEach(k=>{
        try{ localStorage.removeItem(k);}catch(_){}
      });
      alert("当日ユニーク削除完了");
    });
    qs("clearQidCounters").addEventListener("click", ()=>{
      const qid = qidInput.value.trim(); if (!qid) return;
      const cm = readJSON("cscs_correct_by_qid", {}); if (cm && qid in cm){ delete cm[qid]; writeJSON("cscs_correct_by_qid", cm); }
      const wm = readJSON("cscs_wrong_by_qid", {});   if (wm && qid in wm){ delete wm[qid]; writeJSON("cscs_wrong_by_qid", wm); }
      ["cscs_q_correct_total:"+qid,"cscs_q_wrong_total:"+qid,
       "cscs_q_correct_counted_total:"+qid,"cscs_q_wrong_counted_total:"+qid,
       "cscs_q_correct_uncounted_total:"+qid,"cscs_q_wrong_uncounted_total:"+qid
      ].forEach(k=>{ try{ localStorage.removeItem(k);}catch(_){ } });
      alert("qidカウンタ削除完了");
    });
    qs("clearChoice").addEventListener("click", ()=>{
      const qid = qidInput.value.trim(); if (!qid) return;
      try{ localStorage.removeItem("cscs_choice_count:"+qid);}catch(_){}
      alert("choiceカウント削除完了");
    });
    qs("clearDaylog").addEventListener("click", ()=>{
      const qid = qidInput.value.trim(); if (!qid) return;
      iterRecentDays(7).forEach(d=>{
        const key = "cscs_daylog:"+d;
        const arr = readJSON(key, null);
        if (Array.isArray(arr)) {
          const next = arr.filter(x => !(x && x.qid === qid));
          writeJSON(key, next);
        }
      });
      alert("日別ログ（直近7日・該当qid）削除完了");
    });

    // ===== reset UI (ストレージは触らずUIのみ初期表示へ) =====
    function resetUI(){
      // セレクトを先頭へ
      if (daySelect.options.length) daySelect.selectedIndex = 0;
      if (numSelect.options.length) numSelect.selectedIndex = 0;
      // choice は A に戻す
      const choiceSel = qs("choiceSelect");
      if (choiceSel) choiceSel.value = "A";
      // qid を空に
      qidInput.value = "";
      // パネルクリア
      ["tbl-token","tbl-unique","tbl-qid-counters","tbl-global","tbl-choice","tbl-daylog","tbl-debug"]
        .forEach(id => { const el = qs(id); if (el) el.innerHTML = ""; });
      const diag = qs("diagnosis"); if (diag) diag.innerHTML = "";
      // URL の ?qid を除去
      try { history.replaceState(null, "", location.pathname); } catch(_){}
      // 先頭に戻す & フォーカス
      window.scrollTo(0,0);
      qidInput.focus();
    }
    qs("resetAll").addEventListener("click", resetUI);

    // ===== boot =====
    const qidFromQuery = getQuery("qid");
    if (qidFromQuery) {
      qidInput.value = qidFromQuery;
      syncQidToSelects();
    } else {
      if (daySelect.options.length) daySelect.selectedIndex = 0;
      if (numSelect.options.length) numSelect.selectedIndex = 0;
      syncSelectsToQid();
    }

    qs("load").addEventListener("click", ()=>{
      const qid = qidInput.value.trim();
      if (!qid) return;
      syncQidToSelects();
      render(qid);
    });

    // 手動更新（前回表示との差分だけ水色太字）
    qs("refresh").addEventListener("click", ()=>{
      const qid = qidInput.value.trim();
      if (!qid) return;
      syncQidToSelects();
      render(qid);
    });
    qidInput.addEventListener("keydown", (e)=>{
      if (e.key === "Enter") {
        e.preventDefault();
        qs("load").click();
      }
    });

    if (qidInput.value.trim()) render(qidInput.value.trim());

    // ===== 計測可否診断ロジック（A/B静的解析） =====
    function writeAuditRow(k, v, cls, note=""){
      const tr = document.createElement("tr");
      const tdTarget = document.createElement("td");
      const tdItem   = document.createElement("td");
      const tdJudge  = document.createElement("td");
      const tdNote   = document.createElement("td");

      // A/B/その他にざっくり振り分け（見出しから自動推測）
      let target = "-";
      if (/^A\b/.test(k)) target = "A";
      else if (/^B\b/.test(k)) target = "B";
      tdTarget.textContent = target;

      tdItem.textContent  = k;
      tdJudge.textContent = v;
      if (cls) tdJudge.className = cls;
      tdNote.textContent  = note;

      tr.appendChild(tdTarget);
      tr.appendChild(tdItem);
      tr.appendChild(tdJudge);
      tr.appendChild(tdNote);
      qs("tbl-audit").appendChild(tr);
    }

    async function fetchText(url){
      try {
        const res = await fetch(url, {cache:"no-store"});
        const txt = await res.text();
        return {ok: res.ok, status: res.status, text: txt};
      } catch (e) {
        return {ok:false, status:"ERR", text: String(e)};
      }
    }

    function judgeA(html){
      const hasOpts = /<ol[^>]*class=["']opts["'][^>]*>/i.test(html);
      const hasBLinks = /q\d{3}_b\.html\?choice=/i.test(html);
      const hasCSCS = /cscs_/i.test(html) || /from_a/i.test(html);
      return {hasOpts, hasBLinks, hasCSCS};
    }

    function judgeB(html){
      const readsChoice = /choice=|getQuery\(['"]choice['"]\)/i.test(html);
      const writesCounts = /cscs_(?:correct|wrong|choice_count|daylog)/i.test(html);
      const hasCSCS = /cscs_/i.test(html);
      return {readsChoice, writesCounts, hasCSCS};
    }

    function buildPathsFromQidForAudit(qid){
      const m = qid.match(/^(\d{8})-(\d{3})$/);
      if (!m) return null;
      const day = m[1], num = m[2];
      const base = `/_build_cscs_${day}/slides/q${num}`;
      return {a: `${base}_a.html`, b: `${base}_b.html`};
    }

    // 小道具：相対URL解決
    function resolveURL(pageURL, src){
      try { return new URL(src, pageURL).toString(); } catch(_){ return src; }
    }
    async function sha256Text(text){
      const enc = new TextEncoder().encode(text);
      const buf = await crypto.subtle.digest("SHA-256", enc);
      const arr = Array.from(new Uint8Array(buf));
      return arr.map(b=>b.toString(16).padStart(2,"0")).join("");
    }

    qs("auditMeasure").addEventListener("click", async () => {
      const qid = qs("qid").value.trim();
      const tbody = qs("tbl-audit");
      tbody.innerHTML = "";
      window._lastAuditResults = null;

      if (!qid){
        writeAuditRow("エラー", "qidが空です。上のプルダウンか入力欄で指定してください。", "bad");
        return;
      }
      const paths = buildPathsFromQidForAudit(qid);
      if (!paths){
        writeAuditRow("エラー", "qidの形式が不正です（YYYYMMDD-NNN）。", "bad");
        return;
      }

      writeAuditRow("origin", location.origin, "muted");
      writeAuditRow("A URL", paths.a);
      writeAuditRow("B URL", paths.b);

      const [aRes, bRes] = await Promise.all([fetchText(paths.a), fetchText(paths.b)]);

      writeAuditRow("A取得", aRes.ok ? `OK (${aRes.status})` : `NG (${aRes.status})`, aRes.ok ? "ok":"bad");
      writeAuditRow("B取得", bRes.ok ? `OK (${bRes.status})` : `NG (${bRes.status})`, bRes.ok ? "ok":"bad");

      let aChecks = null, bChecks = null, judgeSrc = null, judgeSha = null, judgeShaSaved = localStorage.getItem("cscs_baseline_judge_sha256") || "";

      if (aRes.ok){
        const aj = judgeA(aRes.text);
        writeAuditRow('A: <ol class="opts">', aj.hasOpts ? "あり":"なし", aj.hasOpts ? "ok":"bad");
        writeAuditRow("A: _b.html?choice= リンク", aj.hasBLinks ? "あり":"なし", aj.hasBLinks ? "ok":"bad");
        writeAuditRow("A: cscs系痕跡", aj.hasCSCS ? "あり":"なし", aj.hasCSCS ? "ok":"warn");
        aChecks = aj;
      } else {
        writeAuditRow("A解析", "スキップ（取得失敗）", "warn");
      }

      if (bRes.ok){
        const bj = judgeB(bRes.text);
        writeAuditRow("B: choice受取処理", bj.readsChoice ? "あり":"なし", bj.readsChoice ? "ok":"bad");
        writeAuditRow("B: 記録系(cscs_*)", bj.writesCounts ? "あり":"なし", bj.writesCounts ? "ok":"warn");
        writeAuditRow("B: cscs系痕跡", bj.hasCSCS ? "あり":"なし", bj.hasCSCS ? "ok":"warn");

        // 追加：B内の script タグから b_judge_record.js を探す
        const m = bRes.text.match(/<script[^>]+src=["']([^"']*b_judge_record\.js[^"']*)["'][^>]*>/i);
        if (m){
          const resolved = resolveURL(paths.b, m[1]);
          writeAuditRow("B: b_judge_record.js 読込タグ", "あり", "ok");
          writeAuditRow("B: b_judge_record.js URL", resolved, "muted");

          // 実体取得してSHA確認
          const jsRes = await fetchText(resolved);
          if (jsRes.ok){
            writeAuditRow("b_judge_record.js 取得", `OK (${jsRes.status})`, "ok");
            const sha = await sha256Text(jsRes.text);
            judgeSrc = resolved;
            judgeSha = sha;
            writeAuditRow("b_judge_record.js SHA-256", sha, "muted");
            if (judgeShaSaved){
              writeAuditRow("保存済み基準SHA", judgeShaSaved, "muted");
              writeAuditRow("SHA一致判定", sha === judgeShaSaved ? "一致" : "不一致", sha === judgeShaSaved ? "ok":"bad");
            } else {
              writeAuditRow("基準SHA", "未登録（保存済み基準SHAがありません）", "warn");
            }
          } else {
            writeAuditRow("b_judge_record.js 取得", `NG (${jsRes.status})`, "bad");
          }
        } else {
          writeAuditRow("B: b_judge_record.js 読込タグ", "なし", "bad");
        }
        bChecks = bj;
      } else {
        writeAuditRow("B解析", "スキップ（取得失敗）", "warn");
      }

      const pass = aRes.ok && bRes.ok;
      const aOk = pass && /<ol[^>]*class=["']opts["'][^>]*>/i.test(aRes.text) && /_b\.html\?choice=/i.test(aRes.text);
      const bOk = pass && ((/choice=/i.test(bRes.text) || /getQuery\(['"]choice['"]\)/i.test(bRes.text)) && /b_judge_record|record_result|cscs_(correct|wrong|choice_count|daylog)/i.test(bRes.text));
      writeAuditRow("総評",
        (aOk && bOk)
          ? "計測可能な構造が見つかりました。AからBへ遷移して確認してください。"
          : "必須の構造が欠けています。Aの選択肢リンク、Bのchoice受け取り、b_judge_record.jsの読込/記録呼び出しを見直してください。",
        (aOk && bOk) ? "ok":"bad"
      );

      // レポート用に保存
      window._lastAuditResults = {
        qid,
        aURL: paths.a, bURL: paths.b,
        aFetch: aRes, bFetch: bRes,
        aChecks, bChecks,
        judgeSrc, judgeSha, judgeShaSaved,
        overallAOK: aOk, overallBOK: bOk
      };
    });

        // ===== レポート生成ユーティリティ =====
    function _ts(){
      const d=new Date();
      const pad=n=>String(n).padStart(2,"0");
      return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
    }
    function _kv(v){ return v===null ? "(null)" : String(v); }
    function _lsKeys(prefix){
      const keys = [];
      for(let i=0;i<localStorage.length;i++){
        const k = localStorage.key(i);
        if (prefix ? k.startsWith(prefix) : true) keys.push(k);
      }
      keys.sort();
      return keys;
    }
    function _today(){ return todayYYYYMMDD_JST(); }

    // --- fetch helper ---
    async function _fetchText(url){
      try{
        const res = await fetch(url,{cache:"no-store"});
        const txt = await res.text();
        return {ok:res.ok,status:res.status,text:txt,url};
      }catch(e){
        return {ok:false,status:"ERR",text:String(e),url};
      }
    }

    // --- SHA-256 helper (hex) ---
    async function _sha256Hex(str){
      const enc = new TextEncoder().encode(str);
      const buf = await crypto.subtle.digest("SHA-256", enc);
      const view = new Uint8Array(buf);
      return Array.from(view).map(b=>b.toString(16).padStart(2,"0")).join("");
    }

    // --- line diff (簡易) ---
    function _diffLines(baseText, curText, limit=200){
      const b = baseText.split(/\r?\n/);
      const c = curText.split(/\r?\n/);
      const max = Math.max(b.length, c.length);
      const parts = [];
      let count=0;
      for(let i=0;i<max;i++){
        const bl = b[i]!==undefined ? b[i] : "";
        const cl = c[i]!==undefined ? c[i] : "";
        if (bl===cl) continue;
        if (count>=limit){
          parts.push(`... (+${(max-i)} more differences truncated)`);
          break;
        }
        if (bl && !cl){
          parts.push(`-${String(i+1).padStart(4," ")} | ${bl}`);
          count++;
        }else if (!bl && cl){
          parts.push(`+${String(i+1).padStart(4," ")} | ${cl}`);
          count++;
        }else{
          parts.push(`-${String(i+1).padStart(4," ")} | ${bl}`);
          parts.push(`+${String(i+1).padStart(4," ")} | ${cl}`);
          count+=2;
        }
      }
      return parts.join("\n");
    }
    
    // --- judge baseline localStorage keys ---
    const JUDGE_BASE_SHA_KEY  = "cscs_baseline_judge_sha256";
    const JUDGE_BASE_TEXT_KEY = "cscs_baseline_judge_text";
    const JUDGE_BASE_DATE_KEY = "cscs_baseline_judge_saved_at";

    function _getJudgeBaselineSha(){ return localStorage.getItem(JUDGE_BASE_SHA_KEY) || ""; }
    function _getJudgeBaselineText(){ return localStorage.getItem(JUDGE_BASE_TEXT_KEY) || ""; }
    function _getJudgeBaselineDate(){ return localStorage.getItem(JUDGE_BASE_DATE_KEY) || ""; }

    function _setJudgeBaseline(sha, text){
      try{
        const now = new Date();
        const pad = n=>String(n).padStart(2,"0");
        const ts = `${now.getFullYear()}-${pad(now.getMonth()+1)}-${pad(now.getDate())} ${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(now.getSeconds())}`;
        localStorage.setItem(JUDGE_BASE_SHA_KEY, sha || "");
        localStorage.setItem(JUDGE_BASE_TEXT_KEY, text || "");
        localStorage.setItem(JUDGE_BASE_DATE_KEY, ts);
      }catch(_){}
    }

    function _clearJudgeBaseline(){
      try{
        localStorage.removeItem(JUDGE_BASE_SHA_KEY);
        localStorage.removeItem(JUDGE_BASE_TEXT_KEY);
        localStorage.removeItem(JUDGE_BASE_DATE_KEY);
      }catch(_){}
    }

    function _refreshJudgeBaselineBadge(){
      const span = qs("judgeBaselineSha");
      if (!span) return;
      const sha = _getJudgeBaselineSha();
      const dt  = _getJudgeBaselineDate();
      span.textContent = sha ? `${sha}  （保存日時: ${dt || "不明"})` : "(未設定)";
    }

    // --- b_judge_record.js 監査（UIテーブル反映） ---
    async function auditJudgeToTable(){
      const tbody = qs("tbl-judge-audit");
      if (tbody) tbody.innerHTML = "";
      const rows = (k,v,b="")=>{
        const tr = document.createElement("tr");
        const td1=document.createElement("td"); td1.textContent=k;
        const td2=document.createElement("td"); td2.textContent=v;
        const td3=document.createElement("td"); td3.textContent=b;
        tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3);
        tbody.appendChild(tr);
      };

      const res = await _fetchText("/assets/b_judge_record.js");
      rows("取得", res.ok?`OK (${res.status})`:`NG (${res.status})`, res.url||"");
      if (!res.ok) return;

      const current = res.text;
      const size = current.length;
      const sha = await _sha256Hex(current);
      rows("サイズ(bytes)", String(size));
      rows("SHA-256", sha);

      const baseSha = _getJudgeBaselineSha();
      const baseText = _getJudgeBaselineText();
      rows("保存済み基準SHA", baseSha || "(未設定)");

      if (baseSha){
        rows("一致判定", sha===baseSha ? "一致":"不一致", sha===baseSha ? "" : "差分を下部に表示");
        if (sha!==baseSha && baseText){
          const diff = _diffLines(baseText, current, 400);
          const pre = qs("judgeDiff");
          if (pre) pre.textContent = diff || "(差分検出0)";
        }else{
          const pre = qs("judgeDiff"); if (pre) pre.textContent = "";
        }
      }else{
        rows("一致判定", "(基準未設定)");
        const pre = qs("judgeDiff"); if (pre) pre.textContent = "";
      }
    }

    // ランタイム計測検証：Aをiframeで開いて最初の選択肢クリック→Bへ遷移→localStorage差分
    function snapshotFor(qid){
      const day = _today();
      const snap = {};
      snap["cscs_correct_done:"+day] = localStorage.getItem("cscs_correct_done:"+day);
      snap["cscs_wrong_done:"+day]   = localStorage.getItem("cscs_wrong_done:"+day);
      const cm = readJSON("cscs_correct_by_qid", {});
      const wm = readJSON("cscs_wrong_by_qid", {});
      snap["correct_by_qid"] = cm && cm[qid] ? cm[qid] : 0;
      snap["wrong_by_qid"]   = wm && wm[qid] ? wm[qid] : 0;
      const chm = readJSON("cscs_choice_count:"+qid, {});
      snap["choice_A"] = chm?.A|0; snap["choice_B"] = chm?.B|0; snap["choice_C"] = chm?.C|0; snap["choice_D"] = chm?.D|0; snap["choice_E"] = chm?.E|0; snap["choice_other"] = chm?.その他|0;
      return snap;
    }
    function writeProbeRow(k, before, after){
      const tr = document.createElement("tr");
      const td1 = document.createElement("td"); td1.textContent = k;
      const td2 = document.createElement("td"); td2.textContent = before ?? "(null)";
      const td3 = document.createElement("td"); td3.textContent = after ?? "(null)";
      const td4 = document.createElement("td");
      let d = null;
      if (before==null && after!=null) d = "(new)";
      else if (before!=null && after!=null && !isNaN(before) && !isNaN(after)) d = String((after|0)-(before|0));
      else if (before!=null && after!=null) d = before===after ? "0" : "changed";
      else d = "-";
      td4.textContent = d;
      tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3); tr.appendChild(td4);
      qs("tbl-probe").appendChild(tr);
    }

    qs("probeRuntime").addEventListener("click", async ()=>{
      const qid = qs("qid").value.trim();
      const tbody = qs("tbl-probe");
      tbody.innerHTML = "";
      window._lastProbeResults = null;

      if (!qid){ alert("qid を指定してください"); return; }
      const p = buildPathsFromQidForAudit(qid);
      if (!p){ alert("qid形式が不正です（YYYYMMDD-NNN）"); return; }

      const before = snapshotFor(qid);
      const iframe = qs("probeFrame");
      let clicked = false;
      let reachedB = false;
      let watchdogTimer = null;

      function clearWatchdog(){
        if (watchdogTimer){ clearTimeout(watchdogTimer); watchdogTimer = null; }
      }

      const onALoad = ()=>{
        try{
          const doc = iframe.contentDocument;
          if (!doc) throw new Error("iframe doc 取得失敗");

          // 1) aタグ（_b.html?choice=）優先
          let link = doc.querySelector('ol.opts a[href*="_b.html?choice="], a[href*="_b.html?choice="]');

          // 2) data-choice を持つ要素でも遷移を許容（ボタン等）
          if (!link) {
            const btn = doc.querySelector('[data-choice], button[data-choice], a[data-choice]');
            if (btn) {
              clicked = true;
              // 新規タブ抑止
              try { btn.setAttribute("target", "_self"); } catch(_){}
              btn.click();
              return;
            }
          }

          if (!link) throw new Error('A内に遷移トリガが見つからない（<a href*="_b.html?choice="] または [data-choice]）');

          // 新規タブ抑止（iframe内遷移）
          try { link.setAttribute("target", "_self"); } catch(_){}

          clicked = true;
          link.click();
        }catch(e){
          alert("Aページ自動クリック失敗: "+ (e?.message||e));
        }
      };

      const onBLoadThenCheck = ()=>{
        reachedB = true;
        clearWatchdog();
        setTimeout(()=>{
          const after = snapshotFor(qid);
          const keys = [
            "cscs_correct_done:"+_today(),
            "cscs_wrong_done:"+_today(),
            "correct_by_qid",
            "wrong_by_qid",
            "choice_A","choice_B","choice_C","choice_D","choice_E","choice_other"
          ];
          keys.forEach(k=>writeProbeRow(k, before[k], after[k]));
          window._lastProbeResults = { before, after };

          // 差分ゼロ時のヒント出力
          const allZero =
            (before["correct_by_qid"]===after["correct_by_qid"]) &&
            (before["wrong_by_qid"]===after["wrong_by_qid"]) &&
            (before["choice_A"]===after["choice_A"] &&
             before["choice_B"]===after["choice_B"] &&
             before["choice_C"]===after["choice_C"] &&
             before["choice_D"]===after["choice_D"] &&
             before["choice_E"]===after["choice_E"] &&
             before["choice_other"]===after["choice_other"]);

          if (allZero){
            console.warn("[probe] 差分が出ていません。Bで記録関数が未実行か、同一オリジンでない可能性、または記録猶予不足です。");
          }
        }, 900); // B内JS実行の猶予を少し長めに
      };

      // A→B遷移監視
      iframe.onload = ()=>{
        try{
          const href = iframe.contentWindow.location.href;
          if (!clicked) onALoad();
          if (/_b\.html\?choice=/i.test(href)) {
            onBLoadThenCheck();
          }
        }catch(_){
          // 同一オリジンでない場合はここで例外になり得る
        }
      };

      // Bに到達しない場合のウォッチドッグ（3秒）
      watchdogTimer = setTimeout(()=>{
        if (!reachedB){
          alert("B への自動遷移を検出できませんでした。Aのリンクが新規タブで開かれていないか、同一オリジンか、または A がJS経由で遷移していないか確認してください。");
        }
      }, 3000);

      // Aを読み込み
      iframe.src = p.a;
    });


    // --- レポート（静的診断＆ランタイム検証も確実に反映） ---
    async function buildReportAsync(qid){
      const lines = [];
      lines.push("=== CSCS observer report ===");
      lines.push(`timestamp: ${_ts()}`);
      lines.push(`origin: ${location.origin}`);
      lines.push(`qid: ${qid}`);
      lines.push("");

      // A→B token
      lines.push("[A→B トークン]");
      const tk1 = sessionStorage.getItem("cscs_from_a_token:"+qid) ?? localStorage.getItem("cscs_from_a_token:"+qid);
      const tk2 = sessionStorage.getItem("cscs_from_a:"+qid) ?? localStorage.getItem("cscs_from_a:"+qid);
      lines.push(`cscs_from_a_token:${qid}: ${_kv(tk1)}`);
      lines.push(`cscs_from_a:${qid}: ${_kv(tk2)}`);
      lines.push("");

      // 当日ユニーク
      const day = _today();
      lines.push("[当日ユニーク]");
      lines.push(`cscs_correct_done:${day} = ${_kv(localStorage.getItem("cscs_correct_done:"+day))}`);
      lines.push(`cscs_wrong_done:${day} = ${_kv(localStorage.getItem("cscs_wrong_done:"+day))}`);
      lines.push("");

      // qid 別
      lines.push("[qid別カウント]");
      const cm = readJSON("cscs_correct_by_qid", {});
      const wm = readJSON("cscs_wrong_by_qid", {});
      lines.push(`cscs_correct_by_qid[${qid}]: ${cm && cm[qid] ? cm[qid] : 0}`);
      lines.push(`cscs_wrong_by_qid[${qid}]: ${wm && wm[qid] ? wm[qid] : 0}`);
      lines.push("");

      // 全体
      lines.push("[全体カウント]");
      lines.push(`cscs_correct_count: ${_kv(localStorage.getItem("cscs_correct_count"))}`);
      lines.push(`cscs_wrong_count: ${_kv(localStorage.getItem("cscs_wrong_count"))}`);
      lines.push("");

      // choice 分布
      lines.push("[選択肢分布]");
      const chm = readJSON("cscs_choice_count:"+qid, {});
      ["A","B","C","D","E","その他"].forEach(k=>{
        lines.push(`${k}: ${chm && chm[k] ? chm[k] : 0}`);
      });
      lines.push("");

      // 直近7日ログ（該当qid）
      lines.push("[直近7日間ログ（該当qidのみ）]");
      for (let back=0; back<7; back++){
        const d = new Date();
        d.setDate(d.getDate()-back);
        const j = new Date(d.getTime() + 9*60*60*1000).toISOString().slice(0,10).replace(/-/g,"");
        const arr = readJSON("cscs_daylog:"+j, []);
        if (Array.isArray(arr)) {
          arr.filter(x => x && x.qid === qid).forEach(item=>{
            lines.push(`- ${j} ${item.ts ? item.ts.split("T")[1].replace("+09:00",""):""}  ${item.result||""}  choice=${item.choice||""}  raw=${JSON.stringify(item)}`);
          });
        }
      }
      lines.push("");

      // 内部カウンタ群
      lines.push("[内部カウンタ群]");
      const dbgKeys = [
        "cscs_correct_attempts_"+_today(),
        "cscs_wrong_attempts_"+_today(),
        "cscs_q_correct_total:"+qid,
        "cscs_q_wrong_total:"+qid,
        "cscs_correct_streak_len",
        "cscs_correct_streak3_total",
        "cscs_correct_streak3_log"
      ];
      dbgKeys.forEach(k=>{
        const v = localStorage.getItem(k) ?? sessionStorage.getItem(k);
        lines.push(`${k}: ${_kv(v)}`);
      });

      // 全期間集計サマリー
      lines.push("");
      lines.push("[全期間集計サマリー]");
      try{
        const cm = readJSON("cscs_correct_by_qid", {}) || {};
        const wm = readJSON("cscs_wrong_by_qid", {}) || {};
        let corrSum=0, wrongSum=0, corrQ=0, wrongQ=0;
        Object.keys(cm).forEach(k=>{ const v=cm[k]|0; if(v>0) corrQ++; corrSum += v|0; });
        Object.keys(wm).forEach(k=>{ const v=wm[k]|0; if(v>0) wrongQ++; wrongSum += v|0; });

        let daylogDays=0, daylogTotal=0, daylogCorrect=0, daylogWrong=0;
        for (let i=0;i<localStorage.length;i++){
          const k = localStorage.key(i);
          if (/^cscs_daylog:\d{8}$/.test(k)){
            const arr = readJSON(k, []);
            if (Array.isArray(arr)){
              daylogDays++; daylogTotal += arr.length;
              arr.forEach(it=>{
                if (it && it.result === "correct") daylogCorrect++;
                else if (it && it.result === "wrong") daylogWrong++;
              });
            }
          }
        }

        const gC = localStorage.getItem("cscs_correct_count");
        const gW = localStorage.getItem("cscs_wrong_count");
        const rawC = localStorage.getItem("cscs_alltime_correct_raw");
        const rawW = localStorage.getItem("cscs_alltime_wrong_raw");

        lines.push(`by_qid 合算（correct）: ${corrSum}`);
        lines.push(`by_qid 合算（wrong）  : ${wrongSum}`);
        lines.push(`by_qid 対象qid数（correct>0）: ${corrQ}`);
        lines.push(`by_qid 対象qid数（wrong>0）  : ${wrongQ}`);
        if (gC !== null) lines.push(`global counter: cscs_correct_count: ${gC}`);
        if (gW !== null) lines.push(`global counter: cscs_wrong_count  : ${gW}`);
        if (rawC !== null) lines.push(`raw: cscs_alltime_correct_raw: ${rawC}`);
        if (rawW !== null) lines.push(`raw: cscs_alltime_wrong_raw  : ${rawW}`);
        lines.push(`daylog 集計（日数）   : ${daylogDays}`);
        lines.push(`daylog 集計（総件数） : ${daylogTotal}`);
        lines.push(`daylog 集計（correct）: ${daylogCorrect}`);
        lines.push(`daylog 集計（wrong）  : ${daylogWrong}`);

        // 全qid choice 合算
        const choiceTotals = {A:0,B:0,C:0,D:0,E:0,"その他":0};
        for (let i=0;i<localStorage.length;i++){
          const k = localStorage.key(i);
          if (k.startsWith("cscs_choice_count:")){
            const m = readJSON(k, {});
            ["A","B","C","D","E","その他"].forEach(ch=>{
              choiceTotals[ch] += (m && (m[ch]|0)) || 0;
            });
          }
        }
        lines.push("全期間 選択肢分布（合算）:");
        ["A","B","C","D","E","その他"].forEach(ch=>{
          lines.push(` - ${ch}: ${choiceTotals[ch]|0}`);
        });
      }catch(e){
        lines.push("(全期間集計の生成中にエラー) " + ((e && e.message) ? e.message : String(e)));
      }

      // ---- 計測可否診断（A/B HTML静的解析：直近の実行結果をそのまま反映 or その場で取得） ----
      lines.push("");
      lines.push("[計測可否診断（A/B HTML静的解析）]");

      if (!window._lastAuditResults || window._lastAuditResults.qid !== qid){
        // ユーザーが未実行なら、その場で実行して反映
        const paths = buildPathsFromQidForAudit(qid);
        if (paths){
          const aRes = await fetchText(paths.a);
          const bRes = await fetchText(paths.b);
          lines.push(`A取得: ${aRes.ok ? "OK":"NG"} (${aRes.status}) ${paths.a}`);
          lines.push(`B取得: ${bRes.ok ? "OK":"NG"} (${bRes.status}) ${paths.b}`);
          if (aRes.ok){
            const aj = judgeA(aRes.text);
            lines.push(`A: <ol class="opts"> = ${aj.hasOpts?"あり":"なし"}`);
            lines.push(`A: _b.html?choice= リンク = ${aj.hasBLinks?"あり":"なし"}`);
            lines.push(`A: cscs_from_a_token = ${aj.hasCSCS?"あり":"なし"}`);
          }
          if (bRes.ok){
            const bj = judgeB(bRes.text);
            lines.push(`B: choice受取 = ${bj.readsChoice?"あり":"なし"}`);
            lines.push(`B: 計測呼び出し = ${bj.writesCounts?"あり":"なし"}`);
            // Bの b_judge_record.js 読み込み検出＋SHA
            const m = bRes.text.match(/<script[^>]+src=["']([^"']*b_judge_record\.js[^"']*)["'][^>]*>/i);
            if (m){
              const resolved = resolveURL(paths.b, m[1]);
              lines.push(`B: b_judge_record.js 読込タグ: あり`);
              lines.push(`B: b_judge_record.js URL: ${resolved}`);
              const jsRes = await fetchText(resolved);
              if (jsRes.ok){
                const sha = await sha256Text(jsRes.text);
                const saved = localStorage.getItem("cscs_baseline_judge_sha256") || "";
                lines.push(`b_judge_record.js SHA-256: ${sha}`);
                if (saved){
                  lines.push(`保存済み基準SHA: ${saved}`);
                  lines.push(`SHA一致判定: ${sha===saved ? "一致":"不一致"}`);
                } else {
                  lines.push("保存済み基準SHA: (未登録)");
                }
              } else {
                lines.push(`b_judge_record.js 取得: NG (${jsRes.status})`);
              }
            } else {
              lines.push(`B: b_judge_record.js 読込タグ: なし`);
            }
          }
          const aOk = aRes.ok && /<ol[^>]*class=["']opts["'][^>]*>/i.test(aRes.text) && /_b\.html\?choice=/i.test(aRes.text);
          const bOk = bRes.ok && ((/choice=/i.test(bRes.text) || /getQuery\(['"]choice['"]\)/i.test(bRes.text)) && /b_judge_record|record_result|cscs_(correct|wrong|choice_count|daylog)/i.test(bRes.text));
          lines.push(`総評: A=${aOk?"OK":"NG"} / B=${bOk?"OK":"NG"}`);
        } else {
          lines.push("qid形式不正のため診断スキップ");
        }
      } else {
        const r = window._lastAuditResults;
        lines.push(`A取得: ${r.aFetch.ok ? "OK":"NG"} (${r.aFetch.status}) ${r.aURL}`);
        lines.push(`B取得: ${r.bFetch.ok ? "OK":"NG"} (${r.bFetch.status}) ${r.bURL}`);
        if (r.aChecks){
          lines.push(`A: <ol class="opts"> = ${r.aChecks.hasOpts?"あり":"なし"}`);
          lines.push(`A: _b.html?choice= リンク = ${r.aChecks.hasBLinks?"あり":"なし"}`);
          lines.push(`A: cscs_from_a_token = ${r.aChecks.hasCSCS?"あり":"なし"}`);
        }
        if (r.bChecks){
          lines.push(`B: choice受取 = ${r.bChecks.readsChoice?"あり":"なし"}`);
          lines.push(`B: 計測呼び出し = ${r.bChecks.writesCounts?"あり":"なし"}`);
          if (r.judgeSrc){
            lines.push(`B: b_judge_record.js 読込タグ: あり`);
            lines.push(`B: b_judge_record.js URL: ${r.judgeSrc}`);
            lines.push(`b_judge_record.js SHA-256: ${r.judgeSha || "(取得失敗)"}`);
            if (r.judgeShaSaved){
              lines.push(`保存済み基準SHA: ${r.judgeShaSaved}`);
              lines.push(`SHA一致判定: ${r.judgeSha && r.judgeShaSaved ? (r.judgeSha===r.judgeShaSaved ? "一致":"不一致") : "未知"}`);
            } else {
              lines.push("保存済み基準SHA: (未登録)");
            }
          } else {
            lines.push(`B: b_judge_record.js 読込タグ: なし`);
          }
        }
        lines.push(`総評: A=${r.overallAOK?"OK":"NG"} / B=${r.overallBOK?"OK":"NG"}`);
      }

      // localStorage keys (cscs_*)
      lines.push("");
      lines.push("[localStorageキー一覧（cscs_*）]");
      _lsKeys("cscs_").forEach(k=>lines.push(" - "+k));

      // ---- ランタイム計測検証（直近の実行結果をそのまま反映）----
      lines.push("");
      lines.push("[ランタイム計測検証（A→B自動遷移の差分）]");
      if (window._lastProbeResults){
        const {before, after} = window._lastProbeResults;
        const keys = [
          "cscs_correct_done:"+_today(),
          "cscs_wrong_done:"+_today(),
          "correct_by_qid",
          "wrong_by_qid",
          "choice_A","choice_B","choice_C","choice_D","choice_E","choice_other"
        ];
        keys.forEach(k=>{
          const b = before[k], a = after[k];
          const delta = (b==null||a==null) ? "n/a" : (!isNaN(b)&&!isNaN(a) ? String((a|0)-(b|0)) : (b===a?"0":"changed"));
          lines.push(`${k}: before=${b??"(null)"} / after=${a??"(null)"} / Δ=${delta}`);
        });
      } else {
        lines.push("（未実行）右上の「ランタイム計測検証」ボタンでA→B自動遷移を実行してください。");
      }

      return lines.join("\n");
    }

    qs("genReport").addEventListener("click", async ()=>{
      const qid = qs("qid").value.trim();
      if (!qid) { alert("qid を指定してください"); return; }
      qs("genReport").disabled = true;
      try{
        const text = await buildReportAsync(qid);
        qs("reportBox").value = text;
      } finally {
        qs("genReport").disabled = false;
      }
    });

    // （関数外に出ていたレポート断片を削除しました。b_judge_record.js の検証は buildReportAsync 内で実施済み）

    // （重複する genReport ハンドラを削除しました。buildReportAsync 版のみ残します）

    qs("copyReport").addEventListener("click", async ()=>{
      const ta = qs("reportBox");
      if (!ta.value){ alert("先にレポートを生成してください"); return; }
      try{
        await navigator.clipboard.writeText(ta.value);
        alert("コピーしました");
      }catch(_){
        ta.select(); document.execCommand("copy");
        alert("コピーしました（fallback）");
      }
    });

    // レポート削除（テキストエリアを空にするだけ。ストレージ等は触らない）
    qs("clearReport").addEventListener("click", ()=>{
      const ta = qs("reportBox");
      if (!ta) return;
      ta.value = "";
      alert("レポートを削除しました。必要なら『この qid のレポートを生成』を再実行してください。");
    });    

    qs("downloadReport").addEventListener("click", ()=>{
      const ta = qs("reportBox"); if (!ta.value) return;
      const blob = new Blob([ta.value], {type:"text/plain;charset=utf-8"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      const qid = qs("qid").value.trim() || "unknown";
      a.href = url;
      a.download = `cscs_observer_${qid}.txt`;
      document.body.appendChild(a);
      a.click();
      setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
    });

    // ===== b_judge_record.js 監査のイベント =====
    _refreshJudgeBaselineBadge();

    qs("auditJudge").addEventListener("click", async ()=>{
      await auditJudgeToTable();
    });

    qs("saveJudgeBaseline").addEventListener("click", async ()=>{
      const res = await _fetchText("/assets/b_judge_record.js");
      if (!res.ok){ alert("b_judge_record.js を取得できませんでした"); return; }
      const sha = await _sha256Hex(res.text);
      _setJudgeBaseline(sha, res.text);
      _refreshJudgeBaselineBadge();
      alert("現在の b_judge_record.js を基準として保存しました（SHA と本文）");
    });

    qs("clearJudgeBaseline").addEventListener("click", ()=>{
      _clearJudgeBaseline();
      _refreshJudgeBaselineBadge();
      const pre = qs("judgeDiff"); if (pre) pre.textContent = "";
      const tbody = qs("tbl-judge-audit"); if (tbody) tbody.innerHTML = "";
      alert("保存済みの基準を削除しました");
    });
    
  })();
  </script>
<!-- === 集計系リセット パネル（追記） === -->
<style>
  #cscs_reset_panel{
    position: fixed; right: 12px; bottom: 12px; z-index: 99999;
    background: #111; color: #fff; border: 1px solid #444; border-radius: 8px;
    padding: 10px 12px; font: 12px/1.4 -apple-system,system-ui,Segoe UI,Roboto,sans-serif;
    box-shadow: 0 6px 24px rgba(0,0,0,.35);
  }
  #cscs_reset_panel button{
    margin: 4px 0; width: 180px; padding: 6px 8px; border-radius: 6px; border: 1px solid #555;
    background:#222; color:#fff; cursor:pointer;
  }
  #cscs_reset_panel button:hover{ background:#2a2a2a; }
  #cscs_reset_panel .note{ color:#bbb; margin-top:6px; }
</style>
<div id="cscs_reset_panel">
  <div style="font-weight:600;margin-bottom:6px;">集計リセット</div>
  <button id="btn_reset_counts">集計のみリセット</button>
  <button id="btn_reset_today">本日ぶんのみ</button>
  <button id="btn_reset_all" style="border-color:#884;background:#351;">完全リセット</button>
  <div class="note">※ 完全は全部（お気に入り等も消えます）</div>
</div>
<script>
(function(){
  // ★ 集計系キー（学習ログのみ：トークンは含めない）
  const COUNT_KEYS_EXACT = [
    'cscs_correct_daily_log',
    'cscs_wrong_daily_log',
    'cscs_correct_log',         // 互換
    'cscs_wrong_log',           // 互換
    'cscs_alltime_correct_raw', // 全期間カウンタ
    'cscs_alltime_wrong_raw',
    'cscs_last_seen_day'        // 参照メタ
  ];
  const ROLLUP_PREFIX = /^cscs_rollup:\d{8}$/; // 例: cscs_rollup:20250926

  function todayStr(){
    try{
      const d = new Date();
      const pad = n => String(n).padStart(2,"0");
      return d.getFullYear()+pad(d.getMonth()+1)+pad(d.getDate());
    }catch(_){ return ""; }
  }

  function removeByPredicate(pred){
    const removed = [];
    // localStorage は列挙中に長さが変わるため逆順で安全に
    for (let i = localStorage.length - 1; i >= 0; i--) {
      const k = localStorage.key(i);
      if (pred(k)) {
        removed.push(k);
        try { localStorage.removeItem(k); } catch(_){}
      }
    }
    return removed;
  }

  // === 1) 集計のみ（全期間）リセット：トークンは残す ===
  document.getElementById("btn_reset_counts").addEventListener("click", ()=>{
    const removed = [];

    // (a) 完全一致キーを空に/削除
    COUNT_KEYS_EXACT.forEach(k=>{
      if (localStorage.getItem(k) !== null) {
        // 日次ログは "{}" に初期化、それ以外は "0" or 削除
        if (k === 'cscs_correct_daily_log' || k === 'cscs_wrong_daily_log') {
          try { localStorage.setItem(k, "{}"); removed.push(k+"(reset)"); } catch(_){}
        } else if (k === 'cscs_alltime_correct_raw' || k === 'cscs_alltime_wrong_raw') {
          try { localStorage.setItem(k, "0"); removed.push(k+"(zero)"); } catch(_){}
        } else if (k === 'cscs_last_seen_day') {
          try { localStorage.removeItem(k); removed.push(k); } catch(_){}
        } else {
          try { localStorage.removeItem(k); removed.push(k); } catch(_){}
        }
      }
    });

    // (b) ロールアップ日別キーは全削除
    removed.push(...removeByPredicate(k => ROLLUP_PREFIX.test(k)));

    alert("集計系のみリセット: " + removed.length + "件");
    console.log("[observer:reset-counts] removed", removed);
  });

  // === 2) 本日ぶんのみ：当日の日付プロパティだけを削除（トークンは触らない） ===
  document.getElementById("btn_reset_today").addEventListener("click", ()=>{
    const day = todayStr();
    const removed = [];

    // (a) 日次ログ（オブジェクトから当日プロパティだけ削除）
    ['cscs_correct_daily_log','cscs_wrong_daily_log'].forEach(k=>{
      try{
        const obj = JSON.parse(localStorage.getItem(k) || '{}');
        if (Object.prototype.hasOwnProperty.call(obj, day)) {
          delete obj[day];
          localStorage.setItem(k, JSON.stringify(obj));
          removed.push(`${k}.${day}`);
        }
      }catch(_){}
    });

    // (b) 当日のロールアップキーのみ削除
    try{
      const rk = `cscs_rollup:${day}`;
      if (localStorage.getItem(rk) !== null) {
        localStorage.removeItem(rk);
        removed.push(rk);
      }
    }catch(_){}

    // (c) 全期間カウンタは触らない（“本日ぶんのみ”のため）
    alert("本日ぶんのみリセット: " + removed.length + "件");
    console.log("[observer:reset-today] removed", removed);
  });

  // === 3) 完全リセット：localStorage / sessionStorage 全消し（トークン含む） ===
  document.getElementById("btn_reset_all").addEventListener("click", ()=>{
    if (!confirm("本当に完全リセットしますか？（お気に入りや設定も含め全消去）")) return;
    try { localStorage.clear(); } catch(_){}
    try { sessionStorage.clear(); } catch(_){}
    alert("完全リセット完了");
  });
})();
</script>
<!-- === /集計系リセット パネル === -->
</body>
</html>